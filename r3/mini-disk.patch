From b44799eb3310aef2c971bd2c18e43224275e70b5 Mon Sep 17 00:00:00 2001
From: i l <il@l.com>
Date: Mon, 26 Jan 2026 20:43:16 -0300
Subject: [PATCH] luci mini disk

---
 package/luci-app-mini-diskmanager/Makefile    |   21 +
 .../luci-static/resources/view/mdmconfig.js   |  365 ++
 .../luci-static/resources/view/mdmsupport.js  |  147 +
 .../resources/view/minidiskmanager.js         | 5442 +++++++++++++++++
 .../po/de/mini-diskmanager.po                 | 1253 ++++
 .../po/fr/mini-diskmanager.po                 | 1312 ++++
 .../po/it/mini-diskmanager.po                 | 1247 ++++
 .../po/pl/mini-diskmanager.po                 | 1259 ++++
 .../po/ru/mini-diskmanager.po                 | 1254 ++++
 .../po/vi/mini-diskmanager.po                 | 1251 ++++
 .../po/zh_Hans/mini-diskmanager.po            | 1251 ++++
 .../po/zh_Hant/mini-diskmanager.po            | 1815 ++++++
 .../root/etc/config/mdmconfig                 |    2 +
 .../root/etc/uci-defaults/setup_prm.sh        |   11 +
 .../root/usr/libexec/rpcd/minidiskmanager     | 1313 ++++
 .../menu.d/luci-app-mini-diskmanager.json     |   41 +
 .../rpcd/acl.d/luci-app-mini-diskmanager.json |  130 +
 17 files changed, 18114 insertions(+)
 create mode 100644 package/luci-app-mini-diskmanager/Makefile
 create mode 100644 package/luci-app-mini-diskmanager/htdocs/luci-static/resources/view/mdmconfig.js
 create mode 100644 package/luci-app-mini-diskmanager/htdocs/luci-static/resources/view/mdmsupport.js
 create mode 100644 package/luci-app-mini-diskmanager/htdocs/luci-static/resources/view/minidiskmanager.js
 create mode 100644 package/luci-app-mini-diskmanager/po/de/mini-diskmanager.po
 create mode 100644 package/luci-app-mini-diskmanager/po/fr/mini-diskmanager.po
 create mode 100644 package/luci-app-mini-diskmanager/po/it/mini-diskmanager.po
 create mode 100644 package/luci-app-mini-diskmanager/po/pl/mini-diskmanager.po
 create mode 100644 package/luci-app-mini-diskmanager/po/ru/mini-diskmanager.po
 create mode 100644 package/luci-app-mini-diskmanager/po/vi/mini-diskmanager.po
 create mode 100644 package/luci-app-mini-diskmanager/po/zh_Hans/mini-diskmanager.po
 create mode 100644 package/luci-app-mini-diskmanager/po/zh_Hant/mini-diskmanager.po
 create mode 100644 package/luci-app-mini-diskmanager/root/etc/config/mdmconfig
 create mode 100644 package/luci-app-mini-diskmanager/root/etc/uci-defaults/setup_prm.sh
 create mode 100644 package/luci-app-mini-diskmanager/root/usr/libexec/rpcd/minidiskmanager
 create mode 100644 package/luci-app-mini-diskmanager/root/usr/share/luci/menu.d/luci-app-mini-diskmanager.json
 create mode 100644 package/luci-app-mini-diskmanager/root/usr/share/rpcd/acl.d/luci-app-mini-diskmanager.json

diff --git a/package/luci-app-mini-diskmanager/Makefile b/package/luci-app-mini-diskmanager/Makefile
new file mode 100644
index 0000000000..9630b6a2a3
--- /dev/null
+++ b/package/luci-app-mini-diskmanager/Makefile
@@ -0,0 +1,21 @@
+#
+# Copyright 2025-2026 Rafał Wabik - IceG - From eko.one.pl forum
+#
+# MIT License.
+#
+
+include $(TOPDIR)/rules.mk
+
+PKG_NAME:=luci-app-mini-diskmanager
+PKG_VERSION:=1.0.24
+PKG_RELEASE:=20260124
+LUCI_TITLE:=LuCI JS Support for Mini Disk Manager
+MAINTAINER:=Rafał Wabik <4Rafal@gmail.com>
+LUCI_DESCRIPTION:=Interface for managing disk partitions and filesystems in OpenWrt.
+LUCI_DEPENDS:=+luci-base +block-mount +fdisk +parted +lsblk
+LUCI_PKGARCH:=all
+
+include $(TOPDIR)/feeds/luci/luci.mk
+
+# call BuildPackage - OpenWrt buildroot signature
+
diff --git a/package/luci-app-mini-diskmanager/htdocs/luci-static/resources/view/mdmconfig.js b/package/luci-app-mini-diskmanager/htdocs/luci-static/resources/view/mdmconfig.js
new file mode 100644
index 0000000000..29d5cbf565
--- /dev/null
+++ b/package/luci-app-mini-diskmanager/htdocs/luci-static/resources/view/mdmconfig.js
@@ -0,0 +1,365 @@
+'use strict';
+'require view';
+'require form';
+'require rpc';
+'require uci';
+'require ui';
+'require fs';
+
+/*
+
+  Copyright 2025-2026 Rafał Wabik - IceG - From eko.one.pl forum
+  
+  MIT License
+  
+*/
+
+var callInitList = rpc.declare({
+    object: 'luci',
+    method: 'getInitList',
+    params: ['name'],
+    expect: { '': {} }
+});
+
+var pkg = {
+    get Name() { return 'mini-diskmanager'; },
+    get URL()  { return 'https://openwrt.org/packages/pkgdata/' + this.Name + '/'; },
+    get pkgMgrURINew() { return 'admin/system/package-manager'; },
+    get pkgMgrURIOld() { return 'admin/system/opkg'; },
+    bestPkgMgrURI: function () {
+        return L.resolveDefault(
+            fs.stat('/www/luci-static/resources/view/system/package-manager.js'), null
+        ).then(function (st) {
+            if (st && st.type === 'file')
+                return 'admin/system/package-manager';
+            return L.resolveDefault(fs.stat('/usr/libexec/package-manager-call'), null)
+                .then(function (st2) {
+                    return st2 ? 'admin/system/package-manager' : 'admin/system/opkg';
+                });
+        }).catch(function () { return 'admin/system/opkg'; });
+    },
+    openInstallerSearch: function (query) {
+        let self = this;
+        return self.bestPkgMgrURI().then(function (uri) {
+            let q = query ? ('?query=' + encodeURIComponent(query)) : '';
+            window.open(L.url(uri) + q, '_blank', 'noopener');
+        });
+    },
+    checkPackages: function() {
+        return fs.exec_direct('/usr/bin/opkg', ['list-installed'], 'text')
+            .catch(function () {
+                return fs.exec_direct('/usr/libexec/opkg-call', ['list-installed'], 'text')
+                    .catch(function () {
+                        return fs.exec_direct('/usr/libexec/package-manager-call', ['list-installed'], 'text')
+                            .catch(function () {
+                                return '';
+                            });
+                    });
+            })
+            .then(function (data) {
+                data = (data || '').trim();
+                return data ? data.split('\n') : [];
+            });
+    },
+    _isPackageInstalled: function(pkgName) {
+        return this.checkPackages().then(function(installedPackages) {
+            return installedPackages.some(function(pkg) {
+                return pkg.includes(pkgName);
+            });
+        });
+    }
+};
+
+return view.extend({
+    load: function() {
+        return Promise.resolve();
+    },
+
+    render: function() {
+        var m, s, o;
+
+        m = new form.Map('mdmconfig', _('Configuration'));
+
+        s = m.section(form.TypedSection, 'filesystem', _('Disk Manager'));
+        s.anonymous = true;
+        s.addremove = false;
+
+        s.tab('packages', _('Packages & Drivers'));
+        s.tab('disklog', _('Mini Disk Manager log'));
+
+        o = s.taboption('packages', form.DummyValue, '_dummy_drivers');
+        o.rawhtml = true;
+        o.render = function() {
+            return E('div', {}, [
+                E('h3', {}, _('Package and Driver Verification')),
+                E('div', { 'class': 'cbi-map-descr' }, _('Check and install required drivers for storage devices.'))
+            ]);
+        };
+
+        o = s.taboption('packages', form.Button, '_check_usb_drivers', _('Check USB drivers'));
+        o.inputtitle = _('USB drivers');
+        o.inputstyle = 'action';
+        o.onclick = L.bind(function() {
+            showPackageDialog('USB Drivers', {
+                'USB Drivers': [
+                    { name: 'kmod-usb-core', label: 'kmod-usb-core' },
+                    { name: 'kmod-usb-storage', label: 'kmod-usb-storage' },
+                    { name: 'kmod-usb-storage-uas', label: 'kmod-usb-storage-uas' },
+                    { name: 'kmod-usb-storage-extras', label: 'kmod-usb-storage-extras' },
+                    { name: 'kmod-usb2', label: 'kmod-usb2' },
+                    { name: 'kmod-usb3', label: 'kmod-usb3' }
+                ]
+            });
+        }, this);
+
+        o = s.taboption('packages', form.Button, '_check_nvme_drivers', _('Check NVMe drivers'));
+        o.inputtitle = _('NVMe drivers');
+        o.inputstyle = 'action';
+        o.onclick = L.bind(function() {
+            showPackageDialog('NVMe Drivers', {
+                'NVMe Drivers': [
+                    { name: 'kmod-nvme', label: 'kmod-nvme' },
+                    { name: 'libnvme', label: 'libnvme' }
+                ]
+            });
+        }, this);
+
+        o = s.taboption('packages', form.Button, '_check_ata_drivers', _('Check ATA/SATA drivers'));
+        o.inputtitle = _('ATA/SATA drivers');
+        o.inputstyle = 'action';
+        o.onclick = L.bind(function() {
+            showPackageDialog('ATA/SATA Drivers', {
+                'ATA/SATA Drivers': [
+                    { name: 'kmod-ata-core', label: 'kmod-ata-core' },
+                    { name: 'kmod-ata-ahci', label: 'kmod-ata-ahci' },
+                    { name: 'kmod-scsi-core', label: 'kmod-scsi-core' }
+                ]
+            });
+        }, this);
+
+        o = s.taboption('packages', form.DummyValue, '_dummy_filesystems');
+        o.rawhtml = true;
+        o.render = function() {
+            return E('div', {}, [
+                E('h3', {}, _('Filesystem Support')),
+                E('div', { 'class': 'cbi-map-descr' }, _('Packages required to support various file systems.'))
+            ]);
+        };
+
+        o = s.taboption('packages', form.Button, '_check_linux_fs_packages', _('Check Linux filesystem packages'));
+        o.inputtitle = _('Linux filesystems');
+        o.inputstyle = 'action';
+        o.onclick = L.bind(function() {
+            showPackageDialog('Linux Filesystem Packages', {
+                'Ext2/Ext3/Ext4': [
+                    { name: 'kmod-fs-ext4', label: 'kmod-fs-ext4' },
+                    { name: 'e2fsprogs', label: 'e2fsprogs' }
+                ],
+                'Expand Ext2/Ext3/Ext4': [
+                    { name: 'resize2fs', label: 'resize2fs' },
+                    { name: 'bc', label: 'bc' }
+                ],
+                'F2FS': [
+                    { name: 'kmod-fs-f2fs', label: 'kmod-fs-f2fs' },
+                    { name: 'mkf2fs', label: 'mkf2fs' },
+                    { name: 'f2fsck', label: 'f2fsck' },
+                    { name: 'f2fs-tools', label: 'f2fs-tools' }
+                ]
+            });
+        }, this);
+
+        o = s.taboption('packages', form.Button, '_check_windows_fs_packages', _('Check Windows filesystem packages'));
+        o.inputtitle = _('Windows filesystems');
+        o.inputstyle = 'action';
+        o.onclick = L.bind(function() {
+            showPackageDialog('Windows Filesystem Packages', {
+                'FAT16/FAT32': [
+                    { name: 'kmod-fs-vfat', label: 'kmod-fs-vfat' },
+                    { name: 'kmod-nls-cp437', label: 'kmod-nls-cp437' },
+                    { name: 'kmod-nls-iso8859-1', label: 'kmod-nls-iso8859-1' },
+                    { name: 'dosfstools', label: 'dosfstools' }
+                ],
+                'NTFS': [
+                    { name: 'ntfs-3g', label: 'ntfs-3g' },
+                    { name: 'kmod-fs-ntfs3', label: 'kmod-fs-ntfs3' },
+                    { name: 'ntfs-3g-utils', label: 'ntfs-3g-utils' },
+                    { name: 'kmod-nls-utf8', label: 'kmod-nls-utf8' }
+                ],
+                'exFAT': [
+                    { name: 'exfat-mkfs', label: 'exfat-mkfs' },
+                    { name: 'kmod-fs-exfat', label: 'kmod-fs-exfat' },
+                    { name: 'exfat-fsck', label: 'exfat-fsck' }
+                ]
+            });
+        }, this);
+
+        o = s.taboption('packages', form.DummyValue, '_dummy_diskwipe');
+        o.rawhtml = true;
+        o.render = function() {
+            return E('div', {}, [
+                E('h3', {}, _('Disk Wipe Support')),
+                E('div', { 'class': 'cbi-map-descr' }, _('Packages required to support disk wiping functionality (clearing partition table).'))
+            ]);
+        };
+
+        o = s.taboption('packages', form.Button, '_check_diskwipe_packages', _('Check Disk Wipe packages'));
+        o.inputtitle = _('Disk Wipe');
+        o.inputstyle = 'action';
+        o.onclick = L.bind(function() {
+            showPackageDialog('Disk Wipe Support', {
+                'Disk Wipe (dd command)': [
+                    { name: 'coreutils', label: 'coreutils (' + _('alternative') + ')' },
+                    { name: 'coreutils-dd', label: 'coreutils-dd (' + _('alternative') + ')' }
+                ]
+            });
+        }, this);
+
+        function showPackageDialog(title, requiredPackages) {
+            ui.showModal(_(title), [
+                E('p', { 'class': 'spinning' }, _('Loading package data…'))
+            ]);
+
+            var isDiskWipeDialog = (title === 'Disk Wipe Support');
+            
+            var checkPromises = [pkg.checkPackages()];
+            
+            if (isDiskWipeDialog) {
+                checkPromises.push(
+                    L.resolveDefault(fs.stat('/bin/dd'), null).then(function(result) {
+                        return (result && result.type === 'file');
+                    })
+                );
+            }
+
+            Promise.all(checkPromises).then(function(results) {
+                var installedPackages = results[0];
+                var ddExists = isDiskWipeDialog ? results[1] : false;
+
+                var _isInstalled = function(pkgName) {
+                    return installedPackages.some(function(pkg) {
+                        return pkg.includes(pkgName);
+                    });
+                };
+
+                var _row = function(pkgName, installed, isAlternative, ddAvailable) {
+                    var title = E('label', { 'class': 'cbi-value-title' }, pkgName);
+                    var btn;
+                    
+                    if (isAlternative && ddAvailable) {
+                        btn = E('button', { 
+                            'class': 'edit btn', 
+                            'disabled': true
+                        }, _('dd from BusyBox'));
+                    } else if (installed) {
+                        btn = E('button', { 'class': 'edit btn', 'disabled': true }, _('Installed'));
+                    } else {
+                        btn = E('button', {
+                            'class': 'btn cbi-button-positive',
+                            'click': function() { pkg.openInstallerSearch(pkgName); }
+                        }, _('Install…'));
+                    }
+
+                    return E('div', { 'class': 'cbi-value' }, [
+                        title,
+                        E('div', { 'class': 'cbi-value-field' }, [ btn ])
+                    ]);
+                };
+
+                var node = [];
+                var sectionOrder = Object.keys(requiredPackages);
+
+                sectionOrder.forEach(function(key) {
+                    var pkgs = requiredPackages[key];
+                    if (!pkgs || !pkgs.length) return;
+
+                    if (sectionOrder.length > 1)
+                        node.push(E('h4', {}, _(key)));
+
+                    pkgs.forEach(function(p) {
+                        var isAlternative = (p.name === 'coreutils' || p.name === 'coreutils-dd');
+                        node.push(_row(p.label, _isInstalled(p.name), isAlternative, ddExists));
+                    });
+                });
+
+                ui.showModal(_(title), [
+                    E('div', {}, node),
+                    E('div', { 'class': 'right' }, [
+                        E('div', { 'class': 'btn cbi-button-neutral', 'click': ui.hideModal }, _('Close'))
+                    ])
+                ]);
+            });
+        }
+
+        o = s.taboption('disklog', form.DummyValue, '_disklog');
+        o.render = function() {
+            var container = E('div', { 'class': 'cbi-section' }, [
+                E('p', {}, _('Mini Disk Manager Log')),
+                E('textarea', {
+                    'id': 'diskmanager_log_output',
+                    'class': 'cbi-input-textarea',
+                    'style': 'width:100%; height:60vh; min-height:400px; white-space:pre; font-family:monospace;',
+                    'readonly': true,
+                    'wrap': 'off'
+                }, '')
+            ]);
+
+            var textarea = container.querySelector('#diskmanager_log_output');
+
+            function loadLog() {
+                textarea.value = _('Loading log file…');
+                fs.read('/tmp/mini-diskmanager.log').then(function(content) {
+                    textarea.value = content || _('Log file is empty');
+                }).catch(function(err) {
+                    textarea.value = _('Unable to read log file') + ': ' + (err.message || err);
+                });
+            }
+
+            loadLog();
+
+            var controls = E('div', {
+                'class': 'right',
+                'style': 'margin-top:10px; display:flex; gap:0.5em; justify-content:flex-end; flex-wrap:wrap;'
+            }, [
+                E('button', {
+                    'class': 'btn cbi-button-remove',
+                    'click': function() {
+                        fs.write('/tmp/mini-diskmanager.log', '')
+                            .then(function() {
+                                ui.addNotification(null, E('p', _('Log file cleared successfully')), 'info');
+                                loadLog();
+                            })
+                            .catch(function(e) {
+                                ui.addNotification(null, E('p', _('Unable to clear the file') + ': ' + e.message), 'error');
+                            });
+                    }
+                }, _('Clear')),
+
+                E('button', {
+                    'class': 'cbi-button cbi-button-apply important',
+                    'click': function() {
+                        var blob = new Blob([textarea.value || ""], { type: 'text/plain' });
+                        var link = document.createElement('a');
+                        link.download = 'mini-diskmanager.log';
+                        link.href = URL.createObjectURL(blob);
+                        link.click();
+                        URL.revokeObjectURL(link.href);
+                    }
+                }, _('Download')),
+
+                E('button', {
+                    'class': 'btn',
+                    'click': function() { loadLog(); }
+                }, _('Refresh'))
+            ]);
+
+            container.appendChild(controls);
+            return container;
+        };
+
+        return m.render();
+    },
+
+    handleSaveApply: null,
+    handleSave: null,
+    handleReset: null
+});
diff --git a/package/luci-app-mini-diskmanager/htdocs/luci-static/resources/view/mdmsupport.js b/package/luci-app-mini-diskmanager/htdocs/luci-static/resources/view/mdmsupport.js
new file mode 100644
index 0000000000..2c2ac59d8e
--- /dev/null
+++ b/package/luci-app-mini-diskmanager/htdocs/luci-static/resources/view/mdmsupport.js
@@ -0,0 +1,147 @@
+'use strict';
+'require form';
+'require fs';
+'require view';
+'require ui';
+'require uci';
+'require dom';
+'require tools.widgets as widgets';
+
+/*
+
+  Copyright 2025-2026 Rafał Wabik - IceG - From eko.one.pl forum
+  
+  MIT License
+  
+*/
+
+function handleOpen(ev) {
+	if (ev === 'ropenissues')      { window.open('https://github.com/4IceG/luci-app-mini-diskmanager/issues'); return; }
+	if (ev === 'opendiscussion')   { window.open('https://github.com/4IceG/luci-app-mini-diskmanager/discussions'); return; }
+	if (ev === 'ropencoffee')      { window.open('https://suppi.pl/rafalwabik'); return; }
+	if (ev === 'opensupport')      { window.open('https://github.com/sponsors/4IceG'); return; }
+	if (ev === 'opentopic')        { window.open('https://eko.one.pl/forum/viewtopic.php?id=18669'); return; }
+}
+
+return view.extend({
+	load: function () {
+		return uci.load('mdmconfig');
+	},
+
+	render: function (data) {
+		let m, s, o;
+
+		let info = _('The tab allows users to support the package.');
+
+		m = new form.Map('mdmconfig', _('Package support'), info);
+
+		s = m.section(form.TypedSection);
+		s.anonymous = true;
+
+		s.tab('info', _('Mini Disk Manager Info'));
+		
+		let packages = [
+			{
+				package: _('Luci-app-mini-diskmanager'),
+				author: 'Rafał Wabik (IceG)',
+				authorLink: 'https://github.com/4IceG',
+				buttons: [
+					{
+						class: 'cbi-button-action important',
+						label: _('Buy a coffee'),
+						tooltip: _('Buy a coffee if you want to support the development of the project and the author'),
+						action: 'ropencoffee',
+						disabled: false
+					},
+					{
+						class: 'cbi-button-action',
+						label: _('Become a sponsor'),
+						tooltip: _('Become a sponsor if you want to support the development of the project and the author'),
+						action: 'opensupport',
+						disabled: false
+					},
+					{
+						class: 'cbi-button-add',
+						label: _('Write on forum'),
+						tooltip: _('Write in the topic of the package on the forum eko.one.pl'),
+						action: 'opentopic',
+						disabled: false
+					},
+					{
+						class: 'cbi-button-neutral',
+						label: _('Open discussion'),
+						tooltip: _('Open a package discussion on Github'),
+						action: 'opendiscussion',
+						disabled: false
+					},
+					{
+						class: 'cbi-button-remove',
+						label: _('Report a bug'),
+						tooltip: _('Report a bug on the package Github page'),
+						action: 'ropenissues',
+						disabled: false
+					}
+				]
+			}
+		];
+
+		let rows = [];
+		let table = E('table', { 
+		    'class': 'table', 
+            'style': 'border:1px solid var(--border-color-medium)!important; table-layout:fixed; border-collapse:collapse; width:100%;'
+            }, [
+			E('tr', { 'class': 'tr table-titles' }, [
+				E('th', { 'class': 'th' }, _('Package name')),
+				E('th', { 'class': 'th' }, _('Author (package maintainer)')),
+				E('th', { 'class': 'th nowrap cbi-section-actions' })
+			])
+		]);
+
+		for (let i = 0; i < packages.length; i++) {
+			let pkg = packages[i];
+			let buttonElements = [];
+
+			for (let j = 0; j < pkg.buttons.length; j++) {
+				let btn = pkg.buttons[j];
+				let buttonAttrs = {
+					'class': 'btn ' + btn.class,
+					'data-tooltip': btn.tooltip
+				};
+				
+				if (btn.disabled) {
+					buttonAttrs.disabled = true;
+				} else if (btn.action) {
+					buttonAttrs.click = function() { return handleOpen(btn.action); };
+				}
+				
+				buttonElements.push(E('button', buttonAttrs, btn.label));
+			}
+
+			let authorCell = pkg.author ? 
+				E('a', { 'href': pkg.authorLink, 'target': '_blank', 'style': 'color:#37c' }, pkg.author) : 
+				'';
+
+			rows.push([
+				pkg.package,
+				authorCell,
+				E('div', { 'style': 'display: flex; flex-wrap: wrap; gap: 0.5em;' }, buttonElements)
+			]);
+		}
+
+		cbi_update_table(table, rows);
+
+		o = s.taboption('info', form.DummyValue, '_packages_info');
+		o.render = function() {
+			return E('div', { 'class': 'cbi-section' }, [
+				E('p', {}, _('Information about package author and available support options.')),
+				table
+			]);
+		};
+
+		return m.render();
+	},
+
+	handleSaveApply: null,
+	handleSave: null,
+	handleReset: null
+});
diff --git a/package/luci-app-mini-diskmanager/htdocs/luci-static/resources/view/minidiskmanager.js b/package/luci-app-mini-diskmanager/htdocs/luci-static/resources/view/minidiskmanager.js
new file mode 100644
index 0000000000..8f6e11eaa4
--- /dev/null
+++ b/package/luci-app-mini-diskmanager/htdocs/luci-static/resources/view/minidiskmanager.js
@@ -0,0 +1,5442 @@
+'use strict';
+'require fs';
+'require ui';
+'require view';
+'require form';
+'require rpc';
+'require uci';
+
+/*
+
+  Copyright 2025-2026 Rafał Wabik - IceG - From eko.one.pl forum
+  
+  MIT License
+  
+*/
+
+document.head.append(E('style', {'type': 'text/css'},
+`
+
+:root {
+	--app-mini-diskmanager-primary: #2ea256;
+	--app-mini-diskmanager-danger: #ff4e54;
+	--app-mini-diskmanager-warning: #ff9800;
+	--app-disks-info-dark-font-color: #2e2e2e;
+	--app-disks-info-light-font-color: #fff;
+	--app-disks-info-warn-color: #fff7e2;
+	--app-disks-info-err-color: #fcc3bf;
+	--app-disks-info-ok-color-label: #2ea256;
+	--app-disks-info-err-color-label: #ff4e54;
+	--partition-color-ext4: rgba(144, 195, 86, 0.8);
+	--partition-color-ext3: rgba(124, 179, 66, 0.8);
+	--partition-color-ext2: rgba(98, 146, 55, 0.8);
+	--partition-color-ntfs: rgba(61, 174, 233, 0.8);
+	--partition-color-fat: rgba(246, 116, 0, 0.8);
+	--partition-color-vfat: rgba(246, 116, 0, 0.8);
+	--partition-color-fat32: rgba(246, 116, 0, 0.8);
+	--partition-color-exfat: rgba(255, 152, 0, 0.8);
+	--partition-color-swap: rgba(244, 67, 54, 0.8);
+	--partition-color-extended: rgba(158, 158, 158, 0.8);
+	--partition-color-primary: rgba(100, 149, 237, 0.8);
+	--partition-color-logical: rgba(173, 216, 230, 0.8);
+	--partition-color-f2fs: rgba(156, 39, 176, 0.8);
+	--partition-color-unallocated: rgba(224, 224, 224, 0.5);
+	--partition-color-free: rgba(224, 224, 224, 0.5);
+	--partition-border: #cccccc;
+	--active-tile-bg: #e6f4ea;
+	--active-tile-border: #2e7d32;
+	--border-color-medium: #e0e0e0;
+	--background-color-medium: #f8f8f8;
+	--text-color-primary: #222;
+	--text-color-secondary: #666;
+}
+
+:root[data-darkmode="true"] {
+	--app-mini-diskmanager-primary: #2ea256;
+	--app-mini-diskmanager-danger: #a93734;
+	--app-mini-diskmanager-warning: #f57c00;
+	--app-disks-info-dark-font-color: #fff;
+	--app-disks-info-light-font-color: #fff;
+	--app-disks-info-warn-color: #8d7000;
+	--app-disks-info-err-color: #a93734;
+	--app-disks-info-ok-color-label: #007627;
+	--app-disks-info-err-color-label: #a93734;
+	--partition-color-ext4: rgba(90, 138, 47, 0.8);
+	--partition-color-ext3: rgba(74, 118, 36, 0.8);
+	--partition-color-ext2: rgba(58, 96, 25, 0.8);
+	--partition-color-ntfs: rgba(42, 125, 186, 0.8);
+	--partition-color-fat: rgba(197, 88, 0, 0.8);
+	--partition-color-vfat: rgba(197, 88, 0, 0.8);
+	--partition-color-fat32: rgba(197, 88, 0, 0.8);
+	--partition-color-exfat: rgba(230, 126, 34, 0.8);
+	--partition-color-swap: rgba(198, 40, 40, 0.8);
+	--partition-color-extended: rgba(97, 97, 97, 0.8);
+	--partition-color-primary: rgba(65, 105, 225, 0.8);
+	--partition-color-logical: rgba(100, 149, 237, 0.8);
+	--partition-color-f2fs: rgba(123, 31, 162, 0.8);
+	--partition-color-unallocated: rgba(66, 66, 66, 0.5);
+	--partition-color-free: rgba(66, 66, 66, 0.5);
+	--partition-border: #555555;
+	--active-tile-bg: rgba(46, 204, 113, 0.22);
+	--active-tile-border: #2ecc71;
+	--border-color-medium: #444;
+	--background-color-medium: rgba(255,255,255,0.03);
+	--text-color-primary: #eee;
+	--text-color-secondary: #ccc;
+}
+
+.controls {
+	display: flex;
+	margin: .5em 0 1em 0;
+	flex-wrap: wrap;
+	justify-content: space-around;
+}
+
+.controls > * {
+	padding: .25em;
+	white-space: nowrap;
+	flex: 1 1 33%;
+	box-sizing: border-box;
+	display: flex;
+	flex-wrap: wrap;
+}
+
+.controls > *:first-child,
+.controls > * > label {
+	flex-basis: 100%;
+	min-width: 250px;
+}
+
+.controls > *:nth-child(2),
+.controls > *:nth-child(3) {
+	flex-basis: 25%;
+}
+
+.controls > *:nth-child(4) {
+	flex-basis: 50%;
+}
+
+.controls > * > .btn {
+	flex-basis: 20px;
+	text-align: center;
+}
+
+.controls > * > * {
+	flex-grow: 1;
+	align-self: center;
+}
+
+.controls > div > input {
+	width: auto;
+}
+
+.controls .control-group {
+	display: flex;
+	gap: .5em;
+	align-items: center;
+	width: 100%;
+}
+
+.controls .control-group select {
+	min-width: 50px;
+	flex-grow: 1;
+}
+
+.ifacebox {
+    display: flex !important;
+    flex-direction: column !important;
+	min-width: 98% !important;
+}
+
+.ifacebox-body {
+    flex: 1 !important;
+    width: 100% !important;
+    box-sizing: border-box !important;
+}
+
+.ifacebox-head {
+    background: transparent !important;
+    width: 100% !important;
+    box-sizing: border-box !important;
+}
+
+.disks-info-label-status {
+	display: inline;
+	margin: 0 4px !important;
+	padding: 1px 4px;
+	border-radius: 3px;
+	text-transform: uppercase;
+	font-weight: bold;
+	line-height: 1.6em;
+}
+
+.disks-info-ok-label {
+	background-color: var(--app-disks-info-ok-color-label) !important;
+	color: var(--app-disks-info-light-font-color) !important;
+}
+
+.disks-info-err-label {
+	background-color: var(--app-disks-info-err-color-label) !important;
+	color: var(--app-disks-info-light-font-color) !important;
+}
+
+.disks-info-warn {
+	background-color: var(--app-disks-info-warn-color) !important;
+	color: var(--app-disks-info-dark-font-color) !important;
+}
+
+.disks-info-warn .td {
+	color: var(--app-disks-info-dark-font-color) !important;
+}
+
+.disks-info-warn td {
+	color: var(--app-disks-info-dark-font-color) !important;
+}
+
+.disks-info-err {
+	background-color: var(--app-disks-info-err-color) !important;
+	color: var(--app-disks-info-dark-font-color) !important;
+}
+
+.disks-info-err .td {
+	color: var(--app-disks-info-dark-font-color) !important;
+}
+
+.disks-info-err td {
+	color: var(--app-disks-info-dark-font-color) !important;
+}
+
+.operation-status {
+	display: none;
+	padding: 12px 16px;
+    border: 1px solid var(--border-color-medium);
+    border-radius: 5px;
+	margin: 15px 0;
+}
+
+.operation-status.active {
+	display: block;
+}
+
+.operation-status .spinning {
+	display: inline-block;
+	margin-right: 8px;
+}
+
+.disk-partition-bar {
+	width: 100%;
+	height: 60px;
+	display: flex;
+	border: 1px solid var(--partition-border);
+	border-radius: 4px;
+	overflow: hidden;
+	margin: 15px 0;
+	background: var(--partition-color-unallocated);
+}
+
+.partition-segment {
+	height: 100%;
+	display: flex;
+	align-items: center;
+	justify-content: center;
+	flex-direction: column;
+	border-right: 1px solid var(--partition-border);
+	font-size: 11px;
+	padding: 4px;
+	text-align: center;
+	overflow: hidden;
+	position: relative;
+	opacity: 0.85;
+	box-sizing: border-box;
+}
+
+.partition-segment:last-child {
+	border-right: none;
+}
+
+.partition-segment.ext4 { 
+	background-color: var(--partition-color-ext4);
+	color: #000;
+}
+.partition-segment.ext3 { 
+	background-color: var(--partition-color-ext3);
+	color: #000;
+}
+.partition-segment.ext2 { 
+	background-color: var(--partition-color-ext2);
+	color: #000;
+}
+.partition-segment.ntfs { 
+	background-color: var(--partition-color-ntfs);
+	color: #fff;
+}
+.partition-segment.vfat,
+.partition-segment.fat32 { 
+	background-color: var(--partition-color-fat);
+	color: #fff;
+}
+.partition-segment.exfat { 
+	background-color: var(--partition-color-exfat);
+	color: #fff;
+}
+.partition-segment.swap { 
+	background-color: var(--partition-color-swap);
+	color: #fff;
+}
+.partition-segment.extended { 
+	background-color: var(--partition-color-extended);
+	color: #fff;
+}
+.partition-segment.primary { 
+	background-color: var(--partition-color-primary);
+	color: #fff;
+}
+.partition-segment.logical { 
+	background-color: var(--partition-color-logical);
+	color: #000;
+}
+.partition-segment.f2fs { 
+	background-color: var(--partition-color-f2fs);
+	color: #fff;
+}
+.partition-segment.free .partition-label,
+.partition-segment.unallocated .partition-label,
+.partition-segment.free .partition-size,
+.partition-segment.unallocated .partition-size {
+    background-color: var(--partition-color-unallocated);
+    font-weight: 600;
+}
+.partition-segment.free,
+.partition-segment.unallocated {
+    color: #fff;
+    text-shadow: 0 2px 6px rgba(0,0,0,0.7);
+}
+
+.partition-label {
+	font-weight: bold;
+	font-size: 13px;
+	white-space: nowrap;
+	overflow: hidden;
+	text-overflow: ellipsis;
+	max-width: 100%;
+	line-height: 1.3;
+	text-shadow: 0 1px 3px rgba(0,0,0,0.6);
+}
+
+.partition-size {
+	font-size: 12px;
+	font-weight: 600;
+	margin-top: 2px;
+	line-height: 1.2;
+	text-shadow: 0 1px 3px rgba(0,0,0,0.6);
+}
+
+.partition-color-indicator {
+	display: inline-block;
+	width: 18px;
+	height: 18px;
+	border: 2px solid;
+	border-radius: 3px;
+	margin-right: 8px;
+	vertical-align: middle;
+	opacity: 0.85;
+}
+
+.partition-color-indicator.ext4 { 
+	background-color: var(--partition-color-ext4); 
+	border-color: rgba(144, 195, 86, 1);
+}
+.partition-color-indicator.ext3 { 
+	background-color: var(--partition-color-ext3); 
+	border-color: rgba(124, 179, 66, 1);
+}
+.partition-color-indicator.ext2 { 
+	background-color: var(--partition-color-ext2); 
+	border-color: rgba(98, 146, 55, 1);
+}
+.partition-color-indicator.ntfs { 
+	background-color: var(--partition-color-ntfs); 
+	border-color: rgba(61, 174, 233, 1);
+}
+.partition-color-indicator.vfat,
+.partition-color-indicator.fat32 { 
+	background-color: var(--partition-color-fat); 
+	border-color: rgba(246, 116, 0, 1);
+}
+.partition-color-indicator.exfat { 
+	background-color: var(--partition-color-exfat); 
+	border-color: rgba(255, 152, 0, 1);
+}
+.partition-color-indicator.swap { 
+	background-color: var(--partition-color-swap); 
+	border-color: rgba(244, 67, 54, 1);
+}
+.partition-color-indicator.extended { 
+	background-color: var(--partition-color-extended); 
+	border-color: rgba(158, 158, 158, 1);
+}
+.partition-color-indicator.primary { 
+	background-color: var(--partition-color-primary); 
+	border-color: rgba(100, 149, 237, 1);
+}
+.partition-color-indicator.logical { 
+	background-color: var(--partition-color-logical); 
+	border-color: rgba(173, 216, 230, 1);
+}
+.partition-color-indicator.f2fs { 
+	background-color: var(--partition-color-f2fs); 
+	border-color: rgba(156, 39, 176, 1);
+}
+.partition-color-indicator.unallocated { 
+	background-color: var(--partition-color-unallocated); 
+	border-color: rgba(158, 158, 158, 1);
+}
+
+.partition-inner-fs {
+	display: flex;
+	height: 100%;
+	width: 100%;
+	position: absolute;
+	top: 0;
+	left: 0;
+}
+
+.partition-inner-segment {
+	display: flex;
+	flex-direction: column;
+	align-items: center;
+	justify-content: center;
+	font-size: 9px;
+	font-weight: bold;
+	color: #fff;
+	border-right: 1px solid rgba(255,255,255,0.4);
+	position: relative;
+	overflow: hidden;
+	text-shadow: 0 1px 2px rgba(0,0,0,0.5);
+}
+
+.partition-inner-segment:last-child {
+	border-right: none;
+}
+
+.partition-inner-segment.ext4 { 
+	background-color: var(--partition-color-ext4);
+}
+.partition-inner-segment.ext3 { 
+	background-color: var(--partition-color-ext3);
+}
+.partition-inner-segment.ext2 { 
+	background-color: var(--partition-color-ext2);
+}
+.partition-inner-segment.ntfs { 
+	background-color: var(--partition-color-ntfs);
+}
+.partition-inner-segment.vfat,
+.partition-inner-segment.fat32 { 
+	background-color: var(--partition-color-fat);
+}
+.partition-inner-segment.exfat { 
+	background-color: var(--partition-color-exfat);
+}
+.partition-inner-segment.swap { 
+	background-color: var(--partition-color-swap);
+}
+.partition-inner-segment.f2fs { 
+	background-color: var(--partition-color-f2fs);
+}
+.partition-inner-segment.logical { 
+	background-color: var(--partition-color-logical);
+}
+
+.partition-table-container tbody tr td:first-child {
+    font-family: 'Courier New', Courier, monospace;
+}
+
+.partition-inner-segment {
+    transition: all 0.2s ease;
+}
+
+tbody tr td:first-child {
+    white-space: pre;
+}
+
+.size-input-group {
+	display: flex;
+	gap: 8px;
+	align-items: center;
+}
+
+.size-input-group input[type="text"] {
+	flex: 1;
+	min-width: 0;
+}
+
+.size-input-group select {
+	width: 80px;
+	flex-shrink: 0;
+}
+
+@media (max-width: 990px) {
+	.controls { gap:.4rem; }
+	.controls > * { flex-basis: 100%; max-width: 100%; min-width: 0; }
+}
+`));
+
+return view.extend({
+    selectedDisk: null,
+    selectedPartition: null,
+    selectedUnallocated: null,
+    diskData: {},
+    mountedPartitions: {},
+    deviceRegExp: new RegExp('^((h|s)d[a-z]|nvme[0-9]+n[0-9]+|mmcblk[0-9]+)$'),
+    supportedFs: null,
+    MIN_VISIBLE_SIZE: 200 * 1024 * 1024, // 200 MB
+    wipeAllEnabled: false,
+    hasDdSupport: null,
+    
+    viewName: 'minidiskmanager',
+
+    restoreSettingsFromLocalStorage: function() {
+        let selectedDiskLocal = localStorage.getItem(`luci-app-${this.viewName}-selectedDisk`);
+        if(selectedDiskLocal) {
+            this.selectedDisk = selectedDiskLocal;
+        }
+    },
+
+    saveSettingsToLocalStorage: function(diskName) {
+        localStorage.setItem(`luci-app-${this.viewName}-selectedDisk`, diskName);
+    },
+
+    rpcCheckOperation: rpc.declare({
+        object: 'minidiskmanager',
+        method: 'check_operation',
+        params: ['pid'],
+        expect: {}
+    }),
+
+    rpcList: rpc.declare({
+        object: 'minidiskmanager',
+        method: 'list',
+        params: [],
+        expect: {}
+    }),
+
+    rpcCreatePartition: rpc.declare({
+        object: 'minidiskmanager',
+        method: 'create_partition',
+        params: ['device', 'type', 'fstype', 'size', 'layout', 'label', 'reserved_space', 'reserved_unit'],
+        expect: {}
+    }),
+
+    rpcDeletePartition: rpc.declare({
+        object: 'minidiskmanager',
+        method: 'delete_partition',
+        params: ['device', 'partition'],
+        expect: {}
+    }),
+
+    rpcFormatPartition: rpc.declare({
+        object: 'minidiskmanager',
+        method: 'format_partition',
+        params: ['device', 'fstype', 'label', 'reserved_space', 'reserved_unit'],
+        expect: {}
+    }),
+
+    rpcResizePartition: rpc.declare({
+        object: 'minidiskmanager',
+        method: 'resize_partition',
+        params: ['partition', 'new_size', 'unit'],
+        expect: {}
+    }),
+
+    rpcWipeDisk: rpc.declare({
+        object: 'minidiskmanager',
+        method: 'wipe_disk',
+        params: ['device'],
+        expect: {}
+    }),
+
+    getInstalledPackages: function() {
+        const tryCmd = (cmd, args) => {
+            return L.resolveDefault(fs.exec(cmd, args), { code: 1, stdout: '' });
+        };
+
+        return tryCmd('/usr/bin/opkg', ['list-installed'])
+            .then(res => {
+                if (res && res.code === 0 && res.stdout) {
+                    return (res.stdout || '').trim().split('\n').map(s => s.trim()).filter(Boolean);
+                }
+                return tryCmd('/usr/libexec/opkg-call', ['list-installed']).then(r2 => {
+                    if (r2 && r2.code === 0 && r2.stdout) return (r2.stdout || '').trim().split('\n').map(s => s.trim()).filter(Boolean);
+                    return tryCmd('/usr/libexec/package-manager-call', ['list-installed']).then(r3 => {
+                        if (r3 && r3.code === 0 && r3.stdout) return (r3.stdout || '').trim().split('\n').map(s => s.trim()).filter(Boolean);
+                        return [];
+                    });
+                });
+            })
+            .catch(() => {
+                return [];
+            });
+    },
+
+    _isPackageInstalledFromList: function(installedPackages, name) {
+        if (!installedPackages || !installedPackages.length) return false;
+        return installedPackages.some(function(line) {
+            return line.split(/\s+/)[0] === name || line.indexOf(name + ' -') === 0 || line.indexOf(name + ':') === 0 || line.indexOf(name) !== -1;
+        });
+    },
+
+    detectSupportedFilesystems: async function() {
+        if (this.supportedFs !== null) return this.supportedFs;
+
+        try {
+            const installed = await this.getInstalledPackages();
+            const fsSet = new Set();
+
+            const has = (name) => this._isPackageInstalledFromList(installed, name);
+
+            if (has('e2fsprogs') && has('kmod-fs-ext4')) {
+                fsSet.add('ext2');
+            }
+            
+            if (has('e2fsprogs') && has('kmod-fs-ext4')) {
+                fsSet.add('ext3');
+            }
+            
+            if (has('e2fsprogs') && has('kmod-fs-ext4')) {
+                fsSet.add('ext4');
+            }
+
+            if (has('kmod-fs-f2fs') && has('mkf2fs') && has('f2fs-tools') && has('f2fsck')) {
+                fsSet.add('f2fs');
+            }
+
+            if (has('dosfstools') && has('kmod-fs-vfat')) {
+                fsSet.add('vfat');
+            }
+            
+            if (has('ntfs-3g-utils') && (has('ntfs-3g') || has('kmod-fs-ntfs3'))) {
+                fsSet.add('ntfs');
+            }
+
+            if (has('exfat-mkfs') && has('kmod-fs-exfat')) {
+                fsSet.add('exfat');
+            }
+
+	        if (has('swap-utils')) {
+        		fsSet.add('swap');
+	        }
+
+            this.supportedFs = Array.from(fsSet);
+            return this.supportedFs;
+        } catch (e) {
+            console.error('detectSupportedFilesystems error:', e);
+            this.supportedFs = [];
+            return this.supportedFs;
+        }
+    },
+
+    checkDdSupport: async function() {
+        if (this.hasDdSupport !== null) return this.hasDdSupport;
+
+        try {
+            try {
+                const result = await L.resolveDefault(fs.stat('/bin/dd'), null);
+                this.hasDdSupport = (result && result.type === 'file');
+                
+                if (this.hasDdSupport) {
+                    return true;
+                }
+            } catch (e) {
+                // None
+            }
+            
+            const installed = await this.getInstalledPackages();
+            const has = (name) => this._isPackageInstalledFromList(installed, name);
+            
+            this.hasDdSupport = has('coreutils') || has('coreutils-dd');
+            
+            return this.hasDdSupport;
+        } catch (e) {
+            console.error('checkDdSupport error:', e);
+            this.hasDdSupport = false;
+            return this.hasDdSupport;
+        }
+    },
+
+    disableAllButtonsAndRemember: function() {
+        try {
+            const nodes = Array.from(document.querySelectorAll('button, input[type="button"], input[type="submit"], [role="button"]'));
+            const prior = nodes.map(n => ({ el: n, disabled: !!n.disabled }));
+            nodes.forEach(n => {
+                try { n.disabled = true; } catch (e) {}
+            });
+            return {
+                restore: function() {
+                    prior.forEach(p => {
+                        try { p.el.disabled = p.disabled; } catch (e) {}
+                    });
+                }
+            };
+        } catch (e) {
+            console.error('disableAllButtonsAndRemember failed', e);
+            return { restore: function() {} };
+        }
+    },
+
+    disableActiveButtonsAndRemember: function() {
+        try {
+            const nodes = Array.from(document.querySelectorAll('button, input[type="button"], input[type="submit"], [role="button"]'));
+            const toDisable = nodes.filter(n => !n.disabled);
+            const prior = toDisable.map(n => ({ el: n, disabled: !!n.disabled }));
+            toDisable.forEach(n => {
+                try { n.disabled = true; } catch (e) {}
+            });
+            return {
+                restore: function() {
+                    prior.forEach(p => {
+                        try { p.el.disabled = p.disabled; } catch (e) {}
+                    });
+                }
+            };
+        } catch (e) {
+            console.error('disableActiveButtonsAndRemember failed', e);
+            return { restore: function() {} };
+        }
+    },
+
+    load: function() {
+        this.checkDdSupport();
+        this.restoreSettingsFromLocalStorage();
+        
+        return Promise.all([
+            this.getBlockDevices(),
+            this.getMountedPartitions(),
+            L.resolveDefault(fs.stat('/usr/sbin/fdisk'), null),
+            L.resolveDefault(fs.stat('/sbin/parted'), null),
+        ]);
+    },
+
+    handleRender: function() {
+        this.updateActionButtons();
+    },
+
+    showOperationStatus: function(message) {
+        let statusBox = document.getElementById('operation-status');
+        if (statusBox) {
+            statusBox.innerHTML = '';
+            statusBox.appendChild(E('span', {'class': 'spinning'}, message));
+            statusBox.classList.add('active');
+        }
+    },
+
+    hideOperationStatus: function() {
+        let statusBox = document.getElementById('operation-status');
+        if (statusBox) {
+            statusBox.classList.remove('active');
+        }
+    },
+
+    popTimeout: function(a, message, timeout, severity) {
+        ui.addTimeLimitedNotification(a, message, timeout, severity);
+    },
+
+    callRpcd: function(method, params) {
+        const methodMap = {
+            'check_operation': () => this.rpcCheckOperation(params.pid),
+            'list': () => this.rpcList(),
+            'create_partition': () => this.rpcCreatePartition(
+                params.device,
+                params.type,
+                params.fstype,
+                params.size,
+                params.layout,
+                params.label,
+                params.reserved_space,
+                params.reserved_unit
+            ),
+            'delete_partition': () => this.rpcDeletePartition(
+                params.device,
+                params.partition
+            ),
+            'format_partition': () => this.rpcFormatPartition(
+                params.device,
+                params.fstype,
+                params.label,
+                params.reserved_space,
+                params.reserved_unit
+            ),
+            'resize_partition': () => this.rpcResizePartition(
+                params.partition,
+                params.new_size,
+                params.unit
+            ),
+            'wipe_disk': () => this.rpcWipeDisk(params.device)
+        };
+
+        if (!methodMap[method]) {
+            return Promise.reject(new Error(_('Unknown RPC method: ') + method));
+        }
+
+        return L.resolveDefault(methodMap[method](), null)
+            .then(result => {
+                if (result === null) {
+                    return Promise.reject(new Error(_('RPC call failed: no response')));
+                }
+                return result;
+            });
+    },
+
+    monitorOperation: function(pid, progressMsg, successMsg, errorMsg) {
+        return new Promise((resolve, reject) => {
+            this.showOperationStatus(progressMsg);
+
+            let checkInterval = setInterval(() => {
+                this.callRpcd('check_operation', { pid: pid.toString() })
+                    .then(result => {
+                        if (!result.running) {
+                            clearInterval(checkInterval);
+                            this.hideOperationStatus();
+
+                            if (result.exitcode === 0) {
+                                this.popTimeout(null, E('p', successMsg), 5000, 'info');
+                                resolve(result);
+                            } else {
+                                let shortError = errorMsg + ', ' + _('more info in log');
+                                ui.addNotification(null, E('p', shortError), 'error');
+                                console.error('Operation log:', result.log);
+                                reject(new Error(shortError));
+                            }
+                        }
+                    })
+                    .catch(err => {
+                        clearInterval(checkInterval);
+                        this.hideOperationStatus();
+                        ui.addNotification(null, E('p', _('Failed to check operation status: ') + err.message), 'error');
+                        reject(err);
+                    });
+            }, 2000);
+        });
+    },
+
+    getMountedPartitions: function() {
+        return fs.exec('/bin/mount').then(res => {
+            let mounted = {};
+            if (res && res.code === 0) {
+                let lines = res.stdout.trim().split('\n');
+                lines.forEach(line => {
+                    let match = line.match(/^(\/dev\/\S+)\s+on\s+(\S+)/);
+                    if (match) {
+                        mounted[match[1]] = match[2];
+                    }
+                });
+            }
+            return mounted;
+        }).catch(() => {
+            return {};
+        });
+    },
+
+    getBlockDevices: function() {
+        return fs.list('/dev').then(stat => {
+            let devices = [];
+            stat.forEach(e => {
+                let fname = e.name;
+                if (this.deviceRegExp.test(fname)) {
+                    devices.push(fname);
+                }
+            });
+            return devices.sort();
+        }).then(devices => {
+            return Promise.all(devices.map(dev =>
+                Promise.all([
+                    L.resolveDefault(fs.exec('/usr/bin/lsblk', ['-J', '-b', '-o', 'NAME,SIZE,TYPE,FSTYPE,MOUNTPOINT', '/dev/' + dev]), null),
+                    this.getFullDiskModel(dev)
+                ]).then(results => {
+                    let lsblkResult = results[0];
+                    let fullModel = results[1];
+                    
+                    if (lsblkResult && lsblkResult.code === 0) {
+                        try {
+                            let data = JSON.parse(lsblkResult.stdout);
+                            if (data.blockdevices && data.blockdevices[0]) {
+                                return {
+                                    name: dev,
+                                    path: '/dev/' + dev,
+                                    size: data.blockdevices[0].size,
+                                    model: fullModel || '',
+                                    type: data.blockdevices[0].type
+                                };
+                            }
+                        } catch (e) {
+                            console.log('JSON parse error for ' + dev, e);
+                        }
+                    }
+                    return { name: dev, path: '/dev/' + dev, size: 0, model: fullModel || '', type: 'disk' };
+                })
+            ));
+        }).catch(err => {
+            console.log('getBlockDevices error:', err);
+            return [];
+        });
+    },
+
+    getFullDiskModel: function(device) {
+        return Promise.all([
+            L.resolveDefault(fs.exec('/usr/sbin/smartctl', ['-i', '/dev/' + device]), null),
+            L.resolveDefault(fs.exec('/usr/bin/lsblk', ['-dno', 'VENDOR,MODEL', '/dev/' + device]), null),
+            L.resolveDefault(fs.read('/sys/block/' + device + '/device/vendor'), null),
+            L.resolveDefault(fs.read('/sys/block/' + device + '/device/model'), null)
+        ]).then(results => {
+            let modelFamily = '';
+            let model = '';
+            let vendor = '';
+            
+            if (results[0] && results[0].code === 0) {
+                let smartOutput = results[0].stdout;
+                
+                let modelFamilyMatch = smartOutput.match(/Model Family:\s*(.+)/i);
+                if (modelFamilyMatch && modelFamilyMatch[1].trim()) {
+                    modelFamily = modelFamilyMatch[1].trim();
+                }
+                
+                let modelMatch = smartOutput.match(/(?:Device Model|Model Number|Product):\s*(.+)/i);
+                if (modelMatch && modelMatch[1].trim()) {
+                    model = modelMatch[1].trim();
+                }
+                
+                let vendorMatch = smartOutput.match(/Vendor:\s*(.+)/i);
+                if (vendorMatch && vendorMatch[1].trim()) {
+                    vendor = vendorMatch[1].trim();
+                }
+                
+                if (modelFamily && model) {
+                    return modelFamily + ' ' + model;
+                } else if (model) {
+                    return model;
+                } else if (modelFamily) {
+                    return modelFamily;
+                }
+            }
+            
+            if (!model && !modelFamily) {
+                if (results[1] && results[1].code === 0 && results[1].stdout.trim()) {
+                    let lsblkOutput = results[1].stdout.trim();
+                    let parts = lsblkOutput.split(/\s+/, 2);
+                    
+                    if (parts.length >= 2) {
+                        if (parts[0] && parts[0] !== '') {
+                            vendor = parts[0].trim();
+                        }
+                        if (parts[1] && parts[1] !== '') {
+                            model = parts[1].trim();
+                        }
+                    } else if (parts.length === 1 && parts[0] && parts[0] !== '') {
+                        model = parts[0].trim();
+                    }
+                }
+            }
+            
+            if (!model && !vendor) {
+                if (results[2] && results[2].trim()) {
+                    vendor = results[2].trim();
+                }
+                if (results[3] && results[3].trim()) {
+                    model = results[3].trim();
+                }
+            }
+            
+            if (vendor && model) {
+                return vendor + ' ' + model;
+            } else if (model) {
+                return model;
+            } else if (vendor) {
+                return vendor;
+            }
+            
+            return '';
+        }).catch(err => {
+            console.log('getFullDiskModel error for ' + device + ':', err);
+            return '';
+        });
+    },
+
+    getDiskModel: function(device) {
+        return Promise.all([
+            L.resolveDefault(fs.exec('/usr/bin/lsblk', ['-dno', 'MODEL', '/dev/' + device]), null),
+            L.resolveDefault(fs.exec('/usr/sbin/smartctl', ['-i', '/dev/' + device]), null),
+            L.resolveDefault(fs.read('/sys/block/' + device + '/device/model'), null)
+        ]).then(results => {
+            if (results[0] && results[0].code === 0 && results[0].stdout.trim()) {
+                return results[0].stdout.trim();
+            }
+            if (results[1] && results[1].code === 0) {
+                let match = results[1].stdout.match(/Model Number:\s*(.+)/i);
+                if (match && match[1].trim()) return match[1].trim();
+            }
+            if (results[2] && results[2].code === 0) {
+                let match = results[2].stdout.match(/Device Model:\s*(.+)/i) || results[2].stdout.match(/Product:\s*(.+)/i);
+                if (match && match[1].trim()) return match[1].trim();
+            }
+            if (results[3] && results[3].trim()) {
+                return results[3].trim();
+            }
+            return null;
+        }).catch(() => null);
+    },
+
+    getSmartDeviceInfo: function(device) {
+        const devicePath = '/dev/' + device;
+        const diskType = this.getDiskType(device);
+
+        if (diskType === 'nvme') {
+            return L.resolveDefault(fs.exec('/usr/sbin/nvme', ['id-ctrl', devicePath]), null)
+                .then(res => {
+                    if (res && res.code === 0) {
+                        const lines = res.stdout.split('\n');
+                        const info = {};
+                        
+                        for (let line of lines) {
+                            if (line.includes('mn ')) {
+                                const match = line.match(/mn\s*:\s*(.+)/i);
+                                if (match) info.model = match[1].trim();
+                            }
+                            if (line.includes('sn ')) {
+                                const match = line.match(/sn\s*:\s*(.+)/i);
+                                if (match) info.serial = match[1].trim();
+                            }
+                            if (line.includes('fr ')) {
+                                const match = line.match(/fr\s*:\s*(.+)/i);
+                                if (match) info.firmware = match[1].trim();
+                            }
+                        }
+                        return info;
+                    }
+                    return null;
+                })
+                .catch(() => null);
+        } else {
+            // SATA/ATA
+            const attempts = [
+                ['-i', devicePath],
+                ['-i', '-d', 'sat', devicePath],
+                ['-i', '-d', 'ata', devicePath]
+            ];
+
+            let sequence = Promise.resolve(null);
+            for (let i = 0; i < attempts.length; i++) {
+                (function(args) {
+                    sequence = sequence.then(function(found) {
+                        if (found) return found;
+                        return L.resolveDefault(fs.exec('/usr/sbin/smartctl', args), null)
+                            .then(res => {
+                                if (!res || res.code !== 0) return null;
+                                
+                                const lines = res.stdout.split('\n');
+                                const info = {};
+                                
+                                for (let line of lines) {
+                                    if (line.includes('Model Family:')) {
+                                        const match = line.match(/Model Family:\s*(.+)/i);
+                                        if (match) info.modelFamily = match[1].trim();
+                                    }
+                                    if (line.includes('Device Model:') || line.includes('Model Number:') || line.includes('Product:')) {
+                                        const match = line.match(/(?:Device Model|Model Number|Product):\s*(.+)/i);
+                                        if (match) info.model = match[1].trim();
+                                    }
+                                    if (line.includes('Serial Number:') || line.includes('Serial number:')) {
+                                        const match = line.match(/Serial [Nn]umber:\s*(.+)/i);
+                                        if (match) info.serial = match[1].trim();
+                                    }
+                                    if (line.includes('Firmware Version:') || line.includes('Revision:')) {
+                                        const match = line.match(/(?:Firmware Version|Revision):\s*(.+)/i);
+                                        if (match) info.firmware = match[1].trim();
+                                    }
+                                    if (line.includes('User Capacity:')) {
+                                        const match = line.match(/User Capacity:\s*(.+)/i);
+                                        if (match) info.capacity = match[1].trim();
+                                    }
+                                    if (line.includes('Sector Size:')) {
+                                        const match = line.match(/Sector Size:\s*(.+)/i);
+                                        if (match) info.sectorSize = match[1].trim();
+                                    }
+                                    if (line.includes('Rotation Rate:')) {
+                                        const match = line.match(/Rotation Rate:\s*(.+)/i);
+                                        if (match) info.rotationRate = match[1].trim();
+                                    }
+                                    if (line.includes('Form Factor:')) {
+                                        const match = line.match(/Form Factor:\s*(.+)/i);
+                                        if (match) info.formFactor = match[1].trim();
+                                    }
+                                    if (line.includes('ATA Version is:')) {
+                                        const match = line.match(/ATA Version is:\s*(.+)/i);
+                                        if (match) info.ataVersion = match[1].trim();
+                                    }
+                                    if (line.includes('SATA Version is:')) {
+                                        const match = line.match(/SATA Version is:\s*(.+)/i);
+                                        if (match) info.sataVersion = match[1].trim();
+                                    }
+                                }
+                                
+                                return Object.keys(info).length > 0 ? info : null;
+                            });
+                    });
+                })(attempts[i]);
+            }
+            return sequence;
+        }
+    },
+
+    getDiskType: function(device) {
+        if (device.startsWith('nvme')) {
+            return 'nvme';
+        } else if (device.startsWith('sd') || device.startsWith('hd')) {
+            return 'sata';
+        } else if (device.startsWith('mmcblk')) {
+            return 'mmc';
+        }
+        return 'unknown';
+    },
+
+    getDiskTemperature: function(device) {
+    const devicePath = '/dev/' + device;
+    const diskType = this.getDiskType(device);
+
+    // NVMe
+    if (diskType === 'nvme') {
+        return L.resolveDefault(fs.exec('/usr/sbin/nvme', ['smart-log', devicePath, '-o', 'json']), null)
+            .then(res => {
+                if (res && res.code === 0) {
+                    try {
+                        const data = JSON.parse(res.stdout);
+                        if (data.temperature !== undefined && data.temperature !== null) {
+                            const tempC = data.temperature - 273;
+                            if (tempC >= -50 && tempC <= 150) {
+                                return tempC + ' °C';
+                            }
+                        }
+                        if (data.temperature_sensor_1 !== undefined && data.temperature_sensor_1 !== null) {
+                            const tempC = data.temperature_sensor_1 - 273;
+                            if (tempC >= -50 && tempC <= 150) {
+                                return tempC + ' °C';
+                            }
+                        }
+                    } catch (e) {
+                        console.error('NVMe temperature parse error:', e);
+                    }
+                }
+                return null;
+            })
+            .catch(() => null);
+    }
+
+    // SATA/ATA
+    const runSmart = function(args) {
+        return L.resolveDefault(fs.exec('/usr/sbin/smartctl', args), null);
+    };
+
+    const attempts = [
+        ['--json=c', '-A', devicePath],
+        ['--json=c', '-A', '-d', 'sat', devicePath],
+        ['--json=c', '-A', '-d', 'ata', devicePath]
+    ];
+
+    const extractFromJson = function(jsonText) {
+        if (!jsonText) return null;
+        try {
+            const obj = (typeof jsonText === 'string') ? JSON.parse(jsonText) : jsonText;
+
+            if (obj.temperature && typeof obj.temperature === 'object' && obj.temperature.current !== undefined && obj.temperature.current !== null) {
+                const temp = parseInt(obj.temperature.current);
+                if (!isNaN(temp) && temp > 0 && temp < 200) {
+                    return temp + ' °C';
+                }
+            }
+
+            if (obj.ata_smart_attributes && Array.isArray(obj.ata_smart_attributes.table)) {
+                for (let i = 0; i < obj.ata_smart_attributes.table.length; i++) {
+                    const attr = obj.ata_smart_attributes.table[i];
+                    if (!attr || (attr.id !== 194 && !(attr.name && /temp/i.test(attr.name)))) continue;
+                    
+                    if (attr.value !== undefined && attr.value !== null) {
+                        const temp = parseInt(attr.value);
+                        if (!isNaN(temp) && temp > 0 && temp < 200) {
+                            return temp + ' °C';
+                        }
+                    }
+                    
+                    if (attr.raw && typeof attr.raw === 'object' && attr.raw.string) {
+                        const match = String(attr.raw.string).match(/(\d{1,3})/);
+                        if (match) {
+                            const temp = parseInt(match[1]);
+                            if (!isNaN(temp) && temp > 0 && temp < 200) {
+                                return temp + ' °C';
+                            }
+                        }
+                    }
+                    
+                    if (attr.raw && typeof attr.raw === 'string') {
+                        const match = attr.raw.match(/(\d{1,3})/);
+                        if (match) {
+                            const temp = parseInt(match[1]);
+                            if (!isNaN(temp) && temp > 0 && temp < 200) {
+                                return temp + ' °C';
+                            }
+                        }
+                    }
+                }
+            }
+
+            if (obj.temperature !== undefined && obj.temperature !== null && typeof obj.temperature === 'number') {
+                const temp = parseInt(obj.temperature);
+                if (!isNaN(temp) && temp > 0 && temp < 200) {
+                    return temp + ' °C';
+                }
+            }
+
+            if (obj['temperature.current'] || obj['Temperature'] || obj['temp']) {
+                const v = obj['temperature.current'] || obj['Temperature'] || obj['temp'];
+                if (typeof v === 'number') {
+                    const temp = parseInt(v);
+                    if (!isNaN(temp) && temp > 0 && temp < 200) {
+                        return temp + ' °C';
+                    }
+                }
+                if (typeof v === 'string') {
+                    const match = String(v).match(/(\d{1,3})/);
+                    if (match) {
+                        const temp = parseInt(match[1]);
+                        if (!isNaN(temp) && temp > 0 && temp < 200) {
+                            return temp + ' °C';
+                        }
+                    }
+                }
+            }
+
+            if (obj['nvme_smart_health'] && obj['nvme_smart_health'].temperature !== undefined && obj['nvme_smart_health'].temperature !== null) {
+                const temp = parseInt(obj['nvme_smart_health'].temperature);
+                if (!isNaN(temp) && temp > 0 && temp < 200) {
+                    return temp + ' °C';
+                }
+            }
+
+            if (obj.smart_status && obj.smart_status.temperature !== undefined && obj.smart_status.temperature !== null) {
+                const temp = parseInt(obj.smart_status.temperature);
+                if (!isNaN(temp) && temp > 0 && temp < 200) {
+                    return temp + ' °C';
+                }
+            }
+
+        } catch (e) {
+            console.error('Temperature extraction error:', e);
+            return null;
+        }
+        return null;
+    };
+
+    let sequence = Promise.resolve(null);
+    for (let ai = 0; ai < attempts.length; ai++) {
+        (function(args) {
+            sequence = sequence.then(function(found) {
+                if (found) return found;
+                return runSmart(args).then(function(res) {
+                    if (!res || res.code !== 0) return null;
+
+                    const fromJson = extractFromJson(res.stdout);
+                    if (fromJson) return fromJson;
+
+                    const out = res.stdout || '';
+                    const rx1 = out.match(/(?:Current Drive Temperature|Temperature|Drive Temperature|Temp)[^\\d\\n\\r]{0,6}([0-9]{1,3})/i);
+                    if (rx1 && rx1[1]) return rx1[1] + ' °C';
+
+                    const rx2 = out.match(/([0-9]{1,3})\s*°\s*C/i);
+                    if (rx2 && rx2[1]) return rx2[1] + ' °C';
+
+                    const rx3 = out.match(/:?\s*([\d]{1,3})\s+C\b/);
+                    if (rx3 && rx3[1]) return rx3[1] + ' °C';
+
+                    const lines = out.split('\n');
+                    for (let li = 0; li < lines.length; li++) {
+                        const line = lines[li];
+                        if (/Temperature_Celsius/i.test(line)) {
+                            const parts = line.trim().split(/\s+/);
+                            if (parts.length > 0) {
+                                for (let pi = parts.length - 1; pi >= 0; pi--) {
+                                    if (/^\d{1,3}$/.test(parts[pi])) {
+                                        const tempVal = parseInt(parts[pi]);
+                                        if (tempVal > 0 && tempVal < 200) {
+                                            return tempVal + ' °C';
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    }
+
+                    return null;
+                }).catch(function() { return null; });
+            });
+        })(attempts[ai]);
+    }
+
+    return sequence.catch(function() { return null; });
+},
+
+    getSmartStatus: function(device) {
+        const devicePath = '/dev/' + device;
+        const diskType = this.getDiskType(device);
+
+        // NVMe
+        if (diskType === 'nvme') {
+            return L.resolveDefault(fs.exec('/usr/sbin/nvme', ['smart-log', devicePath, '-o', 'json']), null)
+                .then(res => {
+                    if (res && res.code === 0) {
+                        try {
+                            const data = JSON.parse(res.stdout);
+                            if (data.critical_warning !== undefined) {
+                                if (data.critical_warning === 0) {
+                                    return { status: _('PASSED'), color: 'var(--app-mini-diskmanager-primary)' };
+                                } else {
+                                    return { status: _('WARNING'), color: 'var(--app-mini-diskmanager-warning)' };
+                                }
+                            }
+                            if (data.media_errors !== undefined && data.media_errors > 0) {
+                                return { status: _('ERRORS'), color: 'var(--app-mini-diskmanager-danger)' };
+                            }
+                            return { status: _('OK'), color: 'var(--app-mini-diskmanager-primary)' };
+                        } catch (e) {
+                            console.error('NVMe S.M.A.R.T. parse error:', e);
+                        }
+                    }
+                    return { status: '-', color: 'var(--text-color-secondary)' };
+                })
+                .catch(() => ({ status: '-', color: 'var(--text-color-secondary)' }));
+        }
+
+        // SATA/ATA
+        return L.resolveDefault(fs.exec('/usr/sbin/smartctl', ['-H', devicePath]), null)
+            .then(res => {
+                if (res && res.code === 0) {
+                    if (res.stdout.match(/PASSED/i)) {
+                        return { status: _('PASSED'), color: 'var(--app-mini-diskmanager-primary)' };
+                    } else if (res.stdout.match(/FAILED/i)) {
+                        return { status: _('FAILED'), color: 'var(--app-mini-diskmanager-danger)' };
+                    }
+                }
+                return { status: '-', color: 'var(--text-color-secondary)' };
+            }).catch(() => ({ status: '-', color: 'var(--text-color-secondary)' }));
+    },
+
+    // Convert hours
+    formatPowerOnTime: function(hours) {
+        if (!hours || hours === 0) return '-';
+        
+        let totalHours = parseInt(hours);
+        let days = Math.floor(totalHours / 24);
+        let remainingHours = totalHours % 24;
+        
+        let years = Math.floor(days / 365);
+        let remainingDays = days % 365;
+        let months = Math.floor(remainingDays / 30);
+        remainingDays = remainingDays % 30;
+        
+        let parts = [];
+        if (years > 0) parts.push(years + ' ' + (years === 1 ? _('year') : _('years')));
+        if (months > 0) parts.push(months + ' ' + (months === 1 ? _('month') : _('months')));
+        if (remainingDays > 0) parts.push(remainingDays + ' ' + (remainingDays === 1 ? _('day') : _('days')));
+        if (remainingHours > 0 && parts.length === 0) parts.push(remainingHours + ' ' + (remainingHours === 1 ? _('hour') : _('hours')));
+        
+        return parts.join(', ') || totalHours + ' ' + _('hours');
+    },
+
+    translateSmartAttribute: function(attrName) {
+        const translations = {
+            'Raw_Read_Error_Rate': _('Raw Read Error Rate'),
+            'Throughput_Performance': _('Throughput Performance'),
+            'Spin_Up_Time': _('Spin Up Time'),
+            'Start_Stop_Count': _('Start Stop Count'),
+            'Reallocated_Sector_Ct': _('Reallocated Sector Count'),
+            'Seek_Error_Rate': _('Seek Error Rate'),
+            'Seek_Time_Performance': _('Seek Time Performance'),
+            'Power_On_Hours': _('Power On Hours'),
+            'Spin_Retry_Count': _('Spin Retry Count'),
+            'Calibration_Retry_Count': _('Calibration Retry Count'),
+            'Power_Cycle_Count': _('Power Cycle Count'),
+            'Read_Soft_Error_Rate': _('Read Soft Error Rate'),
+            'Airflow_Temperature_Cel': _('Airflow Temperature'),
+            'Temperature_Celsius': _('Temperature Celsius'),
+            'Hardware_ECC_Recovered': _('Hardware ECC Recovered'),
+            'Current_Pending_Sector': _('Current Pending Sector'),
+            'Offline_Uncorrectable': _('Offline Uncorrectable'),
+            'UDMA_CRC_Error_Count': _('UDMA CRC Error Count'),
+            'Multi_Zone_Error_Rate': _('Multi Zone Error Rate'),
+            'Wear_Leveling_Count': _('Wear Leveling Count'),
+            'Used_Rsvd_Blk_Cnt_Tot': _('Used Reserved Block Count Total'),
+            'Used_Rsvd_Blk_Cnt_Chip': _('Used Reserved Block Count Chip'),
+            'Unused_Rsvd_Blk_Cnt_Tot': _('Unused Reserved Block Count Total'),
+            'Program_Fail_Cnt_Total': _('Program Fail Count Total'),
+            'Erase_Fail_Count_Total': _('Erase Fail Count Total'),
+            'Runtime_Bad_Block': _('Runtime Bad Block'),
+            'Uncorrectable_Error_Cnt': _('Uncorrectable Error Count'),
+            'Temperature_Exceed_Cnt': _('Temperature Exceed Count'),
+            'Erase_Fail_Count': _('Erase Fail Count'),
+            'Reported_Uncorrect': _('Reported Uncorrectable Errors'),
+            'High_Fly_Writes': _('High Fly Writes'),
+            'Airflow_Temperature': _('Airflow Temperature'),
+            'G_Sense_Error_Rate': _('G-Sense Error Rate'),
+            'G-Sense_Error_Rate': _('G-Sense Error Rate'),
+            'Power_Off_Retract_Count': _('Power-Off Retract Count'),
+            'Power-Off_Retract_Count': _('Power-Off Retract Count'),
+            'Load_Cycle_Count': _('Load Cycle Count'),
+            'Temperature_Case': _('Temperature Case'),
+            'Reallocated_Event_Count': _('Reallocated Event Count'),
+            'Transfer_Error_Rate': _('Transfer Error Rate'),
+            'Free_Fall_Sensor': _('Free Fall Sensor'),
+            'Total_LBAs_Written': _('Total LBAs Written'),
+            'Total_LBAs_Read': _('Total LBAs Read'),
+            'Read_Error_Retry_Rate': _('Read Error Retry Rate'),
+            'Min_W/E_Cycle': _('Minimum W/E Cycle'),
+            'Max_W/E_Cycle': _('Maximum W/E Cycle'),
+            'Average_W/E_Cycle': _('Average W/E Cycle'),
+            'Media_Wearout_Indicator': _('Media Wearout Indicator'),
+            'Available_Reservd_Space': _('Available Reserved Space'),
+            'SSD_Life_Left': _('SSD Life Left'),
+            'Remaining_Lifetime_Perc': _('Remaining Lifetime Percentage'),
+            'Percentage_Lifetime_Remain': _('Percentage Lifetime Remaining'),
+            'Remaining_Life': _('Remaining Life'),
+            'Lifetime_Writes_GiB': _('Lifetime Writes GiB'),
+            'Lifetime_Reads_GiB': _('Lifetime Reads GiB'),
+            'Available_Reserved_Space': _('Available Reserved Space'),
+            'Program_Fail_Count': _('Program Fail Count'),
+            'Erase_Fail_Count': _('Erase Fail Count'),
+            'Unexpected_Power_Loss_Ct': _('Unexpected Power Loss Count'),
+            'Thermal_Throttle_Status': _('Thermal Throttle Status'),
+            'End_to_End_Error': _('End-to-End Error'),
+            'End-to-End_Error': _('End-to-End Error'),
+            'Workld_Host_Reads_Perc': _('Workload Host Reads Percentage'),
+            'Workld_Media_Wear_Indic': _('Workload Media Wear Indicator'),
+            'Timed_Workld_Media_Wear': _('Timed Workload Media Wear'),
+            'Workload_Timer': _('Workload Timer'),
+            'Perc_Rated_Life_Used': _('Percentage Rated Life Used'),
+            'Head_Flying_Hours': _('Head Flying Hours'),
+            'Read_Channel_Margin': _('Read Channel Margin'),
+            'Loaded_Hours': _('Loaded Hours'),
+            'Load_Unload_Retry_Count': _('Load/Unload Retry Count'),
+            'Load/Unload_Retry_Count': _('Load/Unload Retry Count'),
+            'GMR_Head_Amplitude': _('GMR Head Amplitude'),
+            'Drive_Temperature': _('Drive Temperature'),
+            'Endurance_Remaining': _('Endurance Remaining'),
+            'Power_On_Hours_and_Msec': _('Power On Hours and Milliseconds'),
+            'Head_Health': _('Head Health'),
+            'POR_Recovery_Count': _('POR Recovery Count'),
+            'Unused_Reserve_NAND_Blk': _('Unused Reserve NAND Blocks'),
+            'SSD_Protect_Mode': _('SSD Protect Mode'),
+            'Host_Writes_32MiB': _('Host Writes 32MiB'),
+            'NAND_Writes_32MiB': _('NAND Writes 32MiB'),
+            'Remaining_Life_Left': _('Remaining Life Left'),
+            'Grown_Bad_Block_Count': _('Grown Bad Block Count'),
+            'Soft_Read_Error_Rate': _('Soft Read Error Rate'),
+            'Data_Address_Mark_Errs': _('Data Address Mark Errors'),
+            'Run_Out_Cancel': _('Run Out Cancel'),
+            'Soft_ECC_Correction': _('Soft ECC Correction'),
+            'TA_Increase_Count': _('TA Increase Count'),
+            'Shock_Count_Write_Opern': _('Shock Count Write Operation'),
+            'Shock_Rate_Write_Opern': _('Shock Rate Write Operation'),
+            'Flying_Height': _('Flying Height'),
+            'Spin_High_Current': _('Spin High Current'),
+            'Spin_Buzz': _('Spin Buzz'),
+            'Offline_Seek_Performnce': _('Offline Seek Performance'),
+            'Vibration_During_Write': _('Vibration During Write'),
+            'Shock_During_Write': _('Shock During Write'),
+            'Disk_Shift': _('Disk Shift'),
+            'Load_Retry_Count': _('Load Retry Count'),
+            'Load_Friction': _('Load Friction'),
+            'Load_In_Time': _('Load-in Time'),
+            'Torque_Amplification_Count': _('Torque Amplification Count'),
+            'Write_Error_Rate': _('Write Error Rate'),
+            'Critical_Warning': _('Critical Warning'),
+            'Percentage_Used': _('Percentage Used'),
+            'Data_Units_Read': _('Data Units Read'),
+            'Data_Units_Written': _('Data Units Written'),
+            'Host_Read_Commands': _('Host Read Commands'),
+            'Host_Write_Commands': _('Host Write Commands'),
+            'Controller_Busy_Time': _('Controller Busy Time'),
+            'Power_Cycles': _('Power Cycles'),
+            'Unsafe_Shutdowns': _('Unsafe Shutdowns'),
+            'Media_Errors': _('Media Errors'),
+            'Error_Log_Entries': _('Error Log Entries')
+        };
+        if (translations[attrName]) {
+            return translations[attrName];
+        }
+        return attrName.replace(/_/g, ' ');
+    },
+
+    translateDeviceInfoLabel: function(label) {
+        const deviceLabels = {
+            // SATA/ATA
+            'Model Family': _('Model Family'),
+            'Device Model': _('Device Model'),
+            'Serial Number': _('Serial Number'),
+            'Serial number': _('Serial Number'),
+            'LU WWN Device Id': _('LU WWN Device Id'),
+            'Firmware Version': _('Firmware Version'),
+            'User Capacity': _('User Capacity'),
+            'Capacity': _('Capacity'),
+            'Sector Size': _('Sector Size'),
+            'Sector Sizes': _('Sector Sizes'),
+            'Rotation Rate': _('Rotation Rate'),
+            'Form Factor': _('Form Factor'),
+            'Device is': _('Device is'),
+            'ATA Version is': _('ATA Version is'),
+            'SATA Version is': _('SATA Version is'),
+            'Local Time is': _('Local Time is'),
+            'SMART support is': _('SMART support is'),
+            'SMART Status': _('SMART Status'),
+            'Device': _('Device'),
+            // NVMe
+            'Model Number': _('Model Number'),
+            'Firmware Revision': _('Firmware Revision'),
+            'PCI Vendor/Subsystem ID': _('PCI Vendor/Subsystem ID'),
+            'IEEE OUI Identifier': _('IEEE OUI Identifier'),
+            'Total NVM Capacity': _('Total NVM Capacity'),
+            'Unallocated NVM Capacity': _('Unallocated NVM Capacity'),
+            'Controller ID': _('Controller ID'),
+            'Number of Namespaces': _('Number of Namespaces'),
+            'Namespace 1 Size/Capacity': _('Namespace 1 Size/Capacity'),
+            'Namespace 1 Formatted LBA Size': _('Namespace 1 Formatted LBA Size'),
+            'Namespace 1 IEEE EUI-64': _('Namespace 1 IEEE EUI-64'),  
+            // Plus
+            'logical/physical': _('logical/physical'),
+            'bytes': _('bytes'),
+            'blocks': _('blocks'),
+            'Solid State Device': _('Solid State Device')
+        };
+        
+        return deviceLabels[label] || label;
+    },
+
+    getDetailedSmartInfo: function(device) {
+        const devicePath = '/dev/' + device;
+        const diskType = this.getDiskType(device);
+
+        if (diskType === 'nvme') {
+            // NVMe
+            return L.resolveDefault(fs.exec('/usr/sbin/nvme', ['smart-log', devicePath, '-o', 'json']), null)
+                .then(res => {
+                    if (res && res.code === 0) {
+                        try {
+                            const data = JSON.parse(res.stdout);
+                            
+                            const safeNumber = (val, defaultVal = 0) => {
+                                if (val === undefined || val === null) return defaultVal;
+                                const num = typeof val === 'number' ? val : parseInt(val);
+                                return isNaN(num) ? defaultVal : num;
+                            };
+                            
+                            const criticalWarning = safeNumber(data.critical_warning, 0);
+                            const availSpare = safeNumber(data.avail_spare, null);
+                            const percentUsed = safeNumber(data.percent_used, null);
+                            const unsafeShutdowns = safeNumber(data.unsafe_shutdowns, 0);
+                            const mediaErrors = safeNumber(data.media_errors, 0);
+                            const errorLogEntries = safeNumber(data.num_err_log_entries, 0);
+                            
+                            return {
+                                type: 'nvme',
+                                raw: data,
+                                attributes: [
+                                    {
+                                        name: _('Critical Warning'),
+                                        value: criticalWarning,
+                                        status: (criticalWarning === 0) ? 'OK' : 'WARNING'
+                                    },
+                                    {
+                                        name: _('Temperature'),
+                                        value: data.temperature !== undefined ? (data.temperature - 273) + ' °C' : '-',
+                                        status: 'INFO'
+                                    },
+                                    {
+                                        name: _('Available Spare'),
+                                        value: availSpare !== null ? availSpare + '%' : '-',
+                                        status: availSpare !== null && availSpare >= 10 ? 'OK' : 'WARNING'
+                                    },
+                                    {
+                                        name: _('Available Spare Threshold'),
+                                        value: data.spare_thresh !== undefined ? data.spare_thresh + '%' : '-',
+                                        status: 'INFO'
+                                    },
+                                    {
+                                        name: _('Percentage Used'),
+                                        value: percentUsed !== null ? percentUsed + '%' : '-',
+                                        status: percentUsed !== null && percentUsed < 80 ? 'OK' : 'WARNING'
+                                    },
+                                    {
+                                        name: _('Data Units Read'),
+                                        value: data.data_units_read !== undefined ? data.data_units_read : '-',
+                                        status: 'INFO'
+                                    },
+                                    {
+                                        name: _('Data Units Written'),
+                                        value: data.data_units_written !== undefined ? data.data_units_written : '-',
+                                        status: 'INFO'
+                                    },
+                                    {
+                                        name: _('Host Read Commands'),
+                                        value: data.host_read_commands !== undefined ? data.host_read_commands : '-',
+                                        status: 'INFO'
+                                    },
+                                    {
+                                        name: _('Host Write Commands'),
+                                        value: data.host_write_commands !== undefined ? data.host_write_commands : '-',
+                                        status: 'INFO'
+                                    },
+                                    {
+                                        name: _('Controller Busy Time'),
+                                        value: data.controller_busy_time !== undefined ? data.controller_busy_time : '-',
+                                        status: 'INFO'
+                                    },
+                                    {
+                                        name: _('Power Cycles'),
+                                        value: data.power_cycles !== undefined ? data.power_cycles : '-',
+                                        status: 'INFO'
+                                    },
+                                    {
+                                        name: _('Power On Hours'),
+                                        value: data.power_on_hours !== undefined ? data.power_on_hours : '-',
+                                        status: 'INFO'
+                                    },
+                                    {
+                                        name: _('Unsafe Shutdowns'),
+                                        value: unsafeShutdowns,
+                                        status: unsafeShutdowns > 100 ? 'WARNING' : 'INFO'
+                                    },
+                                    {
+                                        name: _('Media Errors'),
+                                        value: mediaErrors,
+                                        status: mediaErrors > 0 ? 'ERROR' : 'OK'
+                                    },
+                                    {
+                                        name: _('Error Log Entries'),
+                                        value: errorLogEntries,
+                                        status: errorLogEntries > 0 ? 'WARNING' : 'OK'
+                                    }
+                                ]
+                            };
+                        } catch (e) {
+                            console.error('Parse NVMe S.M.A.R.T. error:', e);
+                            return null;
+                        }
+                    }
+                    return null;
+                })
+                .catch(err => {
+                    console.error('NVMe S.M.A.R.T. fetch error:', err);
+                    return null;
+                });
+        } else {
+            // SATA/ATA
+            return L.resolveDefault(fs.exec('/usr/sbin/smartctl', ['-A', '-j', devicePath]), null)
+                .then(res => {
+                    if (res && res.code === 0) {
+                        try {
+                            const data = JSON.parse(res.stdout);
+                            let attributes = [];
+                            
+                            if (data.ata_smart_attributes && Array.isArray(data.ata_smart_attributes.table)) {
+                                attributes = data.ata_smart_attributes.table
+                                    .filter(attr => attr && attr.id !== undefined)
+                                    .map(attr => {
+                                        let status = 'INFO';
+                                        const attrValue = attr.value !== undefined ? attr.value : null;
+                                        const attrThresh = attr.thresh !== undefined ? attr.thresh : null;
+                                        const attrWorst = attr.worst !== undefined ? attr.worst : null;
+                                        
+                                        if (attrThresh !== null && attrValue !== null && attrValue < attrThresh) {
+                                            status = 'ERROR';
+                                        } else if (attrWorst !== null && attrValue !== null && attrValue < attrWorst + 10) {
+                                            status = 'WARNING';
+                                        } else if (attrValue !== null && attrValue >= 100) {
+                                            status = 'OK';
+                                        }
+
+                                        let rawValue = '-';
+                                        if (attr.raw !== undefined) {
+                                            if (typeof attr.raw === 'object' && attr.raw !== null) {
+                                                if (attr.raw.string !== undefined) {
+                                                    rawValue = attr.raw.string;
+                                                } else if (attr.raw.value !== undefined) {
+                                                    rawValue = attr.raw.value;
+                                                }
+                                            } else if (attr.raw !== null) {
+                                                rawValue = attr.raw;
+                                            }
+                                        }
+
+                                        return {
+                                            id: attr.id,
+                                            name: attr.name || 'Unknown_Attr_' + attr.id,
+                                            value: attrValue !== null ? attrValue : '-',
+                                            worst: attrWorst !== null ? attrWorst : '-',
+                                            thresh: attrThresh !== null ? attrThresh : '-',
+                                            raw: rawValue,
+                                            status: status
+                                        };
+                                    });
+                            }
+
+                            return {
+                                type: 'sata',
+                                raw: data,
+                                attributes: attributes
+                            };
+                        } catch (e) {
+                            console.error('Parse SATA S.M.A.R.T. error:', e);
+                            return null;
+                        }
+                    }
+                    return null;
+                })
+                .catch(err => {
+                    console.error('SATA S.M.A.R.T. fetch error:', err);
+                    return null;
+                });
+        }
+    },
+
+    getDiskInfo: function(device) {
+        let devicePath = '/dev/' + device;
+        return Promise.all([
+            L.resolveDefault(fs.exec('/usr/sbin/fdisk', ['-l', devicePath]), null),
+            L.resolveDefault(fs.exec('/sbin/parted', [devicePath, 'unit', 'B', 'print', 'free']), null),
+            L.resolveDefault(fs.exec('/usr/bin/lsblk', ['-J', '-b', '-o', 'NAME,SIZE,TYPE,FSTYPE,MOUNTPOINT,LABEL,UUID,PARTTYPENAME', devicePath]), null),
+            this.getDiskModel(device),
+            this.getDiskTemperature(device),
+            this.getSmartStatus(device),
+            L.resolveDefault(fs.exec('/bin/df', ['-B1']), null)
+        ]).then(results => {
+            let diskInfo = {
+                device: device,
+                fdisk: (results[0] && results[0].code === 0) ? results[0].stdout : null,
+                parted: (results[1] && results[1].code === 0) ? results[1].stdout : null,
+                lsblk: null,
+                partitions: [],
+                model: results[3] || null,
+                temperature: results[4] || null,
+                smartStatus: results[5] || { status: 'N/A', color: 'var(--text-color-secondary)' },
+                hasPartitionTable: false
+            };
+
+            let dfData = {};
+            if (results[6] && results[6].code === 0) {
+                let dfLines = results[6].stdout.trim().split('\n');
+                dfLines.slice(1).forEach(line => {
+                    let parts = line.trim().split(/\s+/);
+                    if (parts.length >= 6 && parts[0].startsWith('/dev/')) {
+                        dfData[parts[0]] = {
+                            size: parseInt(parts[1]) || 0,
+                            used: parseInt(parts[2]) || 0,
+                            available: parseInt(parts[3]) || 0,
+                            usePercent: parts[4],
+                            mountpoint: parts[5]
+                        };
+                    }
+                });
+            }
+
+            if (results[1] && results[1].code === 0) {
+                diskInfo.hasPartitionTable = results[1].stdout.indexOf('Partition Table:') !== -1 &&
+                                            results[1].stdout.indexOf('unknown') === -1;
+            }
+
+            if (results[2] && results[2].code === 0) {
+                try {
+                    let data = JSON.parse(results[2].stdout);
+                    if (data.blockdevices && data.blockdevices[0]) {
+                        diskInfo.lsblk = data.blockdevices[0];
+                        diskInfo.size = data.blockdevices[0].size || 0;
+                        if (diskInfo.lsblk.children) {
+                            diskInfo.partitions = diskInfo.lsblk.children.map(part => {
+                                let partPath = '/dev/' + part.name;
+                                if (dfData[partPath]) {
+                                    part.used = dfData[partPath].used;
+                                    part.available = dfData[partPath].available;
+                                }
+                                return part;
+                            });
+                        }
+                    }
+                } catch (e) {
+                    console.log('lsblk JSON parse error:', e);
+                }
+            }
+
+            return diskInfo;
+        }).catch(err => {
+            console.log('getDiskInfo error:', err);
+            throw err;
+        });
+    },
+
+    parsePartedOutput: function(output) {
+        let lines = (output || '').split('\n');
+        let partitions = [];
+        let inPartitionTable = false;
+        let diskSize = 0;
+        let hasTypeColumn = false;
+        let freeCounter = 1;
+
+        const parseSize = function(sizeStr) {
+            if (!sizeStr) return 0;
+            let match = sizeStr.match(/([\d.]+)([KMGTB]*)/i);
+            if (!match) return 0;
+            let value = parseFloat(match[1]);
+            let unit = match[2].toUpperCase();
+            
+            switch(unit) {
+                case 'KB': return Math.floor(value * 1024);
+                case 'MB': return Math.floor(value * 1024 * 1024);
+                case 'GB': return Math.floor(value * 1024 * 1024 * 1024);
+                case 'TB': return Math.floor(value * 1024 * 1024 * 1024 * 1024);
+                case 'B':
+                default: return Math.floor(value);
+            }
+        };
+
+        for (let line of lines) {
+            if (line.includes('Disk /dev/')) {
+                let match = line.match(/:\s*([\d.]+)([KMGTB]*)/i);
+                if (match) diskSize = parseSize(match[1] + match[2]);
+            }
+
+            if (line.match(/^\s*Number/) && line.toLowerCase().includes('type')) {
+                hasTypeColumn = true;
+                inPartitionTable = true;
+                continue;
+            }
+
+            if (line.match(/^\s*Number/)) {
+                inPartitionTable = true;
+                continue;
+            }
+
+            if (inPartitionTable && line.trim()) {
+                let parts = line.trim().split(/\s+/);
+                
+                if (parts.length >= 3 && !/^\d+$/.test(parts[0]) && parts[0].match(/^\d+/)) {
+                    let partition = {
+                        number: 'free' + freeCounter++,
+                        start: parseSize(parts[0]),
+                        end: parseSize(parts[1]),
+                        size: parseSize(parts[2]),
+                        type: 'free',
+                        filesystem: 'free',
+                        flags: ''
+                    };
+                    partitions.push(partition);
+                    continue;
+                }
+                
+                if (parts.length >= 4) {
+                    let number = parts[0];
+                    if (!/^\d+$/.test(number)) {
+                        continue;
+                    }
+
+                    let partition = {
+                        number: number,
+                        start: parseSize(parts[1]),
+                        end: parseSize(parts[2]),
+                        size: parseSize(parts[3]),
+                        type: 'primary',
+                        filesystem: '',
+                        flags: ''
+                    };
+
+                    if (hasTypeColumn && parts.length >= 5) {
+                        partition.type = parts[4].toLowerCase();
+                        partition.filesystem = parts[5] || '';
+                        partition.flags = parts.slice(6).join(' ');
+                    } else if (parts.length >= 5) {
+                        partition.filesystem = parts[4] || '';
+                        partition.flags = parts.slice(5).join(' ');
+                    }
+                    if (partition.type === 'extended' && !partition.filesystem) {
+                        partition.filesystem = 'extended';
+                    }
+
+                    partitions.push(partition);
+                }
+            }
+        }
+
+        return { diskSize, partitions };
+    },
+
+    normalizeFsClass: function(fstypeRaw) {
+        if (!fstypeRaw) return 'unallocated';
+        let fs = (fstypeRaw || '').toString().toLowerCase().trim();
+        if (fs === 'fat32' || fs === 'fat') fs = 'vfat';
+        if (fs === 'linux-swap' || fs === 'swap') fs = 'swap';
+        if (fs === 'extended') fs = 'extended';
+        if (fs === 'space' || fs === 'free') fs = 'unallocated';
+        if (fs === '') fs = 'unallocated';
+        fs = fs.replace(/[^a-z0-9]/g, '');
+        if (!fs) fs = 'unallocated';
+        return fs;
+    },
+
+    getFriendlyFsName: function(fstype) {
+        if (!fstype) return '-';
+        let fs = this.normalizeFsClass(fstype);
+        
+        const friendlyNames = {
+            'ext2': 'Ext2',
+            'ext3': 'Ext3',
+            'ext4': 'Ext4',
+            'ntfs': 'NTFS',
+            'vfat': 'FAT32',
+            'exfat': 'exFAT',
+            'swap': 'Swap',
+            'f2fs': 'F2FS',
+            'extended': 'Extended',
+            'unallocated': 'Unallocated'
+        };
+        
+        return friendlyNames[fs] || fs.toUpperCase();
+    },
+
+    getPartitionPath: function(diskDevice, partNumber) {
+        if (!diskDevice) return null;
+        if (diskDevice.match(/^nvme[0-9]+n[0-9]+$/)) {
+            return '/dev/' + diskDevice + 'p' + partNumber;
+        }
+        if (diskDevice.match(/^mmcblk[0-9]+$/)) {
+            return '/dev/' + diskDevice + 'p' + partNumber;
+        }
+        return '/dev/' + diskDevice + partNumber;
+    },
+
+    waitForDevice: function(path, maxAttempts, delayMs) {
+        maxAttempts = maxAttempts || 10;
+        delayMs = delayMs || 500;
+        return new Promise((resolve) => {
+            let attempts = 0;
+            let check = () => {
+                fs.stat(path).then(() => resolve(true)).catch(() => {
+                    attempts++;
+                    if (attempts >= maxAttempts) resolve(false);
+                    else setTimeout(check, delayMs);
+                });
+            };
+            check();
+        });
+    },
+
+    getPartitionColor: function(type) {
+        const colorMap = {
+            'ext4': 'rgba(144, 195, 86, 0.8)',
+            'ext3': 'rgba(124, 179, 66, 0.8)',
+            'ext2': 'rgba(98, 146, 55, 0.8)',
+            'ntfs': 'rgba(61, 174, 233, 0.8)',
+            'vfat': 'rgba(246, 116, 0, 0.8)',
+            'fat32': 'rgba(246, 116, 0, 0.8)',
+            'exfat': 'rgba(255, 152, 0, 0.8)',
+            'swap': 'rgba(244, 67, 54, 0.8)',
+            'f2fs': 'rgba(156, 39, 176, 0.8)',
+            'extended': 'rgba(158, 158, 158, 0.8)',
+            'primary': 'rgba(100, 149, 237, 0.8)',
+            'logical': 'rgba(173, 216, 230, 0.8)',
+            'unallocated': 'rgba(224, 224, 224, 0.5)',
+            'free': 'rgba(224, 224, 224, 0.5)'
+        };
+
+        const isDarkMode = document.documentElement.getAttribute('data-darkmode') === 'true';
+
+        if (isDarkMode) {
+            const darkColorMap = {
+                'ext4': 'rgba(90, 138, 47, 0.8)',
+                'ext3': 'rgba(74, 118, 36, 0.8)',
+                'ext2': 'rgba(58, 96, 25, 0.8)',
+                'ntfs': 'rgba(42, 125, 186, 0.8)',
+                'vfat': 'rgba(197, 88, 0, 0.8)',
+                'fat32': 'rgba(197, 88, 0, 0.8)',
+                'exfat': 'rgba(230, 126, 34, 0.8)',
+                'swap': 'rgba(198, 40, 40, 0.8)',
+                'f2fs': 'rgba(123, 31, 162, 0.8)',
+                'extended': 'rgba(97, 97, 97, 0.8)',
+                'primary': 'rgba(65, 105, 225, 0.8)',
+                'logical': 'rgba(100, 149, 237, 0.8)',
+                'unallocated': 'rgba(66, 66, 66, 0.5)',
+                'free': 'rgba(66, 66, 66, 0.5)'
+            };
+            return darkColorMap[type] || 'transparent';
+        }
+
+        return colorMap[type] || 'transparent';
+    },
+
+    getPartitionType: function(part, diskInfo) {
+        if (!part || !diskInfo) return 'primary';
+
+        if (diskInfo.parted) {
+            let partNum = part.name.match(/\d+$/);
+            if (partNum) {
+                let parsed = this.parsePartedOutput(diskInfo.parted);
+                let partedInfo = parsed.partitions.find(p => p.number === partNum[0]);
+                if (partedInfo && partedInfo.type) {
+                    return partedInfo.type;
+                }
+                if (partedInfo && partedInfo.filesystem === 'extended') {
+                    return 'extended';
+                }
+            }
+        }
+
+        let partTypeClass = 'primary';
+        if (part.parttypename) {
+            let t = (part.parttypename || '').toLowerCase();
+            if (t.indexOf('extended') !== -1) partTypeClass = 'extended';
+            else if (t.indexOf('logical') !== -1) partTypeClass = 'logical';
+            else partTypeClass = 'primary';
+        }
+
+        let partNum = part.name.match(/\d+$/);
+        if (partTypeClass === 'primary' && partNum && parseInt(partNum[0]) >= 5) {
+            partTypeClass = 'logical';
+        }
+        return partTypeClass;
+    },
+
+    isDiskMounted: function(diskDevice) {
+        if (!diskDevice || !this.diskData[diskDevice]) return false;
+        let diskInfo = this.diskData[diskDevice];
+        if (!diskInfo.partitions) return false;
+        for (let part of diskInfo.partitions) {
+            if (part.mountpoint && part.mountpoint !== '') {
+                return true;
+            }
+        }
+        return false;
+    },
+
+    isPartitionMounted: function(partition) {
+        if (!partition) return false;
+        return partition.mountpoint && partition.mountpoint !== '';
+    },
+
+    hasAnyPartitionMounted: function(diskDevice) {
+        if (!diskDevice || !this.diskData[diskDevice]) return false;
+        let diskInfo = this.diskData[diskDevice];
+        if (!diskInfo.partitions) return false;
+        for (let part of diskInfo.partitions) {
+            if (part.mountpoint && part.mountpoint !== '') {
+                return true;
+            }
+        }
+        return false;
+    },
+
+    getAvailableSpaceForResize: function(partition) {
+        if (!partition || !this.selectedDisk) return 0;
+        
+        let diskInfo = this.diskData[this.selectedDisk];
+        if (!diskInfo || !diskInfo.parted) return 0;
+
+        let parsed = this.parsePartedOutput(diskInfo.parted);
+        let partNum = partition.name.match(/\d+$/);
+        if (!partNum) return 0;
+
+        let currentPart = parsed.partitions.find(p => p.number === partNum[0]);
+        if (!currentPart) return 0;
+
+        const SECTOR_ALIGNMENT_TOLERANCE = 1048576;
+
+        for (let part of parsed.partitions) {
+            let ptype = (part.type || '').toLowerCase();
+            let fs = (part.filesystem || '').toLowerCase();
+            
+            if (ptype === 'extended' || fs === 'extended') {
+                continue;
+            }
+            
+            if (ptype === 'free' || fs === 'free' || fs === '' || fs === 'unallocated') {
+                let distance = part.start - currentPart.end;
+                if (distance >= 0 && distance <= SECTOR_ALIGNMENT_TOLERANCE) {
+                    return part.size;
+                }
+            }
+        }
+        return 0;
+    },
+
+    canResizePartition: function(partition) {
+        if (!partition) return false;
+        
+        let fstype = this.normalizeFsClass(partition.fstype);
+        if (fstype !== 'ext2' && fstype !== 'ext3' && fstype !== 'ext4') {
+            return false;
+        }
+
+        if (this.isPartitionMounted(partition)) {
+            return false;
+        }
+
+        let availableSpace = this.getAvailableSpaceForResize(partition);
+        const MIN_RESIZE_SPACE = 10 * 1024 * 1024; // 10MB minimum
+        
+        if (availableSpace < MIN_RESIZE_SPACE) {
+            return false;
+        }
+
+        let diskInfo = this.diskData[this.selectedDisk];
+        if (!diskInfo || !diskInfo.parted) return false;
+
+        let parsed = this.parsePartedOutput(diskInfo.parted);
+        let partNum = partition.name.match(/\d+$/);
+        if (!partNum) return false;
+
+        let currentPart = parsed.partitions.find(p => p.number === partNum[0]);
+        if (!currentPart) return false;
+
+        for (let part of parsed.partitions) {
+            let ptype = (part.type || '').toLowerCase();
+            let fs = (part.filesystem || '').toLowerCase();
+            
+            if (ptype === 'free' || fs === 'free' || fs === '' || fs === 'unallocated') {
+                continue;
+            }
+            
+            if (part.start > currentPart.end) {
+                return false;
+            }
+        }
+
+        return true;
+    },
+
+    getLogicalPartitionsInExtended: function(diskInfo, extendedPartNumber) {
+        if (!diskInfo.partitions) return [];
+        let logical = diskInfo.partitions.filter(p => {
+            let partTypeClass = this.getPartitionType(p, diskInfo);
+            let partNum = p.name.match(/\d+$/);
+            if (!partNum) return false;
+            let num = parseInt(partNum[0]);
+            return partTypeClass === 'logical' && num > parseInt(extendedPartNumber);
+        });
+
+        logical.sort((a, b) => {
+            let aNum = parseInt(a.name.match(/\d+$/)[0]);
+            let bNum = parseInt(b.name.match(/\d+$/)[0]);
+            return aNum - bNum;
+        });
+
+        return logical;
+    },
+
+    getTotalUnallocatedSpace: function(diskInfo) {
+        let totalDiskSize = 0;
+        if (diskInfo.lsblk && diskInfo.lsblk.size) {
+            totalDiskSize = diskInfo.lsblk.size;
+        } else if (diskInfo.parted) {
+            let parsed = this.parsePartedOutput(diskInfo.parted);
+            totalDiskSize = parsed.diskSize || 0;
+        }
+
+        if (totalDiskSize === 0) return 0;
+
+        if (!diskInfo.hasPartitionTable) {
+            return totalDiskSize;
+        }
+
+        let usedSpace = 0;
+        if (diskInfo.partitions && diskInfo.partitions.length > 0) {
+            diskInfo.partitions.forEach(part => {
+                if (part.size) {
+                    usedSpace += part.size;
+                }
+            });
+        }
+
+        if (usedSpace === 0 && diskInfo.parted) {
+            let parsed = this.parsePartedOutput(diskInfo.parted);
+            parsed.partitions.forEach(part => {
+                let fsType = (part.filesystem || '').toLowerCase();
+                if (fsType !== 'free' && fsType !== 'space' && 
+                    fsType !== 'unallocated' && fsType !== '') {
+                    usedSpace += part.size;
+                }
+            });
+        }
+
+        let reservedSpace = 1024 * 1024;
+        let freeSpace = totalDiskSize - usedSpace - reservedSpace;
+
+        return Math.max(0, freeSpace);
+    },
+
+    render: function(data) {
+        let devices = data[0] || [];
+        this.mountedPartitions = data[1] || {};
+
+        let diskSelect = E('select', {
+            'class': 'cbi-input-select',
+            'style': 'max-width: 400px;',
+            'change': ui.createHandlerFn(this, function(ev) {
+                this.saveSettingsToLocalStorage(ev.target.value);
+                this.selectedDisk = ev.target.value;
+                this.selectedPartition = null;
+                this.selectedUnallocated = null;
+                this.refreshDiskView();
+            })
+        }, [E('option', {'value': ''}, _('-- ' + _('Select a disk') + ' --'))]);
+
+        devices.forEach(dev => {
+            let sizeStr = dev.size ? ' - ' + this.formatSize(dev.size) : '';
+            let modelStr = dev.model ? ' (' + dev.model.trim() + ')' : '';
+            diskSelect.appendChild(E('option', {'value': dev.name}, '/dev/' + dev.name + sizeStr + modelStr));
+        });
+
+        if (this.selectedDisk && this.selectedDisk !== '') {
+            let options = diskSelect.querySelectorAll('option');
+            for (let i = 0; i < options.length; i++) {
+                if (options[i].value === this.selectedDisk) {
+                    diskSelect.selectedIndex = i;
+                    break;
+                }
+            }
+        }
+
+	let controls = E('div', {'class': 'controls'}, [
+            E('div', {}, [
+                E('label', {}, _('Disk') + ':'),
+                E('span', {'class': 'control-group'}, [
+                    diskSelect,
+                    E('button', {
+                        'class': 'btn cbi-button',
+                        'click': ui.createHandlerFn(this, function() {
+                            if (!this.selectedDisk || this.selectedDisk === '') {
+                                window.location.reload();
+                            } else {
+                                this.refreshDiskView();
+                            }
+                        })
+                    }, _('Refresh'))
+                ])
+            ]),
+            E('div', {}, [
+                E('label', {}, _('Mounting actions') + ':'),
+                E('span', {'class': 'control-group'}, [
+                    E('button', {
+                        'id': 'btn-mount',
+                        'class': 'btn',
+                        'click': ui.createHandlerFn(this, this.mountDisk),
+                        'disabled': 'disabled'
+                    }, _('Mount')),
+                    E('button', {
+                        'id': 'btn-unmount',
+                        'class': 'btn cbi-button-negative',
+                        'click': ui.createHandlerFn(this, this.unmountDisk),
+                        'disabled': 'disabled'
+                    }, _('Unmount'))
+                ])
+            ]),
+            E('div', {}, [
+                E('label', {}, _('S.M.A.R.T. Status') + ':'),
+                E('span', {'class': 'control-group'}, [
+                    E('button', {
+                        'id': 'btn-smart',
+                        'class': 'btn cbi-button-action',
+                        'click': ui.createHandlerFn(this, this.showSmartDialog),
+                        'disabled': 'disabled'
+                    }, _('Show'))
+                ])
+            ]),
+            E('div', {}, [
+                E('label', {}, _('Actions on partitions') + ':'),
+                E('span', {'class': 'control-group'}, [
+                    E('button', {
+                        'id': 'btn-create',
+                        'class': 'btn cbi-button-positive',
+                        'click': ui.createHandlerFn(this, this.showCreatePartitionDialog),
+                        'disabled': 'disabled'
+                    }, _('Create')),
+                    E('button', {
+                        'id': 'btn-resize',
+                        'class': 'btn cbi-button-action',
+                        'click': ui.createHandlerFn(this, this.showResizeDialog),
+                        'disabled': 'disabled'
+                    }, _('Expand')),
+                    E('button', {
+                        'id': 'btn-delete',
+                        'class': 'btn cbi-button-negative',
+                        'click': ui.createHandlerFn(this, this.showDeleteDialog),
+                        'disabled': 'disabled'
+                    }, _('Delete')),
+                    E('button', {
+                        'id': 'btn-format',
+                        'class': 'cbi-button cbi-button-negative important',
+                        'click': ui.createHandlerFn(this, this.showFormatDialog),
+                        'disabled': 'disabled'
+                    }, _('Format')),
+                    E('button', {
+                        'id': 'btn-wipe',
+                        'class': 'cbi-button cbi-button-action important',
+                        'click': ui.createHandlerFn(this, this.showWipeDialog),
+                        'disabled': 'disabled'
+                    }, _('Wipe'))
+                ])
+            ])
+        ]);
+
+        let contentArea = E('div', {'id': 'disk-content-area'}, [
+            E('div', {'class': 'alert alert-info'}, _('Please select a disk to view its partitions'))
+        ]);
+
+        if (this.selectedDisk && this.selectedDisk !== '') {
+            setTimeout(() => {
+                this.refreshDiskView();
+            }, 0);
+        }
+
+        return E([
+            E('h2', {'class': 'fade-in'}, _('Disk Manager')),
+            E('div', {'class': 'cbi-section fade-in'}, [
+                E('div', {'class': 'cbi-section-descr'}, 
+                    _('The Mini Disk Manager package allows users to easily manage disks and partitions.')),
+                controls,
+                E('div', {'id': 'operation-status', 'class': 'operation-status'}),
+                contentArea
+            ])
+        ]);
+    },
+
+    renderPartitionBar: function(diskInfo) {
+        if (!diskInfo.hasPartitionTable || !diskInfo.parted) {
+            let diskSize = diskInfo.lsblk ? diskInfo.lsblk.size : 0;
+
+            let barContainer = E('div', {'class': 'disk-partition-bar'});
+
+            let segment = E('div', {
+                'class': 'partition-segment unallocated',
+                'style': 'width: 100%; position: relative;',
+                'data-partition-index': 0,
+                'data-is-unallocated': 'true',
+                'data-partition-size': diskSize,
+                'data-partition-start': 0,
+                'data-partition-end': diskSize
+            });
+
+            segment.addEventListener('click', (ev) => {
+                const alreadySelected = segment.classList.contains('selected');
+                document.querySelectorAll('.partition-segment').forEach(s => s.classList.remove('selected'));
+
+                const allCheckboxes = document.querySelectorAll('input[name^="partition_select_"]');
+                allCheckboxes.forEach(cb => cb.checked = false);
+
+                if (alreadySelected) {
+                    this.selectedUnallocated = null;
+                    const noTableCheckbox = document.querySelector('input[name="unallocated_select"]');
+                    if (noTableCheckbox) {
+                        noTableCheckbox.checked = false;
+                    }
+                } else {
+                    segment.classList.add('selected');
+                    this.selectedUnallocated = {
+                        size: diskSize,
+                        start: 0,
+                        end: diskSize,
+                        index: 0
+                    };
+                    const noTableCheckbox = document.querySelector('input[name="unallocated_select"]');
+                    if (noTableCheckbox) {
+                        noTableCheckbox.checked = true;
+                    }
+                }
+                this.selectedPartition = null;
+                this.updateActionButtons();
+            }, false);
+
+            segment.appendChild(E('div', {'class': 'partition-label'}, _('Area without partition table')));
+            segment.appendChild(E('div', {'class': 'partition-size'}, this.formatSize(diskSize)));
+
+            barContainer.appendChild(segment);
+
+            let legendRow = [
+                E('td', {
+                    'class': 'td top',
+                    'style': `
+                        padding:4px 8px;
+                        text-align:center;
+                        vertical-align:middle;
+                        white-space:nowrap;
+                    `
+                }, [
+                    E('strong', {
+                        'style': `
+                            display:inline-block;
+                            position:relative;
+                            padding-bottom:2px;
+                            font-weight:600;
+                            font-size:12px;
+                            line-height:1.2;
+                        `
+                    }, [
+                        E('span', {
+                            'style': `
+                                position:relative;
+                                z-index:2;
+                            `
+                        }, [_('Unallocated')]),
+                        E('span', {
+                            'style': `
+                                position:absolute;
+                                left:0;
+                                right:0;
+                                margin:auto;
+                                bottom:0;
+                                width:calc(100%);
+                                height:2px;
+                                max-width:90%;
+                                background-color:${this.getPartitionColor('unallocated')};
+                                border-radius:1px;
+                            `
+                        })
+                    ])
+                ])
+            ];
+
+            let legendTable = E('table', {
+                'class': 'table',
+                'style': `
+                    width:auto;
+                    margin:0 auto;
+                    margin-top:12px;
+                    border-collapse:collapse;
+                    table-layout:auto;
+                `
+            }, [E('tr', {'class': 'tr'}, legendRow)]);
+
+            let legend = E('div', {
+                'style': `
+                    margin-top:15px;
+                    text-align:center;
+                    font-size:12px;
+                    color:var(--text-color-secondary);
+                `
+            }, [legendTable]);
+
+            return E('div', {}, [barContainer, legend]);
+        }
+
+        let parsed = this.parsePartedOutput(diskInfo.parted);
+        let diskSize = parsed.diskSize;
+        let partitions = parsed.partitions;
+
+        if (!diskSize || partitions.length === 0) {
+            let totalSize = diskInfo.lsblk ? diskInfo.lsblk.size : 0;
+
+            let barContainer = E('div', {'class': 'disk-partition-bar'});
+
+            let segment = E('div', {
+                'class': 'partition-segment unallocated',
+                'style': 'width: 100%; position: relative;',
+                'data-partition-index': 0,
+                'data-is-unallocated': 'true',
+                'data-partition-size': totalSize,
+                'data-partition-start': 0,
+                'data-partition-end': totalSize
+            });
+
+            segment.addEventListener('click', (ev) => {
+                const alreadySelected = segment.classList.contains('selected');
+                document.querySelectorAll('.partition-segment').forEach(s => s.classList.remove('selected'));
+
+                const allCheckboxes = document.querySelectorAll('input[name^="partition_select_"]');
+                allCheckboxes.forEach(cb => cb.checked = false);
+
+                if (alreadySelected) {
+                    this.selectedUnallocated = null;
+                    const noTableCheckbox = document.querySelector('input[name="unallocated_select"]');
+                    if (noTableCheckbox) {
+                        noTableCheckbox.checked = false;
+                    }
+                } else {
+                    segment.classList.add('selected');
+                    this.selectedUnallocated = {
+                        size: totalSize,
+                        start: 0,
+                        end: totalSize,
+                        index: 0
+                    };
+                    const noTableCheckbox = document.querySelector('input[name="unallocated_select"]');
+                    if (noTableCheckbox) {
+                        noTableCheckbox.checked = true;
+                    }
+                }
+                this.selectedPartition = null;
+                this.updateActionButtons();
+            }, false);
+
+            segment.appendChild(E('div', {'class': 'partition-label'}, _('Area without partition table')));
+            segment.appendChild(E('div', {'class': 'partition-size'}, this.formatSize(totalSize)));
+
+            barContainer.appendChild(segment);
+
+            let legendRow = [
+                E('td', {
+                    'class': 'td top',
+                    'style': `
+                        padding:4px 8px;
+                        text-align:center;
+                        vertical-align:middle;
+                        white-space:nowrap;
+                    `
+                }, [
+                    E('strong', {
+                        'style': `
+                            display:inline-block;
+                            position:relative;
+                            padding-bottom:2px;
+                            font-weight:600;
+                            font-size:12px;
+                            line-height:1.2;
+                        `
+                    }, [
+                        E('span', {
+                            'style': `
+                                position:relative;
+                                z-index:2;
+                            `
+                        }, [_('Unallocated')]),
+                        E('span', {
+                            'style': `
+                                position:absolute;
+                                left:0;
+                                right:0;
+                                margin:auto;
+                                bottom:0;
+                                width:calc(100%);
+                                height:2px;
+                                max-width:90%;
+                                background-color:${this.getPartitionColor('unallocated')};
+                                border-radius:1px;
+                            `
+                        })
+                    ])
+                ])
+            ];
+
+            let legendTable = E('table', {
+                'class': 'table',
+                'style': `
+                    width:auto;
+                    margin:0 auto;
+                    margin-top:12px;
+                    border-collapse:collapse;
+                    table-layout:auto;
+                `
+            }, [E('tr', {'class': 'tr'}, legendRow)]);
+
+            let legend = E('div', {
+                'style': `
+                    margin-top:15px;
+                    text-align:center;
+                    font-size:12px;
+                    color:var(--text-color-secondary);
+                `
+            }, [legendTable]);
+
+            return E('div', {}, [barContainer, legend]);
+        }
+
+        let barContainer = E('div', {'class': 'disk-partition-bar'});
+        let usedTypes = new Set();
+        let unallocCounter = 0;
+
+        for (let i = 0; i < partitions.length; i++) {
+            let part = partitions[i];
+            let percentage = diskSize > 0 ? (part.size / diskSize * 100) : 0;
+            percentage = Math.max(0.1, percentage);
+
+            let fsTypeRaw = part.filesystem ? part.filesystem.toLowerCase() : 'unallocated';
+            let fsType = this.normalizeFsClass(fsTypeRaw);
+            let isUnallocated = fsType === 'unallocated' || fsTypeRaw === 'free';
+
+            // Hide < 200 MB
+            if (isUnallocated && part.size < this.MIN_VISIBLE_SIZE) {
+                continue;
+            }
+
+            let partTypeClass = 'primary';
+            let displayFsType = fsType;
+            let isExtended = false;
+            let actualFsType = null;
+            let isLogical = false;
+
+            if (diskInfo.partitions) {
+                let matchingPart = diskInfo.partitions.find(p => {
+                    let partNum = p.name.match(/\d+$/);
+                    return partNum && partNum[0] === part.number;
+                });
+                if (matchingPart) {
+                    partTypeClass = this.getPartitionType(matchingPart, diskInfo);
+                    actualFsType = matchingPart.fstype ? this.normalizeFsClass(matchingPart.fstype) : null;
+
+                    isLogical = partTypeClass === 'logical';
+
+                    if (fsType === 'extended' || partTypeClass === 'extended') {
+                        partTypeClass = 'extended';
+                        displayFsType = 'extended';
+                        isExtended = true;
+                    } else if (matchingPart.fstype) {
+                        displayFsType = this.normalizeFsClass(matchingPart.fstype);
+                    }
+                }
+            } else if (part.type === 'logical') {
+                isLogical = true;
+            }
+
+            if (isLogical) {
+                continue;
+            }
+
+            if (isUnallocated && (part.type === 'free' || part.filesystem === 'free')) {
+                let isInsideExtended = false;
+                for (let extPart of parsed.partitions) {
+                    if ((extPart.type === 'extended' || extPart.filesystem === 'extended') &&
+                        part.start >= extPart.start && part.end <= extPart.end) {
+                        isInsideExtended = true;
+                        break;
+                    }
+                }
+                if (isInsideExtended) {
+                    continue;
+                }
+            }
+
+            let outerColorClass = isUnallocated ? 'unallocated' : partTypeClass;
+            if (!isUnallocated) {
+                usedTypes.add(partTypeClass);
+                if (actualFsType && actualFsType !== 'unallocated') {
+                    usedTypes.add(actualFsType);
+                }
+            } else {
+                usedTypes.add('unallocated');
+            }
+
+            let partitionLabel = isUnallocated ? 
+                _('Free Space') : 
+                this.getPartitionPath(diskInfo.device, part.number);
+
+            let segment = E('div', {
+                'class': 'partition-segment ' + outerColorClass,
+                'style': 'width: ' + percentage.toFixed(2) + '%; position: relative;',
+                'data-partition-index': i,
+                'data-partition-number': part.number,
+                'data-is-unallocated': isUnallocated ? 'true' : 'false',
+                'data-partition-size': part.size,
+                'data-partition-start': part.start,
+                'data-partition-end': part.end
+            });
+
+            if (isUnallocated) {
+                segment.setAttribute('data-unallocated-index', unallocCounter);
+            }
+
+            if (!isUnallocated) {
+                segment.addEventListener('click', (ev) => {
+                    if (this.wipeAllEnabled) {
+                        return;
+                    }
+                    
+                    let partPath = this.getPartitionPath(diskInfo.device, part.number);
+                    let partName = partPath.replace('/dev/', '');
+                    let checkbox = document.querySelector('.partition-select-checkbox[data-partition="' + partName + '"]');
+                    
+                    if (checkbox && !checkbox.disabled) {
+                        checkbox.checked = !checkbox.checked;
+                        checkbox.dispatchEvent(new Event('click'));
+                    }
+                }, false);
+            } else {
+                segment.addEventListener('click', (ev) => {
+                    if (this.wipeAllEnabled) {
+                        return;
+                    }
+                    
+                    let unallocIndex = segment.getAttribute('data-unallocated-index');
+                    let checkbox = document.querySelector('input[name="unallocated_select"][data-unallocated-index="' + unallocIndex + '"]');
+                    
+                    if (checkbox && !checkbox.disabled) {
+                        checkbox.checked = !checkbox.checked;
+                        checkbox.dispatchEvent(new Event('click'));
+                    }
+                }, false);
+            }
+
+            // Magic 8%
+            if (percentage < 8) {
+                segment.setAttribute('title', partitionLabel + ' — ' + this.formatSize(part.size));
+                barContainer.appendChild(segment);
+                if (isUnallocated) {
+                    unallocCounter++;
+                }
+                continue;
+            }
+
+            if (isExtended) {
+                let logicalParts = this.getLogicalPartitionsInExtended(diskInfo, part.number);
+                if (logicalParts.length > 0) {
+                    logicalParts.sort((a, b) => {
+                        let aNum = parseInt(a.name.match(/\d+$/)[0]);
+                        let bNum = parseInt(b.name.match(/\d+$/)[0]);
+                        return aNum - bNum;
+                    });
+
+                    let innerContainer = E('div', {
+                        'class': 'partition-inner-fs',
+                        'style': 'position: absolute; top: 2px; left: 2px; right: 2px; bottom: 2px; width: calc(100% - 4px); height: calc(100% - 4px); display: flex; z-index: 1;'
+                    });
+
+                    let totalExtendedSize = part.size;
+                    let usedLogicalSize = 0;
+
+                    logicalParts.forEach(lp => {
+                        usedLogicalSize += (lp.size || 0);
+                    });
+
+                    logicalParts.forEach((lp, idx) => {
+                        let lpFsType = this.normalizeFsClass(lp.fstype);
+                        let lpPercentage = totalExtendedSize > 0 ? ((lp.size || 0) / totalExtendedSize * 100) : 0;
+                        lpPercentage = Math.max(1, lpPercentage);
+                        let lpColorClass = lpFsType && lpFsType !== 'unallocated' ? lpFsType : 'logical';
+
+                        let innerSegment = E('div', {
+                            'class': 'partition-inner-segment ' + lpColorClass,
+                            'style': `
+                                width: ${lpPercentage.toFixed(2)}%;
+                                height: 100%;
+                                display: flex;
+                                flex-direction: column;
+                                align-items: center;
+                                justify-content: center;
+                                border-right: 1px solid rgba(255,255,255,0.4);
+                                font-size: 9px;
+                                font-weight: bold;
+                                color: #fff;
+                                text-shadow: 0 1px 3px rgba(0,0,0,0.6);
+                                position: relative;
+                                overflow: hidden;
+                                border-radius: 2px;
+                            `
+                        });
+                        
+                        innerSegment.addEventListener('click', (ev) => {
+                            ev.stopPropagation();
+                            
+                            if (this.wipeAllEnabled) {
+                                return;
+                            }
+                            
+                            let checkbox = document.querySelector('.partition-select-checkbox[data-partition="' + lp.name + '"]');
+                            if (checkbox && !checkbox.disabled) {
+                                checkbox.checked = !checkbox.checked;
+                                checkbox.dispatchEvent(new Event('click'));
+                            }
+                        }, false);
+                        
+                        // Magic 8%
+                        if (lpPercentage < 8) {
+                            innerSegment.setAttribute('title', '/dev/' + lp.name + ' — ' + this.formatSize(lp.size));
+                        } else {
+                            innerSegment.appendChild(E('div', {
+                                'style': 'font-size: 11px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 90%;'
+                            }, '/dev/' + lp.name));
+                            if (lpFsType && lpFsType !== 'unallocated') {
+                                innerSegment.appendChild(E('div', {
+                                    'style': 'font-size: 9px; margin-top: 2px; text-transform: uppercase;'
+                                }, lpFsType));
+                            }
+                            innerSegment.appendChild(E('div', {
+                                'style': 'font-size: 10px; margin-top: 2px; opacity: 0.9;'
+                            }, this.formatSize(lp.size)));
+                        }
+                        innerContainer.appendChild(innerSegment);
+
+                        if (lpFsType && lpFsType !== 'unallocated') {
+                            usedTypes.add(lpFsType);
+                        }
+                    });
+
+                    let freeInExtended = totalExtendedSize - usedLogicalSize;
+                    let freePercentage = totalExtendedSize > 0 ? (freeInExtended / totalExtendedSize * 100) : 0;
+
+                    if (freePercentage >= 8) {
+                        let freeSegment = E('div', {
+                            'class': 'partition-inner-segment unallocated',
+                            'style': `
+                                width: ${freePercentage.toFixed(2)}%;
+                                height: 100%;
+                                display: flex;
+                                flex-direction: column;
+                                align-items: center;
+                                justify-content: center;
+                                font-size: 10px;
+                                color: #fff;
+                                background-color: var(--partition-color-free);
+                                text-shadow: 0 1px 3px rgba(0,0,0,0.6);
+                            `
+                        });
+                        freeSegment.appendChild(E('div', {'style': 'font-size: 9px; opacity: 0.85;'}, partitionLabel));
+                        freeSegment.appendChild(E('div', {'style': 'margin-top: 2px; font-size: 10px;'}, _('Free')));
+                        freeSegment.appendChild(E('div', {'style': 'margin-top: 2px; font-weight: 600;'}, 
+                            this.formatSize(freeInExtended)));
+                        innerContainer.appendChild(freeSegment);
+                    }
+
+                    segment.appendChild(innerContainer);
+
+                } else {
+                    segment.appendChild(E('div', {
+                        'class': 'partition-label',
+                        'style': 'position: relative; z-index: 2; pointer-events: none; font-size: 10px;'
+                    }, partitionLabel));
+                    segment.appendChild(E('div', {
+                        'class': 'partition-size',
+                        'style': 'position: relative; z-index: 2; pointer-events: none; font-size: 10px;'
+                    }, this.formatSize(part.size)));
+                }
+            } else if (!isUnallocated && actualFsType && actualFsType !== 'unallocated') {
+                let fsColorClass = actualFsType;
+                let innerFsBox = E('div', {
+                    'class': 'partition-inner-segment ' + fsColorClass,
+                    'style': `
+                        position: absolute;
+                        top: 3px;
+                        left: 3px;
+                        right: 3px;
+                        bottom: 3px;
+                        display: flex;
+                        flex-direction: column;
+                        align-items: center;
+                        justify-content: center;
+                        border-radius: 2px;
+                        z-index: 1;
+                        font-weight: bold;
+                        color: #fff;
+                        text-shadow: 0 1px 3px rgba(0,0,0,0.6);
+                    `
+                });
+
+                innerFsBox.appendChild(E('div', {
+                    'class': 'partition-label',
+                    'style': 'font-size: 13px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 90%;'
+                }, partitionLabel));
+                innerFsBox.appendChild(E('div', {
+                    'style': 'font-size: 9px; margin-top: 2px; text-transform: uppercase;'
+                }, actualFsType));
+                innerFsBox.appendChild(E('div', {
+                    'class': 'partition-size',
+                    'style': 'font-size: 11px; margin-top: 2px; opacity: 0.9;'
+                }, this.formatSize(part.size)));
+
+                segment.appendChild(innerFsBox);
+            } else {
+                segment.appendChild(E('div', {'class': 'partition-label'}, partitionLabel));
+                segment.appendChild(E('div', {'class': 'partition-size'}, this.formatSize(part.size)));
+            }
+
+            barContainer.appendChild(segment);
+            
+            if (isUnallocated) {
+                unallocCounter++;
+            }
+        }
+
+        let typeLabels = {
+            'primary': _('Primary'),
+            'extended': _('Extended'),
+            'logical': _('Logical'),
+            'ext4': 'Ext4',
+            'ext3': 'Ext3',
+            'ext2': 'Ext2',
+            'f2fs': 'F2FS',
+            'ntfs': 'NTFS',
+            'vfat': 'FAT32',
+            'exfat': 'exFAT',
+            'swap': _('Linux Swap'),
+            'unallocated': _('Unallocated'),
+            'free': _('Unallocated'),
+            'space': _('Unallocated')
+        };
+
+        let usedTypesArr = Array.from(usedTypes);
+        if (usedTypesArr.length === 0) usedTypesArr = ['unallocated'];
+
+        let legendRow = [];
+        usedTypesArr.forEach(type => {
+            let label = typeLabels[type] || type;
+            let tdLabel = E('td', {
+                'class': 'td top',
+                'style': `
+                    padding:4px 8px;
+                    text-align:center;
+                    vertical-align:middle;
+                    white-space:nowrap;
+                `
+            }, [
+                E('strong', {
+                    'style': `
+                        display:inline-block;
+                        position:relative;
+                        padding-bottom:2px;
+                        font-weight:600;
+                        font-size:12px;
+                        line-height:1.2;
+                    `
+                }, [
+                    E('span', {
+                        'style': `
+                            position:relative;
+                            z-index:2;
+                        `
+                    }, [label]),
+                    E('span', {
+                        'style': `
+                            position:absolute;
+                            left:0;
+                            right:0;
+                            margin:auto;
+                            bottom:0;
+                            width:calc(100%);
+                            height:2px;
+                            max-width:90%;
+                            background-color:${this.getPartitionColor(type)};
+                            border-radius:1px;
+                        `
+                    })
+                ])
+            ]);
+            legendRow.push(tdLabel);
+        });
+
+        let legendTable = E('table', {
+            'class': 'table',
+            'style': `
+                width:auto;
+                margin:0 auto;
+                margin-top:12px;
+                border-collapse:collapse;
+                table-layout:auto;
+            `
+        }, [E('tr', {'class': 'tr'}, legendRow)]);
+
+        let legend = E('div', {
+            'style': `
+                margin-top:15px;
+                text-align:center;
+                font-size:12px;
+                color:var(--text-color-secondary);
+            `
+        }, [legendTable]);
+
+        return E('div', {}, [barContainer, legend]);
+    },
+
+    renderPartitionTable: function(diskInfo) {
+        let parsed = diskInfo.parted ? this.parsePartedOutput(diskInfo.parted) : {partitions: []};
+
+        let partitionTableTitles = [
+            _('Partition'),
+            _('Type / Filesystem'),
+            _('Mount Point'),
+            _('Label'),
+            _('Size'),
+            _('Used'),
+            _('Unused'),
+            _('Flags')
+        ];
+
+        let partitionTableId = 'partition-table-' + diskInfo.device;
+        let equalWidth = (100 / partitionTableTitles.length).toFixed(2) + '%';
+
+        let headerRowChildren = partitionTableTitles.map((t, idx) => {
+            if (idx === 0) {
+                return E('th', {
+                    'class': 'th left',
+                    'style': 'width: 180px; min-width: 180px; text-align: left; cursor: default;',
+                    'click': function(ev) {
+                        ev.stopPropagation();
+                        ev.preventDefault();
+                    }
+                }, [
+                    E('span', {
+                        'style': 'display: inline-block;',
+                        'click': function(ev) {
+                            ev.stopPropagation();
+                        }
+                    }, [
+                        E('input', {
+                            'type': 'checkbox',
+                            'id': 'wipeall-checkbox',
+                            'title': _('Select all partitions for wiping'),
+                            'style': 'margin-right: 8px; vertical-align: middle; cursor: pointer;',
+                            'change': ui.createHandlerFn(this, function(ev) {
+                                this.wipeAllEnabled = ev.target.checked;
+                                
+                                let partCheckboxes = document.querySelectorAll('.partition-select-checkbox');
+                                let unallocCheckboxes = document.querySelectorAll('input[name="unallocated_select"]');
+                                
+                                if (this.wipeAllEnabled) {
+                                    partCheckboxes.forEach(cb => {
+                                        if (!cb.disabled) {
+                                            cb.checked = true;
+                                            cb.disabled = true;
+                                        }
+                                    });
+                                    unallocCheckboxes.forEach(cb => {
+                                        cb.checked = true;
+                                        cb.disabled = true;
+                                    });
+                                } else {
+                                    partCheckboxes.forEach(cb => {
+                                        let isCriticalMount = cb.hasAttribute('data-critical-mount');
+                                        cb.checked = false;
+                                        cb.disabled = isCriticalMount;
+                                    });
+                                    unallocCheckboxes.forEach(cb => {
+                                        cb.checked = false;
+                                        cb.disabled = false;
+                                    });
+                                    this.selectedPartition = null;
+                                    this.selectedUnallocated = null;
+                                }
+                                
+                                this.updateActionButtons();
+                            }),
+                            'click': function(ev) {
+                                ev.stopPropagation();
+                            }
+                        })
+                    ]),
+                    E('span', {
+                        'style': 'pointer-events: none; user-select: none;',
+                        'click': function(ev) {
+                            ev.stopPropagation();
+                            ev.preventDefault();
+                        }
+                    }, t)
+                ]);
+            } else {
+                return E('th', {
+                    'class': 'th left',
+                    'style': 'width:' + equalWidth + '; min-width: 90px; text-align: left; cursor: default; pointer-events: none;'
+                }, t);
+            }
+        });
+
+        let table = E('table', {
+            'class': 'table',
+            'id': partitionTableId,
+            'style': 'border:1px solid var(--border-color-medium)!important; table-layout:fixed; border-collapse:collapse; width:100%; font-size:12px;'
+        }, E('tr', {'class': 'tr table-titles'}, headerRowChildren));
+
+        if (!diskInfo.partitions || diskInfo.partitions.length === 0) {
+            let totalDiskSize = diskInfo.lsblk ? diskInfo.lsblk.size : 0;
+            let hasPartitionTable = diskInfo.hasPartitionTable;
+            
+            let unallocCheckbox = E('input', {
+                'type': 'checkbox',
+                'class': 'unallocated-select-checkbox',
+                'name': 'unallocated_select',
+                'value': 'unallocated-0',
+                'aria-label': _('Select unallocated space')
+            });
+
+            unallocCheckbox.addEventListener('click', (ev) => {
+                if (ev.target.checked) {
+                    this.selectedUnallocated = {
+                        size: totalDiskSize,
+                        start: 0,
+                        end: totalDiskSize,
+                        index: 0
+                    };
+                    this.selectedPartition = null;
+                } else {
+                    this.selectedUnallocated = null;
+                }
+                this.updateActionButtons();
+            }, false);
+
+            let message = hasPartitionTable ? 
+                _('No partitions - select to create') : 
+                _('No partition table - select to create');
+
+            let unallocLabel = E('label', {
+                'data-tooltip': _('Select to enable partition creation'),
+                'style': 'cursor: pointer; display: inline-flex; align-items: center; gap:6px;'
+            }, [
+                unallocCheckbox,
+                E('em', {}, message)
+            ]);
+
+            let rowsEmpty = [[
+                unallocLabel, 
+                _('Unallocated'), 
+                '-', 
+                '-', 
+                this.formatSize(totalDiskSize), 
+                '-', 
+                '-', 
+                '-'
+            ]];
+            
+            if (typeof cbi_update_table === 'function') {
+                cbi_update_table(table, rowsEmpty);
+            } else {
+                let tbody = E('tbody', {});
+                let tr = E('tr', {'class': 'tr'});
+                rowsEmpty[0].forEach(cell => {
+                    tr.appendChild(E('td', {'class': 'td left'}, cell));
+                });
+                tbody.appendChild(tr);
+                table.appendChild(tbody);
+            }
+            return table;
+        }
+
+        let rows = [];
+        let extendedPartitions = {};
+
+        let sortedPartitions = diskInfo.partitions.slice().sort((a, b) => {
+            let aNum = parseInt(a.name.match(/\d+$/)?.[0] || '0');
+            let bNum = parseInt(b.name.match(/\d+$/)?.[0] || '0');
+            return aNum - bNum;
+        });
+
+        for (let i = 0; i < sortedPartitions.length; i++) {
+            let part = sortedPartitions[i];
+            let partNumMatch = part.name.match(/\d+$/);
+            let partNum = partNumMatch ? partNumMatch[0] : '';
+            let partTypeClass = this.getPartitionType(part, diskInfo);
+
+            if (partTypeClass === 'extended') {
+                extendedPartitions[partNum] = this.getLogicalPartitionsInExtended(diskInfo, partNum);
+            }
+        }
+
+        let shortTypeLabels = {
+            'primary': _('Primary'),
+            'extended': _('Extended'),
+            'logical': _('Logical')
+        };
+
+        for (let i = 0; i < sortedPartitions.length; i++) {
+            let part = sortedPartitions[i];
+            let partNumMatch = part.name.match(/\d+$/);
+            let partNum = partNumMatch ? partNumMatch[0] : '';
+            let partedInfo = parsed.partitions.find(p => p.number === partNum);
+
+            let fsType = part.fstype || (partedInfo ? partedInfo.filesystem : '');
+            let fsClass = this.normalizeFsClass(fsType);
+
+            let partTypeClass = this.getPartitionType(part, diskInfo);
+
+            let isLogical = partTypeClass === 'logical';
+            let isExtended = partTypeClass === 'extended';
+
+            if (isLogical) continue;
+
+            let displayText = '';
+            let indicatorClass = '';
+
+            if (isExtended) {
+                displayText = shortTypeLabels['extended'];
+                indicatorClass = 'extended';
+            } else if (fsType && fsType !== '' && fsClass !== 'extended' && fsClass !== 'unallocated') {
+                displayText = this.getFriendlyFsName(fsType);
+                indicatorClass = fsClass;
+            } else {
+                displayText = shortTypeLabels[partTypeClass] || partTypeClass;
+                indicatorClass = partTypeClass;
+            }
+
+            (function(self, partRef, partedInfo, isExtended, extendedPartitions, partNum, fsClass, displayText, indicatorClass) {
+                let isCriticalMount = partRef.mountpoint && (partRef.mountpoint === '/' || partRef.mountpoint === '/boot');
+                
+                let checkbox = E('input', {
+                    'type': 'checkbox',
+                    'class': 'partition-select-checkbox',
+                    'name': 'partition_select',
+                    'value': partRef.name,
+                    'data-partition': partRef.name,
+                    'aria-label': '/dev/' + partRef.name
+                });
+
+                if (isCriticalMount) {
+                    checkbox.disabled = true;
+                    checkbox.setAttribute('data-critical-mount', 'true');
+                }
+
+                checkbox.addEventListener('click', function(ev) {
+                    if (self.wipeAllEnabled) {
+                        ev.preventDefault();
+                        return;
+                    }
+                    
+                    if (ev.target.checked) {
+                        self.selectedPartition = partRef;
+                        self.selectedUnallocated = null;
+                        let others = document.querySelectorAll('input[name="partition_select"]');
+                        others.forEach(function(o) {
+                            if (o !== ev.target) o.checked = false;
+                        });
+                        document.querySelectorAll('input[name="unallocated_select"]').forEach(function(cb) {
+                            cb.checked = false;
+                        });
+                        ev.target.checked = true;
+                    } else {
+                        self.selectedPartition = null;
+                    }
+                    self.updateActionButtons();
+                }, false);
+
+                let partitionName = isCriticalMount ? '🔒 /dev/' + partRef.name : '/dev/' + partRef.name;
+                let tooltipText = isCriticalMount ? _('System partition cannot be selected') : _('Click to select');
+                
+                let partitionCellDom = E('label', {
+                    'data-tooltip': tooltipText,
+                    'style': 'cursor: pointer; display: inline-flex; align-items: center; gap:6px;'
+                }, [
+                    checkbox,
+                    E('span', {}, partitionName)
+                ]);
+
+                let typeCell = '<span class="partition-color-indicator ' + indicatorClass + '"></span> ' + displayText;
+                let mountCell = partRef.mountpoint || '-';
+                let labelCell = partRef.label || '-';
+                let sizeCell = self.formatSize((partedInfo && partedInfo.size) ? partedInfo.size : partRef.size);
+
+                if (sizeCell) {
+                    sizeCell = sizeCell.replace(' TB', ' TiB').replace(' GB', ' GiB').replace(' MB', ' MiB').replace(' KB', ' KiB');
+                }
+
+                let usedCell = '-';
+                let unusedCell = '-';
+                if (partRef.used !== undefined && partRef.available !== undefined) {
+                    usedCell = self.formatSize(partRef.used);
+                    unusedCell = self.formatSize(partRef.available);
+                }
+
+                let flagsCell = '-';
+                if (partedInfo && partedInfo.flags && partedInfo.flags.trim()) {
+                    flagsCell = partedInfo.flags.trim();
+                } else if (partRef.flags && partRef.flags.trim()) {
+                    flagsCell = partRef.flags.trim();
+                }
+
+                rows.push([partitionCellDom, typeCell, mountCell, labelCell, sizeCell, usedCell, unusedCell, flagsCell]);
+
+                if (isExtended && extendedPartitions[partNum]) {
+                    extendedPartitions[partNum].sort((a, b) => {
+                        let aNum = parseInt(a.name.match(/\d+$/)[0]);
+                        let bNum = parseInt(b.name.match(/\d+$/)[0]);
+                        return aNum - bNum;
+                    });
+
+                    extendedPartitions[partNum].forEach(function(logPart) {
+                        let logPartNum = logPart.name.match(/\d+$/)[0];
+                        let logPartedInfo = parsed.partitions.find(p => p.number === logPartNum);
+
+                        let logFsType = logPart.fstype || '';
+                        let logFsClass = self.normalizeFsClass(logFsType);
+                        let logIndicatorClass = logFsClass && logFsClass !== 'unallocated' ? logFsClass : 'logical';
+
+                        let isCriticalMount = logPart.mountpoint && (logPart.mountpoint === '/' || logPart.mountpoint === '/boot');
+
+                        let logCheckbox = E('input', {
+                            'type': 'checkbox',
+                            'class': 'partition-select-checkbox',
+                            'name': 'partition_select',
+                            'value': logPart.name,
+                            'data-partition': logPart.name,
+                            'aria-label': '/dev/' + logPart.name
+                        });
+                        
+                        if (isCriticalMount) {
+                            logCheckbox.disabled = true;
+                        }
+
+                        logCheckbox.addEventListener('click', function(ev) {
+                            if (ev.target.checked) {
+                                self.selectedPartition = logPart;
+                                self.selectedUnallocated = null;
+                                let others = document.querySelectorAll('input[name="partition_select"]');
+                                others.forEach(function(o) {
+                                    if (o !== ev.target) o.checked = false;
+                                });
+                                document.querySelectorAll('input[name="unallocated_select"]').forEach(function(cb) {
+                                    cb.checked = false;
+                                });
+                                ev.target.checked = true;
+                            } else {
+                                self.selectedPartition = null;
+                            }
+                            self.updateActionButtons();
+                        }, false);
+
+                        let indent = '\u00A0\u00A0';
+                        let logPartitionName = isCriticalMount ? '🔒 /dev/' + logPart.name : '/dev/' + logPart.name;
+                        let logTooltipText = isCriticalMount ? _('System partition cannot be selected') : _('Click to select');
+                        
+                        let logPartitionCellDom = E('label', {
+                            'data-tooltip': logTooltipText,
+                            'style': 'cursor: pointer; display: inline-flex; align-items: center; gap:6px;'
+                        }, [
+                            logCheckbox,
+                            E('span', {}, indent + '▶ ' + logPartitionName)
+                        ]);
+
+                        let logTypeCell = '<span class="partition-color-indicator ' + logIndicatorClass + '"></span> ' + 
+                                         (logFsType ? self.getFriendlyFsName(logFsType) : shortTypeLabels['logical']);
+                        let logMountCell = logPart.mountpoint || '-';
+                        let logLabelCell = logPart.label || '-';
+                        let logSizeCell = self.formatSize(logPart.size);
+
+                        if (logSizeCell) {
+                            logSizeCell = logSizeCell.replace(' TB', ' TiB').replace(' GB', ' GiB').replace(' MB', ' MiB').replace(' KB', ' KiB');
+                        }
+
+                        let logUsedCell = '-';
+                        let logUnusedCell = '-';
+                        if (logPart.used !== undefined && logPart.available !== undefined) {
+                            logUsedCell = self.formatSize(logPart.used);
+                            logUnusedCell = self.formatSize(logPart.available);
+                        }
+
+                        let logFlagsCell = '-';
+                        if (logPartedInfo && logPartedInfo.flags && logPartedInfo.flags.trim()) {
+                            logFlagsCell = logPartedInfo.flags.trim();
+                        }
+
+                        rows.push([
+                            logPartitionCellDom,
+                            logTypeCell, 
+                            logMountCell, 
+                            logLabelCell, 
+                            logSizeCell, 
+                            logUsedCell, 
+                            logUnusedCell, 
+                            logFlagsCell
+                        ]);
+                    });
+                }
+            })(this, part, partedInfo, isExtended, extendedPartitions, partNum, fsClass, displayText, indicatorClass);
+        }
+
+        if (parsed && parsed.partitions) {
+            let unallocCounter = 0;
+            parsed.partitions.forEach((part, idx) => {
+                let ptype = (part.type || '').toLowerCase();
+                let fs = (part.filesystem || '').toLowerCase();
+                
+                // Hide < 200 MB
+                if ((ptype === 'free' || fs === 'free' || fs === '' || fs === 'unallocated') && part.size >= this.MIN_VISIBLE_SIZE) {
+                    let isInsideExtended = false;
+                    for (let extPart of parsed.partitions) {
+                        if ((extPart.type === 'extended' || extPart.filesystem === 'extended') &&
+                            part.start >= extPart.start && part.end <= extPart.end) {
+                            isInsideExtended = true;
+                            break;
+                        }
+                    }
+                    
+                    if (!isInsideExtended) {
+                        let unallocCheckbox = E('input', {
+                            'type': 'checkbox',
+                            'class': 'unallocated-select-checkbox',
+                            'name': 'unallocated_select',
+                            'value': 'unallocated-' + unallocCounter,
+                            'data-unallocated-index': unallocCounter,
+                            'aria-label': _('Select unallocated space')
+                        });
+
+                        unallocCheckbox.addEventListener('click', (ev) => {
+                            if (ev.target.checked) {
+                                this.selectedUnallocated = {
+                                    size: part.size,
+                                    start: part.start,
+                                    end: part.end,
+                                    index: unallocCounter
+                                };
+                                this.selectedPartition = null;
+                                document.querySelectorAll('input[name="partition_select"]').forEach(cb => {
+                                    cb.checked = false;
+                                });
+                                document.querySelectorAll('input[name="unallocated_select"]').forEach(cb => {
+                                    if (cb !== ev.target) cb.checked = false;
+                                });
+                            } else {
+                                this.selectedUnallocated = null;
+                            }
+                            this.updateActionButtons();
+                        }, false);
+
+                        let unallocLabel = E('label', {
+                            'data-tooltip': _('Select to enable partition creation'),
+                            'style': 'cursor: pointer; display: inline-flex; align-items: center; gap:6px;'
+                        }, [
+                            unallocCheckbox,
+                            E('span', {}, _('Unallocated space'))
+                        ]);
+
+                        rows.push([
+                            unallocLabel,
+                            '<span class="partition-color-indicator unallocated"></span> ' + _('Unallocated'),
+                            '-',
+                            '-',
+                            this.formatSize(part.size),
+                            '-',
+                            '-',
+                            '-'
+                        ]);
+
+                        unallocCounter++;
+                    }
+                }
+            });
+        }
+
+        if (typeof cbi_update_table === 'function') {
+            cbi_update_table(table, rows);
+        } else {
+            let tbody = E('tbody', {});
+            rows.forEach(r => {
+                let tr = E('tr', {});
+                r.forEach(cell => {
+                    let td = E('td', {});
+                    if (typeof cell === 'string') {
+                        td.innerHTML = cell;
+                    } else {
+                        td.appendChild(cell);
+                    }
+                    tr.appendChild(td);
+                });
+                tbody.appendChild(tr);
+            });
+            table.appendChild(tbody);
+        }
+
+        for (let i = 0; i < diskInfo.partitions.length; i++) {
+            let part = diskInfo.partitions[i];
+            if (part.mountpoint) {
+                ((p) => {
+                    this.getPartitionUsage(p.mountpoint).then(usage => {
+                        if (!usage) return;
+                        let tbl = document.getElementById(partitionTableId);
+                        if (!tbl) return;
+                        let rowsDom = tbl.querySelectorAll('tbody tr');
+                        if (!rowsDom || rowsDom.length === 0) {
+                            rowsDom = tbl.querySelectorAll('tr');
+                        }
+                        for (let r = 0; r < rowsDom.length; r++) {
+                            let firstCell = rowsDom[r].querySelector('td');
+                            if (!firstCell) continue;
+                            let cellText = firstCell.textContent.trim();
+                            cellText = cellText.replace(/[\u00A0\s▶➤↳►▸↦↳]/g, '').trim();
+                            cellText = cellText.replace(/^[^\/]*\/dev\//, '/dev/');
+                            if (cellText === '/dev/' + p.name) {
+                                let cells = rowsDom[r].querySelectorAll('td');
+                                if (cells && cells.length >= 7) {
+                                    if (usage.used) {
+                                        if (usage.used.includes('T')) {
+                                            cells[5].textContent = usage.used.replace('T', ' TiB');
+                                        } else if (usage.used.includes('G')) {
+                                            cells[5].textContent = usage.used.replace('G', ' GiB');
+                                        } else if (usage.used.includes('M')) {
+                                            cells[5].textContent = usage.used.replace('M', ' MiB');
+                                        } else if (usage.used.includes('K')) {
+                                            cells[5].textContent = usage.used.replace('K', ' KiB');
+                                        } else {
+                                            cells[5].textContent = usage.used || '-';
+                                        }
+                                    }
+                                    if (usage.available) {
+                                        if (usage.available.includes('T')) {
+                                            cells[6].textContent = usage.available.replace('T', ' TiB');
+                                        } else if (usage.available.includes('G')) {
+                                            cells[6].textContent = usage.available.replace('G', ' GiB');
+                                        } else if (usage.available.includes('M')) {
+                                            cells[6].textContent = usage.available.replace('M', ' MiB');
+                                        } else if (usage.available.includes('K')) {
+                                            cells[6].textContent = usage.available.replace('K', ' KiB');
+                                        } else {
+                                            cells[6].textContent = usage.available || '-';
+                                        }
+                                    }
+                                }
+                                break;
+                            }
+                        }
+                    }).catch(() => {});
+                })(part);
+            }
+        }
+
+        return table;
+    },
+
+    getPartitionUsage: function(mountpoint) {
+        return L.resolveDefault(fs.exec('/bin/df', ['-h', mountpoint]), null).then(res => {
+            if (res && res.code === 0) {
+                let lines = res.stdout.trim().split('\n');
+                if (lines.length >= 2) {
+                    let fields = lines[1].split(/\s+/);
+                    return {
+                        total: fields[1],
+                        used: fields[2],
+                        available: fields[3],
+                        percent: parseInt(fields[4])
+                    };
+                }
+            }
+            return null;
+        });
+    },
+
+    formatSize: function(bytes) {
+        if (!bytes || bytes === 0) return '0 B';
+        let sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
+        let i = Math.floor(Math.log(bytes) / Math.log(1024));
+        if (i < 0) i = 0;
+        if (i >= sizes.length) i = sizes.length - 1;
+        return (bytes / Math.pow(1024, i)).toFixed(2) + ' ' + sizes[i];
+    },
+
+    updateActionButtons: function() {
+        if (!this.selectedDisk) {
+            ['btn-mount', 'btn-unmount', 'btn-smart', 'btn-create', 'btn-resize', 'btn-delete', 'btn-format', 'btn-wipe'].forEach(id => {
+                let btn = document.getElementById(id);
+                if (btn) btn.setAttribute('disabled', 'disabled');
+            });
+            return;
+        }
+
+        let diskInfo = this.diskData[this.selectedDisk];
+        let hasPartition = !!this.selectedPartition;
+        let hasUnallocated = !!this.selectedUnallocated;
+
+        let isSelectedPartitionMounted = hasPartition && this.isPartitionMounted(this.selectedPartition);
+        let hasAnyMountedPartition = this.hasAnyPartitionMounted(this.selectedDisk);
+        let totalUnallocated = diskInfo ? this.getTotalUnallocatedSpace(diskInfo) : 0;
+        let hasPartitionTable = diskInfo && diskInfo.hasPartitionTable;
+
+        let mountBtn = document.getElementById('btn-mount');
+        let unmountBtn = document.getElementById('btn-unmount');
+        let smartBtn = document.getElementById('btn-smart');
+        let createBtn = document.getElementById('btn-create');
+        let resizeBtn = document.getElementById('btn-resize');
+        let deleteBtn = document.getElementById('btn-delete');
+        let formatBtn = document.getElementById('btn-format');
+        let wipeBtn = document.getElementById('btn-wipe');
+
+        let isExtendedSelected = hasPartition && 
+            this.getPartitionType(this.selectedPartition, diskInfo) === 'extended';
+
+        if (mountBtn) {
+            if (!hasPartition || isSelectedPartitionMounted || isExtendedSelected) {
+                mountBtn.setAttribute('disabled', 'disabled');
+            } else {
+                mountBtn.removeAttribute('disabled');
+            }
+        }
+
+        if (unmountBtn) {
+            if (!hasPartition || !isSelectedPartitionMounted) {
+                unmountBtn.setAttribute('disabled', 'disabled');
+            } else {
+                unmountBtn.removeAttribute('disabled');
+            }
+        }
+
+        if (smartBtn) {
+            smartBtn.removeAttribute('disabled');
+        }
+
+        if (createBtn) {            
+            if (this.wipeAllEnabled || (!hasUnallocated && !isExtendedSelected)) {
+                createBtn.setAttribute('disabled', 'disabled');
+            } else {
+                createBtn.removeAttribute('disabled');
+            }
+        }
+
+        if (resizeBtn) {
+            if (this.wipeAllEnabled || !hasPartition || !this.canResizePartition(this.selectedPartition)) {
+                resizeBtn.setAttribute('disabled', 'disabled');
+            } else {
+                resizeBtn.removeAttribute('disabled');
+            }
+        }
+
+        if (deleteBtn) {
+            if (isSelectedPartitionMounted || !hasPartition || hasUnallocated || this.wipeAllEnabled) {
+                deleteBtn.setAttribute('disabled', 'disabled');
+            } else {
+                deleteBtn.removeAttribute('disabled');
+            }
+        }
+
+        if (formatBtn) {
+            if (isSelectedPartitionMounted || !hasPartition || hasUnallocated || isExtendedSelected || this.wipeAllEnabled) {
+                formatBtn.setAttribute('disabled', 'disabled');
+            } else {
+                formatBtn.removeAttribute('disabled');
+            }
+        }
+
+        if (wipeBtn) {
+            if (!this.wipeAllEnabled || this.hasDdSupport === false || hasAnyMountedPartition) {
+                wipeBtn.setAttribute('disabled', 'disabled');
+            } else {
+                wipeBtn.removeAttribute('disabled');
+            }
+        }
+
+        let wipeCheckbox = document.getElementById('wipeall-checkbox');
+        if (wipeCheckbox) {
+            let hasPartitions = diskInfo && diskInfo.partitions && diskInfo.partitions.length > 0;
+            
+            if (hasAnyMountedPartition || !hasPartitions) {
+                wipeCheckbox.disabled = true;
+                wipeCheckbox.checked = false;
+                this.wipeAllEnabled = false;
+            } else {
+                wipeCheckbox.disabled = false;
+            }
+        }
+    },
+
+    showSmartDialog: function() {
+        if (!this.selectedDisk) {
+            ui.addNotification(null, E('p', _('Please select a disk first')), 'warning');
+            return;
+        }
+
+        let devicePath = '/dev/' + this.selectedDisk;
+        const diskType = this.getDiskType(this.selectedDisk);
+
+        ui.showModal(_('S.M.A.R.T. Status') + ' - ' + devicePath, [
+            E('div', {'class': 'cbi-section'}, [
+                E('div', {'class': 'alert alert-info'}, [
+                    E('span', {'class': 'spinning'}, _('Loading S.M.A.R.T. data...'))
+                ])
+            ])
+        ]);
+
+        Promise.all([
+            this.getDetailedSmartInfo(this.selectedDisk),
+            this.getSmartDeviceInfo(this.selectedDisk)
+        ]).then(results => {
+            const smartData = results[0];
+            const deviceInfo = results[1];
+            
+            if (!smartData) {
+                ui.showModal(_('S.M.A.R.T. Status') + ' - ' + devicePath, [
+                    E('div', {'class': 'cbi-section'}, [
+                        E('div', {'class': 'alert-message info'}, [
+                            E('strong', {}, _('Information')),
+                            E('br'),
+                            _('Unable to read S.M.A.R.T. data.')
+                        ])
+                    ]),
+                    E('div', {'class': 'right'}, [
+                        E('button', {'class': 'btn', 'click': ui.hideModal}, _('Close'))
+                    ])
+                ]);
+                return;
+            }
+
+            let content = [];
+            
+            if (deviceInfo && Object.keys(deviceInfo).length > 0) {
+                let deviceInfoRows = [];
+                
+                if (deviceInfo.serial) {
+                    deviceInfoRows.push(
+                        E('div', {'style': 'display:flex;justify-content:space-between;margin-bottom:4px;font-size:12px'}, [
+                            E('span', {}, this.translateDeviceInfoLabel('Serial Number') + ':'),
+                            E('span', {'style': 'font-weight:500'}, deviceInfo.serial)
+                        ])
+                    );
+                }
+                
+                if (deviceInfo.firmware) {
+                    deviceInfoRows.push(
+                        E('div', {'style': 'display:flex;justify-content:space-between;margin-bottom:4px;font-size:12px'}, [
+                            E('span', {}, this.translateDeviceInfoLabel('Firmware Version') + ':'),
+                            E('span', {'style': 'font-weight:500'}, deviceInfo.firmware)
+                        ])
+                    );
+                }
+                
+                if (deviceInfo.capacity) {
+                    deviceInfoRows.push(
+                        E('div', {'style': 'display:flex;justify-content:space-between;margin-bottom:4px;font-size:12px'}, [
+                            E('span', {}, this.translateDeviceInfoLabel('Capacity') + ':'),
+                            E('span', {'style': 'font-weight:500'}, deviceInfo.capacity)
+                        ])
+                    );
+                }
+                
+                if (deviceInfo.sectorSize) {
+                    deviceInfoRows.push(
+                        E('div', {'style': 'display:flex;justify-content:space-between;margin-bottom:4px;font-size:12px'}, [
+                            E('span', {}, this.translateDeviceInfoLabel('Sector Size') + ':'),
+                            E('span', {'style': 'font-weight:500'}, deviceInfo.sectorSize)
+                        ])
+                    );
+                }
+                
+                if (deviceInfo.rotationRate) {
+                    deviceInfoRows.push(
+                        E('div', {'style': 'display:flex;justify-content:space-between;margin-bottom:4px;font-size:12px'}, [
+                            E('span', {}, this.translateDeviceInfoLabel('Rotation Rate') + ':'),
+                            E('span', {'style': 'font-weight:500'}, deviceInfo.rotationRate)
+                        ])
+                    );
+                }
+                
+                if (deviceInfo.formFactor) {
+                    deviceInfoRows.push(
+                        E('div', {'style': 'display:flex;justify-content:space-between;margin-bottom:4px;font-size:12px'}, [
+                            E('span', {}, this.translateDeviceInfoLabel('Form Factor') + ':'),
+                            E('span', {'style': 'font-weight:500'}, deviceInfo.formFactor)
+                        ])
+                    );
+                }
+                
+                if (deviceInfo.sataVersion) {
+                    deviceInfoRows.push(
+                        E('div', {'style': 'display:flex;justify-content:space-between;margin-bottom:4px;font-size:12px'}, [
+                            E('span', {}, this.translateDeviceInfoLabel('SATA Version is') + ':'),
+                            E('span', {'style': 'font-weight:500'}, deviceInfo.sataVersion)
+                        ])
+                    );
+                }
+                
+                if (deviceInfo.ataVersion) {
+                    deviceInfoRows.push(
+                        E('div', {'style': 'display:flex;justify-content:space-between;margin-bottom:4px;font-size:12px'}, [
+                            E('span', {}, this.translateDeviceInfoLabel('ATA Version is') + ':'),
+                            E('span', {'style': 'font-weight:500'}, deviceInfo.ataVersion)
+                        ])
+                    );
+                }
+                
+                if (deviceInfoRows.length > 0) {
+                    let headerText = '';
+                    if (deviceInfo.modelFamily && deviceInfo.model) {
+                        headerText = deviceInfo.modelFamily + ' ' + deviceInfo.model;
+                    } else if (deviceInfo.model) {
+                        headerText = deviceInfo.model;
+                    } else if (deviceInfo.modelFamily) {
+                        headerText = deviceInfo.modelFamily;
+                    } else {
+                        headerText = this.translateDeviceInfoLabel('Device');
+                    }
+                    
+                    content.push(
+                        E('div', {'class': 'ifacebox', 'style': 'margin:.25em 0 1em 0;width:100%'}, [
+                            E('div', {'class': 'ifacebox-head', 'style': 'font-weight:bold;background:#f8f8f8;padding:8px'}, [
+                                headerText
+                            ]),
+                            E('div', {'class': 'ifacebox-body', 'style': 'padding:8px'}, deviceInfoRows)
+                        ])
+                    );
+                }
+            }
+
+            // NVMe
+            if (smartData.type === 'nvme') {
+                let criticalWarning = smartData.raw.critical_warning !== undefined ? 
+                    smartData.raw.critical_warning : 0;
+                let statusLabel = criticalWarning === 0 ?
+                    E('span', {'class': 'disks-info-label-status disks-info-ok-label'}, _('OK')) :
+                    E('span', {'class': 'disks-info-label-status disks-info-err-label'}, _('WARNING'));
+
+                content.push(E('h5', {
+                    'style': 'width:100% !important; text-align:center !important; margin: 1em 0;'
+                }, [
+                    _('NVMe S.M.A.R.T. Health Status') + ': ',
+                    statusLabel
+                ]));
+
+                let percentUsed = smartData.raw.percent_used !== undefined ? 
+                    smartData.raw.percent_used : 0;
+                let powerOnHours = smartData.raw.power_on_hours !== undefined ? 
+                    smartData.raw.power_on_hours : 0;
+                let powerOnTimeFormatted = this.formatPowerOnTime(powerOnHours);
+                
+                // Temp
+                let temperature = '-';
+                if (smartData.raw.temperature !== undefined && smartData.raw.temperature !== null) {
+                    let tempC = smartData.raw.temperature - 273;
+                    if (tempC >= -50 && tempC <= 150) {
+                        temperature = tempC + ' °C';
+                    }
+                }
+                
+                let statusTableRows = [
+                    E('tr', {'class': 'tr'}, [
+                        E('td', {'class': 'td left', 'style': 'width: 33%;'}, [_('Power On Time')]),
+                        E('td', {'class': 'td'}, [
+                            E('div', {'style': 'text-align: left;'}, [
+                                powerOnTimeFormatted,
+                                E('span', {'style': 'color: var(--text-color-secondary); margin-left: 8px;'}, 
+                                    '(' + powerOnHours + ' ' + _('hours') + ')')
+                            ])
+                        ])
+                    ]),
+                    E('tr', {'class': 'tr'}, [
+                        E('td', {'class': 'td left', 'style': 'width: 33%;'}, [_('Temperature')]),
+                        E('td', {'class': 'td'}, [
+                            E('div', {'style': 'text-align: left;'}, [
+                                temperature
+                            ])
+                        ])
+                    ])
+                ];
+                
+                if (percentUsed !== null && percentUsed !== undefined) {
+                    statusTableRows.push(
+                        E('tr', {'class': 'tr'}, [
+                            E('td', {'class': 'td left', 'style': 'width: 33%;'}, [_('Disk Usage')]),
+                            E('td', {'class': 'td'}, [
+                                E('div', {'class': 'right'}, [
+                                    E('div', {
+                                        'class': 'cbi-progressbar',
+                                        'title': percentUsed + '% ' + ' / ' + (100 - percentUsed) + '% '
+                                    }, E('div', {
+                                        'style': 'width:' + percentUsed + '%; background-color: ' +
+                                            (percentUsed >= 95 ? 'var(--app-mini-diskmanager-danger)' :
+                                             percentUsed >= 80 ? 'var(--app-mini-diskmanager-warning)' :
+                                             'var(--app-mini-diskmanager-primary)') + ';'
+                                    })),
+                                ])
+                            ])
+                        ])
+                    );
+                }
+                
+                content.push(E('table', {'class': 'table', 'style': 'margin: 1em 0;'}, statusTableRows));
+
+                // NVMe
+                let nvmeTable = E('table', {
+                    'class': 'table',
+                    'style': 'width: 100%; font-size: 12px;'
+                }, [
+                    E('tr', {'class': 'tr table-titles'}, [
+                        E('th', {'class': 'th left', 'style': 'width: 60%;'}, _('Attribute')),
+                        E('th', {'class': 'th left', 'style': 'width: 40%;'}, _('Value'))
+                    ])
+                ]);
+
+                for (let attr of smartData.attributes) {
+                    if (!attr || !attr.name) continue;
+                    
+                    let lineStyle = 'tr';
+                    if (attr.status === 'ERROR') {
+                        lineStyle = 'tr disks-info-err';
+                    } else if (attr.status === 'WARNING') {
+                        lineStyle = 'tr disks-info-warn';
+                    }
+
+                    nvmeTable.appendChild(
+                        E('tr', {'class': lineStyle}, [
+                            E('td', {'class': 'td left'}, attr.name || _('Unknown')),
+                            E('td', {'class': 'td left'}, 
+                                attr.value !== undefined ? String(attr.value) : '-')
+                        ])
+                    );
+                }
+
+                content.push(
+                    E('div', {'style': 'max-height: 45vh !important; overflow-y: auto !important;'}, [
+                        nvmeTable
+                    ])
+                );
+
+            } else {
+                // SATA/ATA
+                if (!smartData.attributes || smartData.attributes.length === 0) {
+                    ui.showModal(_('S.M.A.R.T. Status') + ' - ' + devicePath, [
+                        E('div', {'class': 'cbi-section'}, [
+                            E('div', {'class': 'alert-message info'}, [
+                                E('strong', {}, _('Information')),
+                                E('br'),
+                                _('No S.M.A.R.T. attributes found.')
+                            ])
+                        ]),
+                        E('div', {'class': 'right'}, [
+                            E('button', {'class': 'btn', 'click': ui.hideModal}, _('Close'))
+                        ])
+                    ]);
+                    return;
+                }
+
+                let smartCriticalAttrs = [5, 11, 183, 184, 187, 196, 197, 198, 200, 202, 220];
+                let smartTempAttrs = [190, 194];
+                let diskTempWarning = 60;
+
+                if (smartData.raw.temperature && smartData.raw.temperature.op_limit_max) {
+                    diskTempWarning = smartData.raw.temperature.op_limit_max;
+                }
+
+                // Status SMART
+                let smartStatusPassed = true;
+                if (smartData.raw.smart_status && smartData.raw.smart_status.passed !== undefined) {
+                    smartStatusPassed = smartData.raw.smart_status.passed;
+                }
+                
+                let smartStatusLabel = smartStatusPassed ?
+                    E('span', {'class': 'disks-info-label-status disks-info-ok-label'}, _('PASSED')) :
+                    E('span', {'class': 'disks-info-label-status disks-info-err-label'}, _('FAILED'));
+
+                content.push(E('h5', {
+                    'style': 'width:100% !important; text-align:center !important; margin: 1em 0;'
+                }, [
+                    _('S.M.A.R.T. Health Status')+': ',
+                    smartStatusLabel
+                ]));
+
+                let powerOnHours = 0;
+                let temperature = '-';
+                let wearPercent = null;
+                
+                if (smartData.raw.temperature && smartData.raw.temperature.current !== undefined) {
+                    let tempValue = smartData.raw.temperature.current;
+                    if (tempValue > 0 && tempValue < 200) {
+                        temperature = tempValue + ' °C';
+                    }
+                }
+                
+                for (let attr of smartData.attributes) {
+                    if (!attr || attr.id === undefined) continue;
+                    
+                    if (attr.id === 9 && attr.raw !== undefined && attr.raw !== '-') {
+                        if (typeof attr.raw === 'number') {
+                            powerOnHours = attr.raw;
+                        } else if (typeof attr.raw === 'string') {
+                            const parsed = parseInt(attr.raw);
+                            if (!isNaN(parsed)) powerOnHours = parsed;
+                        }
+                    }
+                    
+                    if (temperature === '-' && attr.id === 194 && attr.raw !== undefined && attr.raw !== '-') {
+                        let tempValue = 0;
+                        if (typeof attr.raw === 'number') {
+                            tempValue = attr.raw;
+                        } else if (typeof attr.raw === 'string') {
+                            const parsed = parseInt(attr.raw.split(' ')[0]);
+                            if (!isNaN(parsed)) tempValue = parsed;
+                        }
+                        if (tempValue > 0 && tempValue < 200) {
+                            temperature = tempValue + ' °C';
+                        }
+                    }
+                    
+                    if ((attr.id === 177 || attr.id === 233 || 
+                        (attr.name && (attr.name.includes('Wear') || attr.name.includes('Wearout')))) &&
+                        attr.value !== undefined && attr.value !== '-') {
+                        const attrVal = typeof attr.value === 'number' ? attr.value : parseInt(attr.value);
+                        if (!isNaN(attrVal)) {
+                            wearPercent = 100 - attrVal;
+                            if (wearPercent < 0) wearPercent = 0;
+                            if (wearPercent > 100) wearPercent = 100;
+                        }
+                    }
+                }
+                
+                let powerOnTimeFormatted = this.formatPowerOnTime(powerOnHours);
+                
+                let statusTableRows = [
+                    E('tr', {'class': 'tr'}, [
+                        E('td', {'class': 'td left', 'style': 'width: 33%;'}, [_('Power On Time')]),
+                        E('td', {'class': 'td'}, [
+                            E('div', {'style': 'text-align: left;'}, [
+                                powerOnTimeFormatted,
+                                E('span', {'style': 'color: var(--text-color-secondary); margin-left: 8px; font-size: 90%;'}, 
+                                    '(' + powerOnHours + ' ' + _('hours') + ')')
+                            ])
+                        ])
+                    ]),
+                    E('tr', {'class': 'tr'}, [
+                        E('td', {'class': 'td left', 'style': 'width: 33%;'}, [_('Temperature')]),
+                        E('td', {'class': 'td'}, [
+                            E('div', {'style': 'text-align: left;'}, [
+                                temperature
+                            ])
+                        ])
+                    ])
+                ];
+                
+                if (wearPercent !== null) {
+                    statusTableRows.push(
+                        E('tr', {'class': 'tr'}, [
+                            E('td', {'class': 'td left', 'style': 'width: 33%;'}, [_('Disk Wear Level')]),
+                            E('td', {'class': 'td'}, [
+                                E('div', {'class': 'right'}, [
+                                    E('div', {
+                                        'class': 'cbi-progressbar',
+                                        'title': wearPercent.toFixed(1) + '% ' + _('worn') + ' / ' + (100 - wearPercent).toFixed(1) + '% ' + _('remaining')
+                                    }, E('div', {
+                                        'style': 'width:' + wearPercent + '%; background-color: ' +
+                                            (wearPercent >= 95 ? 'var(--app-mini-diskmanager-danger)' :
+                                             wearPercent >= 80 ? 'var(--app-mini-diskmanager-warning)' :
+                                             'var(--app-mini-diskmanager-primary)') + ';'
+                                    })),
+                                    E('div', {'class': 'right'}, [
+                                        E('div', {'style': 'text-align:center; font-size:90%;'}, [
+                                            wearPercent.toFixed(1) + '% ' + _('worn') + ' / ' + (100 - wearPercent).toFixed(1) + '% ' + _('remaining')
+                                        ])
+                                    ])
+                                ])
+                            ])
+                        ])
+                    );
+                }
+                
+                content.push(E('table', {'class': 'table', 'style': 'margin: 1em 0;'}, statusTableRows));
+
+                // SATA
+                let smartAttrsTable = E('table', {
+                    'class': 'table',
+                    'style': 'width: 100%; font-size: 12px;'
+                }, [
+                    E('tr', {'class': 'tr table-titles'}, [
+                        E('th', {'class': 'th right'}, _('Id')),
+                        E('th', {'class': 'th left'}, _('Attribute')),
+                        E('th', {'class': 'th left'}, _('Value')),
+                        E('th', {'class': 'th left'}, _('Worst')),
+                        E('th', {'class': 'th left'}, _('Thresh')),
+                        E('th', {'class': 'th left'}, _('Raw'))
+                    ])
+                ]);
+
+                for (let attr of smartData.attributes) {
+                    if (!attr || attr.id === undefined) continue;
+                    
+                    let lineStyle = 'tr';
+                    
+                    if (attr.value !== undefined && attr.value !== '-' && 
+                        attr.thresh !== undefined && attr.thresh !== '-') {
+                        const attrValue = typeof attr.value === 'number' ? attr.value : parseInt(attr.value);
+                        const attrThresh = typeof attr.thresh === 'number' ? attr.thresh : parseInt(attr.thresh);
+                        if (!isNaN(attrValue) && !isNaN(attrThresh) && attrValue <= attrThresh) {
+                            lineStyle = 'tr disks-info-err';
+                        }
+                    }
+                    
+                    if (lineStyle === 'tr' && smartCriticalAttrs.includes(attr.id)) {
+                        let rawVal = 0;
+                        if (typeof attr.raw === 'number') {
+                            rawVal = attr.raw;
+                        } else if (typeof attr.raw === 'string') {
+                            rawVal = parseInt(attr.raw.split(' ')[0]) || 0;
+                        }
+                        
+                        if (rawVal > 0) {
+                            lineStyle = 'tr disks-info-warn';
+                        }
+                    }
+                    
+                    if (lineStyle === 'tr' && smartTempAttrs.includes(attr.id)) {
+                        let tempValue = null;
+                        if (typeof attr.raw === 'number') {
+                            tempValue = attr.raw;
+                        } else if (typeof attr.raw === 'string') {
+                            const parsed = parseInt(attr.raw.split(' ')[0]);
+                            if (!isNaN(parsed)) tempValue = parsed;
+                        }
+                        if (tempValue !== null && tempValue >= diskTempWarning) {
+                            lineStyle = 'tr disks-info-warn';
+                        }
+                    }
+
+                    smartAttrsTable.appendChild(
+                        E('tr', {'class': lineStyle}, [
+                            E('td', {'class': 'td right'}, String(attr.id || '-')),
+                            E('td', {'class': 'td left'}, 
+                                attr.name ? this.translateSmartAttribute(attr.name) : _('Unknown')),
+                            E('td', {'class': 'td left'}, 
+                                attr.value !== '-' && !isNaN(attr.value) ? 
+                                    String(parseInt(attr.value)) : String(attr.value)),
+                            E('td', {'class': 'td left'}, 
+                                attr.worst !== '-' && !isNaN(attr.worst) ? 
+                                    String(parseInt(attr.worst)) : String(attr.worst)),
+                            E('td', {'class': 'td left'}, 
+                                attr.thresh !== '-' && !isNaN(attr.thresh) ? 
+                                    String(parseInt(attr.thresh)) : String(attr.thresh)),
+                            E('td', {'class': 'td left'}, 
+                                String(attr.raw !== undefined ? attr.raw : '-'))
+                        ])
+                    );
+                }
+
+                content.push(
+                    E('div', {'style': 'max-height: 45vh !important; overflow-y: auto !important;'}, [
+                        smartAttrsTable
+                    ])
+                );
+            }
+
+            ui.showModal(_('S.M.A.R.T. Status') + ' - ' + devicePath, [
+                E('div', {'class': 'cbi-section'}, content),
+                E('div', {'class': 'right'}, [
+                    E('button', {'class': 'btn', 'click': ui.hideModal}, _('Close'))
+                ])
+            ]);
+
+        }).catch(err => {
+            console.error('S.M.A.R.T. dialog error:', err);
+            ui.showModal(_('S.M.A.R.T. Status') + ' - ' + devicePath, [
+                E('div', {'class': 'cbi-section'}, [
+                    E('div', {'class': 'alert-message warning'}, [
+                        E('strong', {}, _('Warning')),
+                        E('br'),
+                        _('Error reading S.M.A.R.T. data.')
+                    ])
+                ]),
+                E('div', {'class': 'right'}, [
+                    E('button', {'class': 'btn', 'click': ui.hideModal}, _('Close'))
+                ])
+            ]);
+        });
+    },
+
+    showCreatePartitionDialog: function() {
+        if (!this.selectedDisk) {
+            ui.addNotification(null, E('p', _('Please select a disk first')), 'warning');
+            return;
+        }
+
+        this.getDiskInfo(this.selectedDisk).then(async (diskInfo) => {
+            this.diskData[this.selectedDisk] = diskInfo;
+
+            let totalUnallocated = this.getTotalUnallocatedSpace(diskInfo);
+            let isExtendedSelected = this.selectedPartition && 
+                this.getPartitionType(this.selectedPartition, diskInfo) === 'extended';
+
+            if (totalUnallocated === 0 && diskInfo.hasPartitionTable && !isExtendedSelected) {
+                ui.addNotification(null, E('p', _('No unallocated space available on this disk')), 'warning');
+                return;
+            }
+
+            let existingLayout = null;
+            if (diskInfo.fdisk && diskInfo.fdisk.indexOf('GPT') !== -1) {
+                existingLayout = 'gpt';
+            } else if (diskInfo.fdisk && diskInfo.fdisk.indexOf('DOS') !== -1) {
+                existingLayout = 'mbr';
+            }
+
+            let freeSpace = totalUnallocated || (diskInfo.lsblk ? diskInfo.lsblk.size : 0);
+            if (isExtendedSelected) {
+                if (!diskInfo.parted) {
+                    ui.addNotification(null, E('p', _('Cannot read partition information')), 'error');
+                    return;
+                }
+                
+                let parsed = this.parsePartedOutput(diskInfo.parted);
+                let extPartNum = this.selectedPartition.name.match(/\d+$/);
+                if (!extPartNum) {
+                    ui.addNotification(null, E('p', _('Invalid extended partition')), 'error');
+                    return;
+                }
+                
+                let extendedPartInfo = parsed.partitions.find(p => 
+                    p.number === extPartNum[0] && 
+                    (p.type === 'extended' || p.filesystem === 'extended')
+                );
+                
+                if (!extendedPartInfo || !extendedPartInfo.size) {
+                    ui.addNotification(null, E('p', _('Extended partition not found or has invalid size')), 'error');
+                    return;
+                }
+                
+                let logicalParts = this.getLogicalPartitionsInExtended(diskInfo, extPartNum[0]);
+                let usedLogicalSize = 0;
+                logicalParts.forEach(lp => {
+                    usedLogicalSize += (lp.size || 0);
+                });
+                
+                freeSpace = extendedPartInfo.size - usedLogicalSize;
+                
+                const MIN_PARTITION_SIZE = 10 * 1024 * 1024; // 10MB minimum
+                if (freeSpace < MIN_PARTITION_SIZE) {
+                    let freeSpaceMB = (freeSpace / (1024 * 1024)).toFixed(2);
+                    let extSizeMB = (extendedPartInfo.size / (1024 * 1024)).toFixed(2);
+                    let usedMB = (usedLogicalSize / (1024 * 1024)).toFixed(2);
+                    ui.showModal(_('Cannot Create Partition'), [
+                        E('div', {'class': 'cbi-section'}, [
+                            E('div', {'class': 'alert-message warning'}, [
+                                E('strong', {}, _('Insufficient Space')),
+                                E('br'),
+                                E('br'),
+                                _('Not enough free space in extended partition /dev/%s').format(this.selectedPartition.name),
+                                E('br'),
+                                E('br'),
+                                _('Extended partition size: %s MB').format(extSizeMB),
+                                E('br'),
+                                _('Used by logical partitions: %s MB').format(usedMB),
+                                E('br'),
+                                _('Available for new logical: %s MB').format(freeSpaceMB),
+                                E('br'),
+                                E('br'),
+                                _('Required minimum: 10 MB')
+                            ])
+                        ]),
+                        E('div', {'class': 'right'}, [
+                            E('button', {'class': 'btn', 'click': ui.hideModal}, _('Close'))
+                        ])
+                    ]);
+                    return;
+                }
+            }
+            
+            let freeSpaceMB = Math.floor(freeSpace / (1024 * 1024));
+            let freeSpaceGB = (freeSpaceMB / 1024).toFixed(2);
+            let freeSpaceTB = (freeSpaceGB / 1024).toFixed(2);
+
+            let convertToMB = function(value, unit) {
+                let val = parseFloat(value);
+                if (isNaN(val)) return 0;
+                switch(unit) {
+                    case 'MB': return val;
+                    case 'GB': return val * 1024;
+                    case 'TB': return val * 1024 * 1024;
+                    default: return 0;
+                }
+            };
+
+            let convertFromMB = function(mb, unit) {
+                if (typeof mb !== 'number') return '0';
+                switch(unit) {
+                    case 'MB': return mb;
+                    case 'GB': return (mb / 1024);
+                    case 'TB': return (mb / 1024 / 1024);
+                    default: return mb;
+                }
+            };
+
+            let updateMaxSize = function() {
+                let unitEl = document.getElementById('size_unit');
+                let sizeInput = document.getElementById('part_size');
+                if (!unitEl || !sizeInput) return;
+
+                let unit = unitEl.value;
+                let maxInUnit = convertFromMB(freeSpaceMB, unit);
+                sizeInput.setAttribute('data-max', maxInUnit);
+
+                let currentVal = parseFloat(sizeInput.value);
+                if (!isNaN(currentVal) && currentVal > maxInUnit) {
+                    sizeInput.value = Number(maxInUnit).toFixed(2);
+                }
+            };
+
+            let updatePartitionTypes = function() {
+                let layoutSelect = document.getElementById('part_layout');
+                let partTypeSelect = document.getElementById('part_part_type');
+                let fsTypeSelect = document.getElementById('fs_type');
+                let labelInput = document.getElementById('part_label');
+                let layoutInfo = document.getElementById('layout_info');
+
+                if (!layoutSelect || !partTypeSelect || !fsTypeSelect || !labelInput || !layoutInfo) {
+                    return;
+                }
+
+                partTypeSelect.innerHTML = '';
+                layoutInfo.innerHTML = '';
+
+                let isExtendedSelected = this.selectedPartition && 
+                    this.getPartitionType(this.selectedPartition, diskInfo) === 'extended';
+                let hasExtendedPartition = false;
+                
+                if (diskInfo.partitions) {
+                    for (let part of diskInfo.partitions) {
+                        if (this.getPartitionType(part, diskInfo) === 'extended') {
+                            hasExtendedPartition = true;
+                            break;
+                        }
+                    }
+                }
+
+                if (isExtendedSelected) {
+                    partTypeSelect.appendChild(E('option', {'value': 'logical'}, _('Logical')));
+                    partTypeSelect.disabled = true;
+                    layoutInfo.innerHTML = '<div style="margin-top:8px;padding:8px;background:var(--background-color-medium);border:1px solid var(--border-color-medium);border-radius:4px;font-size:12px;">' + 
+                        _('Creating partition inside extended partition. Only logical partitions can be created here.') + '</div>';
+                } else if (!diskInfo.hasPartitionTable) {
+                    partTypeSelect.appendChild(E('option', {'value': 'primary'}, _('Primary')));
+                    partTypeSelect.disabled = true;
+                    layoutInfo.innerHTML = '<div style="margin-top:8px;padding:8px;background:var(--background-color-medium);border:1px solid var(--border-color-medium);border-radius:4px;font-size:12px;">' + 
+                        _('No partition table detected. A primary partition will be created and a partition table will be initialized.') + '</div>';
+                } else {
+                    partTypeSelect.appendChild(E('option', {'value': 'primary'}, _('Primary')));
+                    if (!hasExtendedPartition) {
+                        partTypeSelect.appendChild(E('option', {'value': 'extended'}, _('Extended')));
+                    }
+                    partTypeSelect.disabled = false;
+                    
+                    if (hasExtendedPartition) {
+                        layoutInfo.innerHTML = '<div style="margin-top:8px;padding:8px;background:var(--background-color-medium);border:1px solid var(--border-color-medium);border-radius:4px;font-size:12px;">' + 
+                            _('Extended partition already exists. You can create primary partitions or select the extended partition to create logical partitions inside.') + '</div>';
+                    }
+                }
+
+                fsTypeSelect.disabled = false;
+                labelInput.disabled = false;
+
+                if (partTypeSelect.options.length > 0) {
+                    let changeEvent = new Event('change');
+                    partTypeSelect.dispatchEvent(changeEvent);
+                }
+            }.bind(this);
+
+            let refreshPartitionData = function() {
+                let refreshBtn = document.getElementById('refresh-partition-btn');
+                if (refreshBtn) {
+                    refreshBtn.disabled = true;
+                    refreshBtn.innerHTML = '<span class="spinning"></span> ' + _('Refreshing...');
+                }
+
+                this.getDiskInfo(this.selectedDisk).then(freshDiskInfo => {
+                    this.diskData[this.selectedDisk] = freshDiskInfo;
+
+                    updatePartitionTypes();
+
+                    let newTotalUnallocated = this.getTotalUnallocatedSpace(freshDiskInfo);
+                    let newFreeSpace = newTotalUnallocated;
+                    
+                    if (isExtendedSelected && this.selectedPartition) {
+                        let extPartNum = this.selectedPartition.name.match(/\d+$/);
+                        if (extPartNum) {
+                            let freshExtPart = freshDiskInfo.partitions.find(p => {
+                                let num = p.name.match(/\d+$/);
+                                return num && num[0] === extPartNum[0];
+                            });
+                            if (freshExtPart) {
+                                let logicalParts = this.getLogicalPartitionsInExtended(freshDiskInfo, extPartNum[0]);
+                                let usedLogicalSize = 0;
+                                logicalParts.forEach(lp => {
+                                    usedLogicalSize += (lp.size || 0);
+                                });
+                                newFreeSpace = freshExtPart.size - usedLogicalSize;
+                            }
+                        }
+                    }
+                    
+                    let newFreeSpaceMB = Math.floor(newFreeSpace / (1024 * 1024));
+                    let newFreeSpaceGB = (newFreeSpaceMB / 1024).toFixed(2);
+                    let newFreeSpaceTB = (newFreeSpaceGB / 1024).toFixed(2);
+
+                    freeSpaceMB = newFreeSpaceMB;
+                    freeSpaceGB = newFreeSpaceGB;
+                    freeSpaceTB = newFreeSpaceTB;
+
+                    let freeSpaceInfo = document.querySelector('#available-space-info');
+                    if (freeSpaceInfo) {
+                        freeSpaceInfo.textContent = _('Available: %s MB / %s GB / %s TB').format(
+                            newFreeSpaceMB, 
+                            newFreeSpaceGB, 
+                            newFreeSpaceTB
+                        );
+                    }
+
+                    updateMaxSize();
+
+                    if (refreshBtn) {
+                        refreshBtn.disabled = false;
+                        refreshBtn.innerHTML = _('Refresh partition data');
+                    }
+
+                    this.popTimeout(null, E('p', _('Partition data refreshed')), 3000, 'info');
+                }).catch(err => {
+                    ui.addNotification(null, E('p', _('Failed to refresh partition data: ') + err.message), 'error');
+                    if (refreshBtn) {
+                        refreshBtn.disabled = false;
+                        refreshBtn.innerHTML = _('Refresh partition data');
+                    }
+                });
+            }.bind(this);
+
+            const supported = await this.detectSupportedFilesystems();
+            const fsOptions = ['ext4', 'ext3', 'ext2', 'f2fs', 'ntfs', 'vfat', 'exfat', 'swap'];
+
+            ui.showModal(_('Create partition'), [
+                E('div', {'class': 'cbi-section'}, [
+                    E('div', {'class': 'cbi-section-descr'}, _('Create a new partition on the selected disk')),
+                    E('div', {'class': 'cbi-section'}, [
+                        E('div', {'class': 'cbi-value'}, [
+                            E('label', {'class': 'cbi-value-title'}, _('Partition layout')),
+                            E('div', {'class': 'cbi-value-field'}, [
+                                E('select', {
+                                    'class': 'cbi-input-select', 
+                                    'id': 'part_layout',
+                                    'change': updatePartitionTypes
+                                }, existingLayout ? [
+                                    E('option', {'value': existingLayout, 'selected': 'selected'}, 
+                                        existingLayout === 'gpt' ? _('GPT (GUID Partition Table)') : _('MBR (Master Boot Record)'))
+                                ] : [
+                                    E('option', {'value': 'mbr'}, _('MBR (Master Boot Record)')),
+                                    E('option', {'value': 'gpt'}, _('GPT (GUID Partition Table)'))
+                                ]),
+                                E('div', {'id': 'layout_info'})
+                            ])
+                        ]),
+                        E('div', {'class': 'cbi-value'}, [
+                            E('label', {'class': 'cbi-value-title'}, _('Partition type')),
+                            E('div', {'class': 'cbi-value-field'}, [
+                                E('select', {
+                                    'class': 'cbi-input-select', 
+                                    'id': 'part_part_type', 
+                                    'change': function() {
+                                        let fsTypeSelect = document.getElementById('fs_type');
+                                        let labelInput = document.getElementById('part_label');
+                                        if (this.value === 'extended') {
+                                            fsTypeSelect.disabled = true;
+                                            fsTypeSelect.value = '';
+                                            labelInput.disabled = true;
+                                            labelInput.value = '';
+                                        } else {
+                                            fsTypeSelect.disabled = false;
+                                            labelInput.disabled = false;
+                                        }
+                                    }
+                                })
+                            ])
+                        ]),
+                        E('div', {'class': 'cbi-value'}, [
+                            E('label', {'class': 'cbi-value-title'}, _('File system')),
+                            E('div', {'class': 'cbi-value-field'}, [
+                                E('select', {
+                                    'class': 'cbi-input-select', 
+                                    'id': 'fs_type',
+                                    'change': function() {
+                                        let reservedSection = document.getElementById('reserved_space_section');
+                                        if (reservedSection) {
+                                            if (this.value === 'ext2' || this.value === 'ext3' || this.value === 'ext4') {
+                                                reservedSection.style.display = '';
+                                            } else {
+                                                reservedSection.style.display = 'none';
+                                            }
+                                        }
+                                    }
+                                }, [
+                                    E('option', {'value': '', 'selected': 'selected', 'disabled': true}, _('Loading...'))
+                                ])
+                            ])
+                        ]),
+                        E('div', {'class': 'cbi-value'}, [
+                            E('label', {'class': 'cbi-value-title'}, _('Volume label')),
+                            E('div', {'class': 'cbi-value-field'}, [
+                                E('input', {'class': 'cbi-input-text', 'id': 'part_label', 'type': 'text', 
+                                    'placeholder': _('Optional')})
+                            ])
+                        ]),
+                        E('div', {'class': 'cbi-value'}, [
+                            E('label', {'class': 'cbi-value-title'}, _('Partition size')),
+                            E('div', {'class': 'cbi-value-field'}, [
+                                E('div', {'class': 'size-input-group'}, [
+                                    E('input', {
+                                        'class': 'cbi-input-text', 
+                                        'id': 'part_size', 
+                                        'type': 'text',
+                                        'placeholder': _('Enter size'),
+                                        'data-max': freeSpaceGB
+                                    }),
+                                    E('select', {
+                                        'class': 'cbi-input-select',
+                                        'id': 'size_unit',
+                                        'change': updateMaxSize
+                                    }, [
+                                        E('option', {'value': 'MB'}, _('MB')),
+                                        E('option', {'value': 'GB', 'selected': 'selected'}, _('GB')),
+                                        E('option', {'value': 'TB'}, _('TB'))
+                                    ])
+                                ]),
+                                E('div', {'style': 'margin-top: 5px; font-size: 12px; color: var(--text-color-secondary)'}, [
+                                    E('div', {
+                                        'id': 'available-space-info',
+                                        'style': 'margin-top: 3px;'
+                                    }, 
+                                        _('Available: %s MB / %s GB / %s TB').format(
+                                            freeSpaceMB, 
+                                            freeSpaceGB, 
+                                            freeSpaceTB
+                                        ))
+                                ])
+                            ])
+                        ]),
+                        E('div', {'class': 'cbi-value', 'id': 'reserved_space_section'}, [
+                            E('label', {'class': 'cbi-value-title'}, _('Reserved space')),
+                            E('div', {'class': 'cbi-value-field'}, [
+                                E('div', {'class': 'size-input-group'}, [
+                                    E('input', {
+                                        'class': 'cbi-input-text',
+                                        'id': 'reserved_space_value',
+                                        'type': 'text',
+                                        'value': '5',
+                                        'placeholder': '5'
+                                    }),
+                                    E('select', {
+                                        'class': 'cbi-input-select',
+                                        'id': 'reserved_space_unit'
+                                    }, [
+                                        E('option', {'value': '%', 'selected': 'selected'}, '%'),
+                                        E('option', {'value': 'MB'}, _('MB')),
+                                        E('option', {'value': 'GB'}, _('GB')),
+                                        E('option', {'value': 'TB'}, _('TB'))
+                                    ])
+                                ]),
+                                E('div', {'style': 'margin-top: 5px; font-size: 12px; color: var(--text-color-secondary)'}, 
+                                    _('Space reserved for root (default: 5%)'))
+                            ])
+                        ])
+                    ])
+                ]),
+                E('div', { 'class': 'cbi-value' }, [
+                    E('label', { 'class': 'cbi-value-title' }, _('All available space')),
+                    E('div', { 'class': 'cbi-value-field' }, [
+                        E('button', {
+                            'id': 'use_max_size',
+                            'class': 'btn',
+                            'click': function () {
+                                let sizeInput = document.getElementById('part_size');
+                                let unitSelect = document.getElementById('size_unit');
+                                if (!sizeInput || !unitSelect) return;
+                                let unit = unitSelect.value;
+                                let maxInUnit = convertFromMB(freeSpaceMB, unit);
+                                sizeInput.value = Number(maxInUnit).toFixed(2);
+                                sizeInput.setAttribute('data-max', maxInUnit);
+                            }
+                        }, _('Fill in size'))
+                    ])
+                ]),
+                E('div', {'style': 'display: flex; justify-content: space-between; align-items: center;'}, [
+                    E('div', {}, [
+                        E('button', {'class': 'btn', 'click': ui.hideModal}, _('Cancel'))
+                    ]),
+                    E('div', {}, [
+                        E('button', {
+                            'class': 'btn cbi-button',
+                            'id': 'refresh-partition-btn',
+                            'click': refreshPartitionData
+                        }, _('Refresh partition data')),
+                        ' ',
+                        E('button', {
+                            'class': 'btn cbi-button-action',
+                            'id': 'create_partition_confirm'
+                        }, _('Create'))
+                    ])
+                ])
+            ]);
+
+            setTimeout(() => {
+                const fsSelect = document.getElementById('fs_type');
+                if (!fsSelect) return;
+
+                fsSelect.innerHTML = '';
+
+                if (supported && supported.length > 0) {
+                    const preferred = ['ext4','ext3','ext2','f2fs','vfat','ntfs','exfat','swap'];
+                    const ordered = preferred.filter(x => supported.indexOf(x) !== -1).concat(supported.filter(x => preferred.indexOf(x) === -1));
+                    ordered.forEach((fsName, idx) => {
+                        let label = this.getFriendlyFsName(fsName);
+                        let opt = E('option', {'value': fsName}, label);
+                        if (idx === 0) opt.setAttribute('selected', 'selected');
+                        fsSelect.appendChild(opt);
+                    });
+                } else {
+                    fsSelect.appendChild(E('option', {'value': '', 'disabled': true}, _('No supported filesystems detected on this system')));
+                    ui.addNotification(null, E('p', _('No filesystem packages detected — user cannot choose unsupported filesystem formats.')), 'warning');
+                }
+                
+                // Reserved space section
+                const reservedSection = document.getElementById('reserved_space_section');
+                if (reservedSection && fsSelect.value) {
+                    if (fsSelect.value === 'ext2' || fsSelect.value === 'ext3' || fsSelect.value === 'ext4') {
+                        reservedSection.style.display = '';
+                    } else {
+                        reservedSection.style.display = 'none';
+                    }
+                }
+
+                const createBtn = document.getElementById('create_partition_confirm');
+
+                if (createBtn) {
+                    createBtn.addEventListener('click', ui.createHandlerFn(this, function() {
+                        let partTypeSelect = document.getElementById('part_part_type');
+
+                        if (partTypeSelect.options.length === 0 || partTypeSelect.value === '') {
+                            ui.addNotification(null, E('p', _('No partition types available. Maximum partitions reached.')), 'warning');
+                            return;
+                        }
+
+                        let sizeValue = document.getElementById('part_size').value.trim();
+                        let unit = document.getElementById('size_unit').value;
+
+                        if (!sizeValue || parseFloat(sizeValue) <= 0) {
+                            ui.addNotification(null, E('p', _('Please enter a valid size')), 'warning');
+                            return;
+                        }
+
+                        let multiplier = 1;
+                        if (unit === 'KB') multiplier = 1/1024;
+                        if (unit === 'GB') multiplier = 1024;
+                        if (unit === 'TB') multiplier = 1024*1024;
+                        let sizeMB = parseFloat(sizeValue) * multiplier;
+
+                        if (isNaN(sizeMB) || sizeMB < 1) {
+                            ui.addNotification(null, E('p', _('Size is too small')), 'warning');
+                            return;
+                        }
+
+                        let size = Math.floor(sizeMB).toString();
+                        
+                        let reservedSpaceValue = document.getElementById('reserved_space_value').value.trim();
+                        let reservedSpaceUnit = document.getElementById('reserved_space_unit').value;
+                        let fstype = document.getElementById('fs_type').value;
+
+                        ui.hideModal();
+
+                        this.createPartition(
+                            document.getElementById('part_part_type').value,
+                            fstype,
+                            document.getElementById('part_label').value,
+                            size,
+                            document.getElementById('part_layout').value,
+                            reservedSpaceValue,
+                            reservedSpaceUnit
+                        );
+                    }));
+                }
+
+                if (existingLayout) {
+                    let layoutSelect = document.getElementById('part_layout');
+                    if (layoutSelect) {
+                        layoutSelect.disabled = true;
+                    }
+                }
+
+                updatePartitionTypes();
+                updateMaxSize();
+
+                const sizeInput = document.getElementById('part_size');
+                const unitSelect = document.getElementById('size_unit');
+                const useMaxButton = document.getElementById('use_max_size');
+
+                const clampSizeInput = function() {
+                    if (!sizeInput || !unitSelect) return;
+                    let unit = unitSelect.value;
+                    let maxInUnit = parseFloat(sizeInput.getAttribute('data-max')) || convertFromMB(freeSpaceMB, unit);
+
+                    let val = parseFloat(sizeInput.value);
+                    if (isNaN(val)) return;
+                    if (val <= 0) {
+                        sizeInput.value = Number(Math.max(0.01, val)).toFixed(2);
+                        return;
+                    }
+
+                    if (val > maxInUnit) {
+                        sizeInput.value = Number(maxInUnit).toFixed(2);
+                    }
+                };
+
+                if (sizeInput) {
+                    sizeInput.addEventListener('input', clampSizeInput, false);
+                }
+                if (unitSelect) {
+                    unitSelect.addEventListener('change', function() {
+                        updateMaxSize();
+                        clampSizeInput();
+                    }, false);
+                }
+                if (useMaxButton) {
+                    useMaxButton.addEventListener('click', function() {
+                        let unit = unitSelect ? unitSelect.value : 'GB';
+                        let maxInUnit = convertFromMB(freeSpaceMB, unit);
+                        if (sizeInput) {
+                            sizeInput.value = Number(maxInUnit).toFixed(2);
+                            sizeInput.setAttribute('data-max', maxInUnit);
+                        }
+                    }, false);
+                }
+
+            }, 60);
+
+        }).catch(err => {
+            ui.addNotification(null, E('p', _('Failed to load disk information: ') + err.message), 'error');
+            console.error('showCreatePartitionDialog error:', err);
+        });
+    },
+
+    createPartition: async function(type, fstype, label, size, layout, reservedSpace, reservedUnit) {
+        const restorer = this.disableAllButtonsAndRemember();
+        try {
+            if (!this.selectedDisk) {
+                ui.addNotification(null, E('p', _('Please select a disk first')), 'warning');
+                return;
+            }
+
+            let diskInfo = await this.getDiskInfo(this.selectedDisk);
+            this.diskData[this.selectedDisk] = diskInfo;
+
+            let device = '/dev/' + this.selectedDisk;
+
+            let result = await this.callRpcd('create_partition', {
+                device: device,
+                type: type,
+                fstype: fstype,
+                size: size || '',
+                layout: layout,
+                label: label || '',
+                reserved_space: reservedSpace || '',
+                reserved_unit: reservedUnit || ''
+            });
+
+            if (result.success && result.pid) {
+                await this.monitorOperation(
+                    result.pid,
+                    _('Creating partition...'),
+                    _('Partition created successfully'),
+                    _('Failed to create partition')
+                );
+            } else {
+                throw new Error(result.error || _('Failed to start partition creation'));
+            }
+
+            await new Promise(resolve => setTimeout(resolve, 2000));
+
+            let freshDiskInfo = await this.getDiskInfo(this.selectedDisk);
+            this.diskData[this.selectedDisk] = freshDiskInfo;
+
+            if (freshDiskInfo.partitions && freshDiskInfo.partitions.length > 0) {
+                let lastPart = freshDiskInfo.partitions[freshDiskInfo.partitions.length - 1];
+                let path = '/dev/' + lastPart.name;
+
+                let exists = await this.waitForDevice(path, 20, 500);
+                if (exists && fstype && fstype !== 'extended') {
+                    const supported = await this.detectSupportedFilesystems();
+                    if (supported && supported.indexOf(fstype) !== -1) {
+                        await this.formatPartition(lastPart.name, fstype, label, true, true, reservedSpace, reservedUnit);
+                    } else {
+                        ui.addNotification(null, E('p', _('Partition created but selected filesystem is not available for formatting on this system')), 'warning');
+                        this.refreshDiskView();
+                    }
+                } else if (!exists) {
+                    ui.addNotification(null, E('p', _('Partition created but device node did not appear in time')), 'warning');
+                    this.refreshDiskView();
+                } else {
+                    this.refreshDiskView();
+                }
+            } else {
+                this.refreshDiskView();
+            }
+        } catch (err) {
+            this.hideOperationStatus();
+            console.error('createPartition error:', err);
+        } finally {
+            try { restorer.restore(); } catch (e) { console.error('restore buttons failed', e); }
+        }
+    },
+
+    showFormatDialog: function() {
+        if (!this.selectedPartition) {
+            ui.addNotification(null, E('p', _('Please select a partition first')), 'warning');
+            return;
+        }
+
+        if (this.isPartitionMounted(this.selectedPartition)) {
+            ui.addNotification(null, E('p', _('Cannot format mounted partition. Please unmount first.')), 'warning');
+            return;
+        }
+
+        let partName = this.selectedPartition.name;
+
+        this.detectSupportedFilesystems().then((supported) => {
+            let fsOptions = [];
+            if (supported && supported.length > 0) {
+                const preferred = ['ext4','ext3','ext2','f2fs','vfat','ntfs','exfat','swap'];
+                const ordered = preferred.filter(x => supported.indexOf(x) !== -1).concat(supported.filter(x => preferred.indexOf(x) === -1));
+                ordered.forEach((fsName, idx) => {
+                    fsOptions.push(E('option', {'value': fsName, ...(idx===0?{'selected':'selected'}:{})}, this.getFriendlyFsName(fsName)));
+                });
+            } else {
+                fsOptions.push(E('option', {'value': '', 'disabled': true, 'selected': 'selected'}, _('No supported filesystems detected on this system')));
+            }
+
+            ui.showModal(_('Format Partition'), [
+                E('div', {'class': 'cbi-section'}, [
+                    E('div', {'class': 'alert-message warning'}, [
+                        E('strong', {}, _('Warning')),
+                        E('br'),
+                        _('This will erase all data on /dev/%s').format(partName)
+                    ]),
+                    E('div', {'class': 'cbi-value'}, [
+                        E('label', {'class': 'cbi-value-title'}, _('Partition')),
+                        E('div', {'class': 'cbi-value-field'}, [
+                            E('input', {
+                                'class': 'cbi-input-text',
+                                'type': 'text',
+                                'value': '/dev/' + partName,
+                                'disabled': 'disabled'
+                            })
+                        ])
+                    ]),
+                    E('div', {'class': 'cbi-value'}, [
+                        E('label', {'class': 'cbi-value-title'}, _('File system')),
+                        E('div', {'class': 'cbi-value-field'}, [
+                            E('select', {
+                                'class': 'cbi-input-select', 
+                                'id': 'format_fs_type',
+                                'change': function() {
+                                    let reservedSection = document.getElementById('format_reserved_space_section');
+                                    if (reservedSection) {
+                                        if (this.value === 'ext2' || this.value === 'ext3' || this.value === 'ext4') {
+                                            reservedSection.style.display = '';
+                                        } else {
+                                            reservedSection.style.display = 'none';
+                                        }
+                                    }
+                                }
+                            }, fsOptions)
+                        ])
+                    ]),
+                    E('div', {'class': 'cbi-value'}, [
+                        E('label', {'class': 'cbi-value-title'}, _('Volume label')),
+                        E('div', {'class': 'cbi-value-field'}, [
+                            E('input', {'class': 'cbi-input-text', 'id': 'format_label', 'type': 'text', 
+                                'placeholder': _('Optional')})
+                        ])
+                    ]),
+                    E('div', {'class': 'cbi-value', 'id': 'format_reserved_space_section', 'style': 'display: none'}, [
+                        E('label', {'class': 'cbi-value-title'}, _('Reserved space')),
+                        E('div', {'class': 'cbi-value-field'}, [
+                            E('div', {'class': 'size-input-group'}, [
+                                E('input', {
+                                    'class': 'cbi-input-text',
+                                    'id': 'format_reserved_space_value',
+                                    'type': 'text',
+                                    'value': '5',
+                                    'placeholder': '5'
+                                }),
+                                E('select', {
+                                    'class': 'cbi-input-select',
+                                    'id': 'format_reserved_space_unit'
+                                }, [
+                                    E('option', {'value': '%', 'selected': 'selected'}, '%'),
+                                    E('option', {'value': 'MB'}, _('MB')),
+                                    E('option', {'value': 'GB'}, _('GB')),
+                                    E('option', {'value': 'TB'}, _('TB'))
+                                ])
+                            ]),
+                            E('div', {'style': 'margin-top: 5px; font-size: 12px; color: var(--text-color-secondary)'}, 
+                                _('Space reserved for root (default: 5%)'))
+                        ])
+                    ])
+                ]),
+                E('div', {'class': 'right'}, [
+                    E('button', {'class': 'btn', 'click': ui.hideModal}, _('Cancel')),
+                    ' ',
+                    E('button', {
+                        'class': 'btn cbi-button-negative',
+                        'click': ui.createHandlerFn(this, function() {
+                            let fstypeEl = document.getElementById('format_fs_type');
+                            let fstype = fstypeEl ? fstypeEl.value : '';
+                            let label = document.getElementById('format_label').value;
+                            let reservedSpaceValue = document.getElementById('format_reserved_space_value').value.trim();
+                            let reservedSpaceUnit = document.getElementById('format_reserved_space_unit').value;
+
+                            if (!fstype) {
+                                ui.addNotification(null, E('p', _('Please select a filesystem')), 'warning');
+                                return;
+                            }
+                            if (fstype === 'extended') {
+                    				// Not need filesystem validation
+				            } else if (fstype && supported && supported.length > 0 && supported.indexOf(fstype) === -1) {
+                    				ui.addNotification(null, E('p', _('Selected filesystem is not supported on this system')), 'warning');
+                    				return;
+				            }
+
+                            ui.hideModal();
+                            this.formatPartition(partName, fstype, label, false, false, reservedSpaceValue, reservedSpaceUnit);
+                        })
+                    }, _('Format'))
+                ])
+            ]);
+            
+            // Reserved space section
+            setTimeout(() => {
+                const fsSelect = document.getElementById('format_fs_type');
+                const reservedSection = document.getElementById('format_reserved_space_section');
+                if (reservedSection && fsSelect && fsSelect.value) {
+                    if (fsSelect.value === 'ext2' || fsSelect.value === 'ext3' || fsSelect.value === 'ext4') {
+                        reservedSection.style.display = '';
+                    } else {
+                        reservedSection.style.display = 'none';
+                    }
+                }
+            }, 100);
+        }).catch(err => {
+            ui.showModal(_('Format Partition'), [
+                E('p', {}, _('Failed to detect supported filesystems')),
+                E('pre', {}, (err && err.toString()) ? err.toString() : String(err)),
+                E('div', { 'class': 'right' }, [
+                    E('div', { 'class': 'btn cbi-button-neutral', 'click': ui.hideModal }, _('Close'))
+                ])
+            ]);
+        });
+    },
+
+    formatPartition: async function(partition, fstype, label, skipModal, skipDisable, reservedSpace, reservedUnit) {
+        const restorer = (skipDisable ? { restore: function() {} } : this.disableActiveButtonsAndRemember());
+        try {
+            const supported = await this.detectSupportedFilesystems();
+            if (fstype === 'extended') {
+		        // Not need filesystem validation
+		    } else if (fstype && supported && supported.length > 0 && supported.indexOf(fstype) === -1) {
+    			ui.addNotification(null, E('p', _('Selected filesystem is not supported on this system')), 'warning');
+    			return;
+		    }
+
+            let device = '/dev/' + partition;
+
+            let result = await this.callRpcd('format_partition', {
+                device: device,
+                fstype: fstype,
+                label: label || '',
+                reserved_space: reservedSpace || '',
+                reserved_unit: reservedUnit || ''
+            });
+
+            if (result.success && result.pid) {
+                await this.monitorOperation(
+                    result.pid,
+                    _('Formatting partition...'),
+                    _('Partition formatted successfully'),
+                    _('Failed to format partition')
+                );
+            } else {
+                throw new Error(result.error || _('Failed to start formatting'));
+            }
+
+            this.refreshDiskView();
+        } catch (err) {
+            this.hideOperationStatus();
+            console.error('formatPartition error:', err);
+        } finally {
+            try { restorer.restore(); } catch (e) { console.error('restore buttons failed', e); }
+        }
+    },
+
+    showWipeDialog: function() {
+        if (!this.selectedDisk || !this.wipeAllEnabled) {
+            ui.addNotification(null, E('p', _('Please enable wipe mode first')), 'warning');
+            return;
+        }
+
+        let diskName = this.selectedDisk;
+        let diskInfo = this.diskData[diskName];
+
+        if (this.hasAnyPartitionMounted(diskName)) {
+            ui.addNotification(null, E('p', _('Cannot wipe disk with mounted partitions. Please unmount all partitions first.')), 'warning');
+            return;
+        }
+
+        ui.showModal(_('Wipe Disk'), [
+            E('div', {'class': 'cbi-section'}, [
+                E('div', {'class': 'alert-message warning'}, [
+                    E('strong', {}, _('WARNING')),
+                    E('br'),
+                    _('This will completely erase the partition table and all data on /dev/%s!').format(diskName),
+                    E('br'),
+                    E('br'),
+                    E('strong', {}, _('THIS OPERATION CANNOT BE UNDONE!'))
+                ]),
+                E('p', {}, _('Number of partitions to be deleted: %d').format(diskInfo.partitions.length)),
+                E('p', {}, _('Are you absolutely sure you want to continue?'))
+            ]),
+            E('div', {'class': 'right'}, [
+                E('button', {'class': 'btn', 'click': ui.hideModal}, _('Cancel')),
+                ' ',
+                E('button', {
+                    'class': 'btn cbi-button-negative',
+                    'click': ui.createHandlerFn(this, function() {
+                        ui.hideModal();
+                        this.wipeDisk(diskName);
+                    })
+                }, _('Wipe Disk'))
+            ])
+        ]);
+    },
+
+    wipeDisk: async function(diskName) {
+        const restorer = this.disableActiveButtonsAndRemember();
+        try {
+            let device = '/dev/' + diskName;
+
+            let result = await this.callRpcd('wipe_disk', {
+                device: device
+            });
+
+            if (result.success && result.pid) {
+                await this.monitorOperation(
+                    result.pid,
+                    _('Wiping disk partition table...'),
+                    _('Disk partition table has been successfully erased'),
+                    _('Failed to wipe disk')
+                );
+            } else {
+                throw new Error(result.error || _('Failed to start disk wipe'));
+            }
+
+            this.wipeAllEnabled = false;
+            let wipeCheckbox = document.getElementById('wipeall-checkbox');
+            if (wipeCheckbox) {
+                wipeCheckbox.checked = false;
+            }
+            this.selectedPartition = null;
+            this.selectedUnallocated = null;
+            this.refreshDiskView();
+        } catch (err) {
+            this.hideOperationStatus();
+            console.error('wipeDisk error:', err);
+        } finally {
+            try { restorer.restore(); } catch (e) { console.error('restore buttons failed', e); }
+        }
+    },
+
+    showResizeDialog: async function() {
+        if (!this.selectedPartition) {
+            ui.addNotification(null, E('p', _('Please select a partition first')), 'warning');
+            return;
+        }
+
+        if (!this.canResizePartition(this.selectedPartition)) {
+            ui.addNotification(null, E('p', _('Selected partition cannot be resized. Only unmounted Ext2/3/4 partitions with available space can be resized.')), 'warning');
+            return;
+        }
+
+        const installed = await this.getInstalledPackages();
+        const has = (name) => this._isPackageInstalledFromList(installed, name);
+
+        const hasParted = has('parted');
+        const hasE2fsprogs = has('e2fsprogs');
+        const hasKmodExt4 = has('kmod-fs-ext4');
+        const hasBc = has('bc');
+        const hasResize2fs = has('resize2fs');
+
+        const resizeSupported = hasParted && hasE2fsprogs && hasKmodExt4 && hasBc && hasResize2fs;
+
+        if (!resizeSupported) {
+            return;
+        }
+
+        let part = this.selectedPartition;
+        let partName = part.name;
+        let currentSize = part.size;
+        let availableSpace = this.getAvailableSpaceForResize(part);
+        let maxSize = currentSize + availableSpace;
+
+        let currentSizeMB = Math.floor(currentSize / (1024 * 1024));
+        let currentSizeGB = (currentSizeMB / 1024).toFixed(2);
+        let currentSizeTB = (currentSizeGB / 1024).toFixed(2);
+
+        let availableSpaceMB = Math.floor(availableSpace / (1024 * 1024));
+        let availableSpaceGB = (availableSpaceMB / 1024).toFixed(2);
+        let availableSpaceTB = (availableSpaceGB / 1024).toFixed(2);
+
+        let maxSizeMB = Math.floor(maxSize / (1024 * 1024));
+        let maxSizeGB = (maxSizeMB / 1024).toFixed(2);
+        let maxSizeTB = (maxSizeGB / 1024).toFixed(2);
+
+        let convertToMB = function(value, unit) {
+            let val = parseFloat(value);
+            if (isNaN(val)) return 0;
+            switch(unit) {
+                case 'MB': return val;
+                case 'GB': return val * 1024;
+                case 'TB': return val * 1024 * 1024;
+                default: return 0;
+            }
+        };
+
+        let convertFromMB = function(mb, unit) {
+            if (typeof mb !== 'number') return '0';
+            switch(unit) {
+                case 'MB': return mb;
+                case 'GB': return (mb / 1024);
+                case 'TB': return (mb / 1024 / 1024);
+                default: return mb;
+            }
+        };
+
+        let sizeInput = E('input', {
+            'type': 'text',
+            'class': 'cbi-input-text',
+            'id': 'resize_size',
+            'placeholder': _('Enter new size'),
+            'value': currentSizeGB,
+            'data-max': maxSizeGB
+        });
+
+        let unitSelect = E('select', {
+            'class': 'cbi-input-select',
+            'id': 'resize_unit',
+            'change': function() {
+                let sizeInput = document.getElementById('resize_size');
+                if (!sizeInput) return;
+
+                let unit = unitSelect.value;
+                let maxInUnit = convertFromMB(maxSizeMB, unit);
+                sizeInput.setAttribute('data-max', maxInUnit);
+
+                let currentVal = parseFloat(sizeInput.value);
+                if (!isNaN(currentVal) && currentVal > maxInUnit) {
+                    sizeInput.value = Number(maxInUnit).toFixed(2);
+                }
+            }
+        }, [
+            E('option', {'value': 'MB'}, 'MB'),
+            E('option', {'value': 'GB', 'selected': 'selected'}, 'GB'),
+            E('option', {'value': 'TB'}, 'TB')
+        ]);
+
+        ui.showModal(_('Resize Partition'), [
+            E('div', {'class': 'cbi-section'}, [
+                E('div', {'class': 'alert-message warning'}, [
+                    E('strong', {}, _('Warning')),
+                    E('br'),
+                    _('Resizing a partition can cause data loss if not done correctly.'),
+                    E('br'),
+                    _('Please ensure you have a backup of important data before proceeding.')
+                ]),
+                E('div', {'class': 'cbi-section-descr'}, _('Resize partition /dev/%s').format(partName)),
+                E('div', {'class': 'cbi-section'}, [
+                    E('div', {'class': 'cbi-value'}, [
+                        E('label', {'class': 'cbi-value-title'}, _('New size')),
+                        E('div', {'class': 'cbi-value-field'}, [
+                            E('div', {'class': 'size-input-group'}, [sizeInput, unitSelect]),
+                            E('div', {'style': 'margin-top: 5px; font-size: 12px; color: var(--text-color-secondary)'}, [
+                                E('div', {'style': 'margin-top: 1px;'}, 
+                                    _('Current size: %s MB / %s GB / %s TB').format(
+                                        currentSizeMB, 
+                                        currentSizeGB, 
+                                        currentSizeTB
+                                    )),
+                                E('div', {'style': 'margin-top: 1px;'}, 
+                                    _('Available space: %s MB / %s GB / %s TB').format(
+                                        availableSpaceMB, 
+                                        availableSpaceGB, 
+                                        availableSpaceTB
+                                    )),
+                                E('div', {'style': 'margin-top: 1px;'}, 
+                                    _('Maximum size to be obtained: %s MB / %s GB / %s TB').format(
+                                        maxSizeMB, 
+                                        maxSizeGB, 
+                                        maxSizeTB
+                                    ))
+                            ])
+                        ])
+                    ])
+                ])
+            ]),
+            E('div', {'class': 'cbi-value'}, [
+                E('label', {'class': 'cbi-value-title'}, _('All available space')),
+                E('div', {'class': 'cbi-value-field'}, [
+                    E('button', {
+                        'id': 'use_max_resize',
+                        'class': 'btn',
+                        'click': function() {
+                            let sizeInput = document.getElementById('resize_size');
+                            let unitSelect = document.getElementById('resize_unit');
+                            if (!sizeInput || !unitSelect) return;
+
+                            let unit = unitSelect.value;
+                            let maxInUnit = convertFromMB(maxSizeMB, unit);
+                            sizeInput.value = Number(maxInUnit).toFixed(2);
+                            sizeInput.setAttribute('data-max', maxInUnit);
+                        }
+                    }, _('Fill in size'))
+                ])
+            ]),
+
+            E('div', {'style': 'display: flex; justify-content: space-between; align-items: center;'}, [
+                E('div', {}, [
+                    E('button', {'class': 'btn', 'click': ui.hideModal}, _('Cancel'))
+                ]),
+
+                E('div', {}, [
+                    E('button', {
+                        'class': 'cbi-button cbi-button-positive',
+                        'click': ui.createHandlerFn(this, function() {
+                            let newSizeValue = parseFloat(sizeInput.value);
+                            let unit = unitSelect.value;
+
+                            if (!newSizeValue || newSizeValue <= 0) {
+                                ui.addNotification(null, E('p', _('Please enter a valid size')), 'warning');
+                                return;
+                            }
+
+                            let newSizeBytes = newSizeValue;
+                            if (unit === 'MB') newSizeBytes *= 1024 * 1024;
+                            else if (unit === 'GB') newSizeBytes *= 1024 * 1024 * 1024;
+                            else if (unit === 'TB') newSizeBytes *= 1024 * 1024 * 1024 * 1024;
+
+                            if (newSizeBytes <= currentSize) {
+                                ui.addNotification(null, E('p', _('New size must be larger than current size')), 'warning');
+                                return;
+                            }
+
+                            if (newSizeBytes > maxSize) {
+                                ui.addNotification(null, E('p', _('New size exceeds available space')), 'warning');
+                                return;
+                            }
+
+                            ui.hideModal();
+                            this.resizePartition(partName, newSizeValue, unit);
+                        })
+                    }, _('Resize'))
+                ])
+            ])
+        ]);
+    },
+
+    resizePartition: async function(partition, newSize, unit) {
+        const restorer = this.disableActiveButtonsAndRemember();
+        try {
+            let device = '/dev/' + partition;
+
+            let result = await this.callRpcd('resize_partition', {
+                partition: device,
+                new_size: newSize.toString(),
+                unit: unit
+            });
+
+            if (result.success && result.pid) {
+                await this.monitorOperation(
+                    result.pid,
+                    _('Resizing partition...'),
+                    _('Partition resized successfully'),
+                    _('Failed to resize partition')
+                );
+            } else {
+                throw new Error(result.error || _('Failed to start partition resize'));
+            }
+
+            this.refreshDiskView();
+        } catch (err) {
+            this.hideOperationStatus();
+            console.error('resizePartition error:', err);
+        } finally {
+            try { restorer.restore(); } catch (e) { console.error('restore buttons failed', e); }
+        }
+    },
+
+    showDeleteDialog: function() {
+        if (!this.selectedPartition) {
+            ui.addNotification(null, E('p', _('Please select a partition first')), 'warning');
+            return;
+        }
+
+        if (this.isPartitionMounted(this.selectedPartition)) {
+            ui.addNotification(null, E('p', _('Cannot delete mounted partition. Please unmount first.')), 'warning');
+            return;
+        }
+
+        let partName = this.selectedPartition.name;
+
+        ui.showModal(_('Delete Partition'), [
+            E('div', {'class': 'cbi-section'}, [
+                E('div', {'class': 'alert-message warning'}, [
+                    E('strong', {}, _('Warning')),
+                    E('br'),
+                    _('This will delete partition /dev/%s and all its data!').format(partName)
+                ]),
+                E('p', {}, _('Are you sure you want to continue?'))
+            ]),
+            E('div', {'class': 'right'}, [
+                E('button', {'class': 'btn', 'click': ui.hideModal}, _('Cancel')),
+                ' ',
+                E('button', {
+                    'class': 'btn cbi-button-negative',
+                    'click': ui.createHandlerFn(this, function() {
+                        ui.hideModal();
+                        this.deletePartition(partName);
+                    })
+                }, _('Delete'))
+            ])
+        ]);
+    },
+
+    deletePartition: function(partition) {
+        let partitionPath = '/dev/' + partition;
+
+        this.callRpcd('delete_partition', {
+            partition: partitionPath
+        }).then(result => {
+            if (result.success && result.pid) {
+                return this.monitorOperation(
+                    result.pid,
+                    _('Deleting partition...'),
+                    _('Partition deleted successfully'),
+                    _('Failed to delete partition')
+                );
+            } else {
+                throw new Error(result.error || _('Failed to start partition deletion'));
+            }
+        }).then(() => {
+            this.selectedPartition = null;
+            this.refreshDiskView();
+        }).catch(err => {
+            this.hideOperationStatus();
+            console.error('deletePartition error:', err);
+        });
+    },
+
+    mountDisk: function() {
+        if (!this.selectedPartition) {
+            ui.addNotification(null, E('p', _('Please select a partition first')), 'warning');
+            return;
+        }
+
+        let part = this.selectedPartition;
+        let partPath = '/dev/' + part.name;
+        let mountPoint = '/mnt/' + part.name;
+
+        fs.exec('/bin/mkdir', ['-p', mountPoint]).then(() => {
+            fs.exec('/bin/mount', [partPath, mountPoint]).then(res => {
+                if (res.code === 0) {
+                    this.popTimeout(null, E('p', _('Mounted to %s').format(mountPoint)), 5000, 'info');
+                    this.refreshDiskView();
+                } else {
+                    ui.addNotification(null, E('p', _('Failed to mount: ') + res.stderr), 'error');
+                }
+            });
+        });
+    },
+
+    unmountDisk: function() {
+        if (!this.selectedPartition) {
+            ui.addNotification(null, E('p', _('Please select a partition first')), 'warning');
+            return;
+        }
+
+        let part = this.selectedPartition;
+
+        if (!part.mountpoint) {
+            ui.addNotification(null, E('p', _('Selected partition is not mounted')), 'warning');
+            return;
+        }
+
+        fs.exec('/bin/umount', [part.mountpoint]).then(res => {
+            if (res.code === 0) {
+                this.popTimeout(null, E('p', _('Unmounted %s').format(part.mountpoint)), 5000, 'info');
+                this.refreshDiskView();
+            } else {
+                ui.addNotification(null, E('p', _('Failed to unmount: ') + res.stderr), 'error');
+            }
+        });
+    },
+
+    refreshDiskView: function() {
+        this.selectedPartition = null;
+        this.selectedUnallocated = null;
+
+        if (!this.selectedDisk) {
+            let contentArea = document.getElementById('disk-content-area');
+            if (contentArea) {
+                contentArea.innerHTML = '';
+                contentArea.appendChild(
+                E('div', {'class': 'alert alert-information'}, 
+                    _('Please select a disk to view its partitions')));
+            }
+            this.updateActionButtons();
+            return;
+        }
+
+        let contentArea = document.getElementById('disk-content-area');
+        if (!contentArea) return;
+
+        contentArea.innerHTML = '';
+        contentArea.appendChild(E('div', {'class': 'alert alert-info'}, 
+            E('span', {'class': 'spinning'}, _('Loading disk information...'))));
+
+        Promise.all([
+            this.getDiskInfo(this.selectedDisk),
+            this.getMountedPartitions()
+        ]).then(results => {
+            let diskInfo = results[0];
+            this.mountedPartitions = results[1];
+            this.diskData[this.selectedDisk] = diskInfo;
+
+            let diskDetails = E('div', {'class': 'cbi-value'}, [
+                E('div', { 
+                    'class': 'cbi-value', 
+                    'id': 'disk-info-compact',
+                    'style': 'margin-bottom: 0.5em; text-align: left;'
+                }, [
+                    E('small', { 'style': 'font-size: 0.9em; color: var(--text-color-medium, #111);' }, [
+                        _('Mount Status') + ': ',
+                        E('span', { 'style': 'color: ' + (this.hasAnyPartitionMounted(this.selectedDisk) ? 
+                            'var(--app-mini-diskmanager-primary)' : 'var(--text-color-secondary)') }, 
+                            [(this.hasAnyPartitionMounted(this.selectedDisk) ? _('Mounted') : _('Not mounted')).toUpperCase()])
+                    ])
+                ])
+            ]);
+
+            let partitionLayoutSection = E('div', {'class': 'partition-layout-section'}, [
+                E('div', {'class': 'ifacebox', 'style': 'width:98%;table-layout:fixed;'}, [
+                    E('div', {
+                        'class': 'ifacebox-head', 
+                        'style': 'font-weight:bold;background:#f8f8f8;padding:8px;text-align:center;',
+                        'click': ui.createHandlerFn(this, function(ev) {
+                            if (this.hasAnyPartitionMounted(this.selectedDisk)) {
+                                return;
+                            }  
+                            let wipeCheckbox = document.getElementById('wipeall-checkbox');
+                            if (wipeCheckbox && !wipeCheckbox.disabled) {
+                                wipeCheckbox.checked = !wipeCheckbox.checked;
+                                wipeCheckbox.dispatchEvent(new Event('change', { bubbles: true }));
+                            }
+                        })
+                    }, _('Partition Layout')),
+                    E('div', {'class': 'ifacebox-body'}, [
+                        this.renderPartitionBar(diskInfo)
+                    ])
+                ])
+            ]);
+
+            contentArea.innerHTML = '';
+            contentArea.appendChild(diskDetails);
+            contentArea.appendChild(partitionLayoutSection);
+            contentArea.appendChild(E('h3', {'class': 'fade-in'}, _('Partitions')));
+            contentArea.appendChild(E('div', {'class': 'partition-table-container'}, [
+                this.renderPartitionTable(diskInfo)
+            ]));
+
+            this.updateActionButtons();
+        }).catch(err => {
+            console.log('refreshDiskView error:', err);
+            contentArea.innerHTML = '';
+            contentArea.appendChild(E('div', {'class': 'alert alert-danger'}, 
+                _('Error loading disk information: ') + (err.message || err.toString())));
+            this.updateActionButtons();
+        });
+    },
+
+    handleSaveApply: null,
+    handleSave: null,
+    handleReset: null
+});
diff --git a/package/luci-app-mini-diskmanager/po/de/mini-diskmanager.po b/package/luci-app-mini-diskmanager/po/de/mini-diskmanager.po
new file mode 100644
index 0000000000..32ef6fa620
--- /dev/null
+++ b/package/luci-app-mini-diskmanager/po/de/mini-diskmanager.po
@@ -0,0 +1,1253 @@
+msgid ""
+msgstr ""
+"Project-Id-Version: luci-app-mini-diskmanager\n"
+"Language-Team: Rafał Wabik (IceG)\n"
+
+msgid "Disk Manager"
+msgstr "Datenträgerverwaltung"
+
+msgid "-- Select a disk --"
+msgstr "-- Datenträger auswählen --"
+
+msgid "Disk"
+msgstr "Datenträger"
+
+msgid "Refresh"
+msgstr "Aktualisieren"
+
+msgid "Mounting actions"
+msgstr "Einhängeaktionen"
+
+msgid "Actions on partitions"
+msgstr "Operationen auf Partitionen"
+
+msgid "Mount"
+msgstr "Einhängen"
+
+msgid "Unmount"
+msgstr "Aushängen"
+
+msgid "Create"
+msgstr "Erstellen"
+
+msgid "Delete"
+msgstr "Löschen"
+
+msgid "Format"
+msgstr "Formatieren"
+
+msgid "Please select a disk to view its partitions"
+msgstr "Bitte wählen Sie einen Datenträger aus, um seine Partitionen anzuzeigen"
+
+msgid "Please select a disk first"
+msgstr "Bitte wählen Sie zuerst einen Datenträger aus"
+
+msgid "Please select a partition first"
+msgstr "Bitte wählen Sie zuerst eine Partition aus"
+
+msgid "Loading disk information..."
+msgstr "Datenträgerinformationen werden geladen..."
+
+msgid "Error loading disk information: "
+msgstr "Fehler beim Laden der Datenträgerinformationen: "
+
+msgid "Disk Information"
+msgstr "Datenträgerinformationen"
+
+msgid "Temperature"
+msgstr "Temperatur"
+
+msgid "S.M.A.R.T."
+msgstr "S.M.A.R.T."
+
+msgid "S.M.A.R.T. Status"
+msgstr "S.M.A.R.T.-Status"
+
+msgid "Partitions"
+msgstr "Partitionen"
+
+msgid "Mount Status"
+msgstr "Einhängestatus"
+
+msgid "Mounted"
+msgstr "Eingehängt"
+
+msgid "Not mounted"
+msgstr "Nicht eingehängt"
+
+msgid "Partition Layout"
+msgstr "Partitionslayout"
+
+msgid "Partition"
+msgstr "Partition"
+
+msgid "Type / Filesystem"
+msgstr "Typ / Dateisystem"
+
+msgid "Filesystem"
+msgstr "Dateisystem"
+
+msgid "Mount Point"
+msgstr "Einhängepunkt"
+
+msgid "Label"
+msgstr "Bezeichnung"
+
+msgid "Size"
+msgstr "Größe"
+
+msgid "Used"
+msgstr "Belegt"
+
+msgid "Unused"
+msgstr "Frei"
+
+msgid "Flags"
+msgstr "Flags"
+
+msgid "No partitions found"
+msgstr "Keine Partitionen gefunden"
+
+msgid "Unallocated"
+msgstr "Nicht zugewiesen"
+
+msgid "Area without partition table"
+msgstr "Bereich ohne Partitionstabelle"
+
+msgid "Free Space"
+msgstr "Freier Speicherplatz"
+
+msgid "Primary"
+msgstr "Primär"
+
+msgid "Extended"
+msgstr "Erweitert"
+
+msgid "Logical"
+msgstr "Logisch"
+
+msgid "Create partition"
+msgstr "Partition erstellen"
+
+msgid "Cancel"
+msgstr "Abbrechen"
+
+msgid "File system"
+msgstr "Dateisystem"
+
+msgid "Volume label"
+msgstr "Datenträgerbezeichnung"
+
+msgid "Partition size"
+msgstr "Partitionsgröße"
+
+msgid "Enter size"
+msgstr "Größe eingeben"
+
+msgid "Use all available space"
+msgstr "Gesamten verfügbaren Speicherplatz verwenden"
+
+msgid "Available: %s MB / %s GB / %s TB"
+msgstr "Verfügbar: %s MB / %s GB / %s TB"
+
+msgid "Please enter a valid size"
+msgstr "Bitte geben Sie eine gültige Größe ein"
+
+msgid "Size is too small"
+msgstr "Die Größe ist zu klein"
+
+msgid "Creating partition..."
+msgstr "Partition wird erstellt..."
+
+msgid "Partition created successfully"
+msgstr "Partition erfolgreich erstellt"
+
+msgid "Failed to create partition"
+msgstr "Partition konnte nicht erstellt werden"
+
+msgid "Format Partition"
+msgstr "Partition formatieren"
+
+msgid "Warning"
+msgstr "Warnung"
+
+msgid "This will erase all data on /dev/%s"
+msgstr "Dies löscht alle Daten auf /dev/%s"
+
+msgid "Formatting partition..."
+msgstr "Partition wird formatiert..."
+
+msgid "Partition formatted successfully"
+msgstr "Partition erfolgreich formatiert"
+
+msgid "Failed to format partition"
+msgstr "Partition konnte nicht formatiert werden"
+
+msgid "Delete Partition"
+msgstr "Partition löschen"
+
+msgid "Are you sure you want to continue?"
+msgstr "Sind Sie sicher, dass Sie fortfahren möchten?"
+
+msgid "Deleting partition..."
+msgstr "Partition wird gelöscht..."
+
+msgid "Partition deleted successfully"
+msgstr "Partition erfolgreich gelöscht"
+
+msgid "Failed to delete partition"
+msgstr "Partition konnte nicht gelöscht werden"
+
+msgid "No partitions to mount"
+msgstr "Keine Partitionen zum Einhängen"
+
+msgid "No mounted partitions found"
+msgstr "Keine eingehängten Partitionen gefunden"
+
+msgid "No partitions to unmount"
+msgstr "Keine Partitionen zum Aushängen"
+
+msgid "Mounted to %s"
+msgstr "Eingehängt unter %s"
+
+msgid "Unmounted %s"
+msgstr "%s ausgehängt"
+
+msgid "Failed to mount: "
+msgstr "Einhängen fehlgeschlagen: "
+
+msgid "Failed to unmount: "
+msgstr "Aushängen fehlgeschlagen: "
+
+msgid "Failed to check operation status: "
+msgstr "Überprüfung des Betriebsstatus fehlgeschlagen: "
+
+msgid "Partition created but device node did not appear in time"
+msgstr "Partition erstellt, aber Geräteknoten ist nicht rechtzeitig erschienen"
+
+msgid "Partition created but device node did not appear; please refresh manually"
+msgstr "Partition erstellt, aber Geräteknoten ist nicht erschienen; bitte manuell aktualisieren"
+
+msgid "PASSED"
+msgstr "BESTANDEN"
+
+msgid "FAILED"
+msgstr "FEHLGESCHLAGEN"
+
+msgid "Cannot create partition on mounted disk. Please unmount first."
+msgstr "Partition kann nicht auf eingehängtem Datenträger erstellt werden. Bitte zuerst aushängen."
+
+msgid "No unallocated space available on this disk"
+msgstr "Kein nicht zugewiesener Speicherplatz auf diesem Datenträger verfügbar"
+
+msgid "Cannot format mounted partition. Please unmount first."
+msgstr "Eingehängte Partition kann nicht formatiert werden. Bitte zuerst aushängen."
+
+msgid "Failed to refresh partition data: "
+msgstr "Aktualisierung der Partitionsdaten fehlgeschlagen: "
+
+msgid "Cannot delete partition on mounted disk. Please unmount first."
+msgstr "Partition kann nicht auf eingehängtem Datenträger gelöscht werden. Bitte zuerst aushängen."
+
+msgid "This will delete partition /dev/%s and all its data!"
+msgstr "Dies löscht Partition /dev/%s und alle ihre Daten!"
+
+msgid "Failed to load disk information: "
+msgstr "Laden der Datenträgerinformationen fehlgeschlagen: "
+
+msgid "Click to select"
+msgstr "Zum Auswählen klicken"
+
+msgid "System partition cannot be selected"
+msgstr "Systempartition kann nicht ausgewählt werden"
+
+msgid "Free"
+msgstr "Frei"
+
+msgid "Select a disk"
+msgstr "Datenträger auswählen"
+
+msgid "Create a new partition on the selected disk"
+msgstr "Neue Partition auf dem ausgewählten Datenträger erstellen"
+
+msgid "Partition layout"
+msgstr "Partitionslayout"
+
+msgid "Partition type"
+msgstr "Partitionstyp"
+
+msgid "Refresh partition data"
+msgstr "Partitionsdaten aktualisieren"
+
+msgid "MBR (Master Boot Record)"
+msgstr "MBR (Master Boot Record)"
+
+msgid "GPT (GUID Partition Table)"
+msgstr "GPT (GUID-Partitionstabelle)"
+
+msgid "The Mini Disk Manager package allows users to easily manage disks and partitions."
+msgstr "Das Paket Mini Disk Manager ermöglicht es Benutzern, Datenträger und Partitionen einfach zu verwalten."
+
+msgid "Configuration"
+msgstr "Konfiguration"
+
+msgid "Package and Driver Verification"
+msgstr "Paket- und Treiberüberprüfung"
+
+msgid "Check and install required drivers for storage devices."
+msgstr "Überprüfen und installieren Sie die erforderlichen Treiber für Speichergeräte."
+
+msgid "Filesystem Support"
+msgstr "Dateisystemunterstützung"
+
+msgid "Check USB drivers"
+msgstr "USB-Treiber überprüfen"
+
+msgid "USB drivers"
+msgstr "USB-Treiber"
+
+msgid "Check NVMe drivers"
+msgstr "NVMe-Treiber überprüfen"
+
+msgid "NVMe drivers"
+msgstr "NVMe-Treiber"
+
+msgid "Check ATA/SATA drivers"
+msgstr "ATA/SATA-Treiber überprüfen"
+
+msgid "ATA/SATA drivers"
+msgstr "ATA/SATA-Treiber"
+
+msgid "Check Linux filesystem packages"
+msgstr "Linux-Dateisystempakete überprüfen"
+
+msgid "Linux filesystems"
+msgstr "Linux-Dateisysteme"
+
+msgid "Check Windows filesystem packages"
+msgstr "Windows-Dateisystempakete überprüfen"
+
+msgid "Windows filesystems"
+msgstr "Windows-Dateisysteme"
+
+msgid "Linux Filesystem Packages"
+msgstr "Linux-Dateisystempakete"
+
+msgid "Windows Filesystem Packages"
+msgstr "Windows-Dateisystempakete"
+
+msgid "Disk Manager Log"
+msgstr "Datenträgerverwaltungsprotokoll"
+
+msgid "Loading package data…"
+msgstr "Paketdaten werden geladen…"
+
+msgid "Loading log file…"
+msgstr "Protokolldatei wird geladen…"
+
+msgid "Log file content"
+msgstr "Protokolldateiinhalt"
+
+msgid "Log file is empty"
+msgstr "Protokolldatei ist leer"
+
+msgid "Unable to read log file"
+msgstr "Protokolldatei kann nicht gelesen werden"
+
+msgid "Log file cleared successfully"
+msgstr "Protokolldatei erfolgreich geleert"
+
+msgid "Unable to clear the file"
+msgstr "Datei kann nicht geleert werden"
+
+msgid "Installed"
+msgstr "Installiert"
+
+msgid "Install…"
+msgstr "Installieren…"
+
+msgid "Clear"
+msgstr "Löschen"
+
+msgid "Download"
+msgstr "Herunterladen"
+
+msgid "Close"
+msgstr "Schließen"
+
+msgid "Failed to load package data"
+msgstr "Laden der Paketdaten fehlgeschlagen"
+
+msgid "more info in log"
+msgstr "mehr Informationen im Protokoll"
+
+msgid "The tab allows users to support the package."
+msgstr "Die Registerkarte ermöglicht es Benutzern, das Paket zu unterstützen."
+
+msgid "Package support"
+msgstr "Paketunterstützung"
+
+msgid "Mini Disk Manager Info"
+msgstr "Mini Disk Manager-Informationen"
+
+msgid "Luci-app-mdmanager"
+msgstr "Luci-app-mdmanager"
+
+msgid "Buy a coffee"
+msgstr "Einen Kaffee spendieren"
+
+msgid "Buy a coffee if you want to support the development of the project and the author"
+msgstr "Spendieren Sie einen Kaffee, wenn Sie die Entwicklung des Projekts und den Autor unterstützen möchten"
+
+msgid "Become a sponsor"
+msgstr "Sponsor werden"
+
+msgid "Become a sponsor if you want to support the development of the project and the author"
+msgstr "Werden Sie Sponsor, wenn Sie die Entwicklung des Projekts und den Autor unterstützen möchten"
+
+msgid "Write on forum"
+msgstr "Im Forum schreiben"
+
+msgid "Write in the topic of the package on the forum eko.one.pl"
+msgstr "Schreiben Sie im Thema des Pakets im Forum eko.one.pl"
+
+msgid "Open discussion"
+msgstr "Diskussion öffnen"
+
+msgid "Open a package discussion on Github"
+msgstr "Paketdiskussion auf Github öffnen"
+
+msgid "Report a bug"
+msgstr "Fehler melden"
+
+msgid "Report a bug on the package Github page"
+msgstr "Melden Sie einen Fehler auf der Github-Seite des Pakets"
+
+msgid "Package name"
+msgstr "Paketname"
+
+msgid "Author (package maintainer)"
+msgstr "Autor (Paketbetreuer)"
+
+msgid "Information about package author and available support options."
+msgstr "Informationen über den Paketautor und verfügbare Supportoptionen."
+
+# --
+
+msgid "All available space"
+msgstr "Gesamter verfügbarer Speicherplatz"
+
+msgid "Cannot delete mounted partition. Please unmount first."
+msgstr "Eingehängte Partition kann nicht gelöscht werden. Bitte zuerst aushängen."
+
+msgid "Failed to create partition: "
+msgstr "Erstellen der Partition fehlgeschlagen: "
+
+msgid "Failed to detect supported filesystems"
+msgstr "Erkennung unterstützter Dateisysteme fehlgeschlagen"
+
+msgid "Failed to format partition: "
+msgstr "Formatieren der Partition fehlgeschlagen: "
+
+msgid "Failed to parse JSON response: "
+msgstr "Parsen der JSON-Antwort fehlgeschlagen: "
+
+msgid "Failed to start formatting"
+msgstr "Formatierung konnte nicht gestartet werden"
+
+msgid "Failed to start partition creation"
+msgstr "Partitionserstellung konnte nicht gestartet werden"
+
+msgid "Failed to start partition deletion"
+msgstr "Partitionslöschung konnte nicht gestartet werden"
+
+msgid "Fill in size"
+msgstr "Größe ausfüllen"
+
+msgid "Linux Swap"
+msgstr "Linux Swap"
+
+msgid "Loading..."
+msgstr "Wird geladen..."
+
+msgid "No filesystem packages detected — user cannot choose unsupported filesystem formats."
+msgstr "Keine Dateisystempakete erkannt — Benutzer kann nicht unterstützte Dateisystemformate nicht auswählen."
+
+msgid "No partition types available. Maximum partitions reached."
+msgstr "Keine Partitionstypen verfügbar. Maximale Anzahl an Partitionen erreicht."
+
+msgid "No supported filesystems detected on this system"
+msgstr "Keine unterstützten Dateisysteme auf diesem System erkannt"
+
+msgid "Optional"
+msgstr "Optional"
+
+msgid "Partition created but selected filesystem is not available for formatting on this system"
+msgstr "Partition erstellt, aber das ausgewählte Dateisystem ist auf diesem System nicht zum Formatieren verfügbar"
+
+msgid "Partition data refreshed"
+msgstr "Partitionsdaten aktualisiert"
+
+msgid "Please select a filesystem"
+msgstr "Bitte wählen Sie ein Dateisystem aus"
+
+msgid "RPC call failed: "
+msgstr "RPC-Aufruf fehlgeschlagen: "
+
+msgid "Refreshing..."
+msgstr "Wird aktualisiert..."
+
+msgid "Selected filesystem is not supported on this system"
+msgstr "Das ausgewählte Dateisystem wird auf diesem System nicht unterstützt"
+
+msgid "Selected partition is not mounted"
+msgstr "Ausgewählte Partition ist nicht eingehängt"
+
+msgid "unknown error"
+msgstr "unbekannter Fehler"
+
+msgid "Packages & Drivers"
+msgstr "Pakete und Treiber"
+
+msgid "Mini Disk Manager log"
+msgstr "Mini Disk Manager-Protokoll"
+
+msgid "Packages required to support various file systems."
+msgstr "Pakete, die zur Unterstützung verschiedener Dateisysteme erforderlich sind."
+
+msgid "Expand"
+msgstr "Erweitern"
+
+msgid "Resize"
+msgstr "Größe ändern"
+
+msgid "Resize Partition"
+msgstr "Partitionsgröße ändern"
+
+msgid "Resize partition /dev/%s"
+msgstr "Größe der Partition /dev/%s ändern"
+
+msgid "Resizing partition..."
+msgstr "Partitionsgröße wird geändert..."
+
+msgid "Resizing a partition can cause data loss if not done correctly."
+msgstr "Das Ändern der Partitionsgröße kann zu Datenverlust führen, wenn es nicht korrekt durchgeführt wird."
+
+msgid "Please ensure you have a backup of important data before proceeding."
+msgstr "Stellen Sie sicher, dass Sie vor dem Fortfahren eine Sicherung wichtiger Daten haben."
+
+msgid "Current size: %s MB / %s GB / %s TB"
+msgstr "Aktuelle Größe: %s MB / %s GB / %s TB"
+
+msgid "Available space: %s MB / %s GB / %s TB"
+msgstr "Verfügbarer Speicherplatz: %s MB / %s GB / %s TB"
+
+msgid "Maximum size to be obtained: %s MB / %s GB / %s TB"
+msgstr "Maximal erreichbare Größe: %s MB / %s GB / %s TB"
+
+msgid "Maximum new size"
+msgstr "Maximale neue Größe"
+
+msgid "New size"
+msgstr "Neue Größe"
+
+msgid "Enter new size"
+msgstr "Neue Größe eingeben"
+
+msgid "New size must be larger than current size"
+msgstr "Neue Größe muss größer als die aktuelle Größe sein"
+
+msgid "New size exceeds available space"
+msgstr "Neue Größe überschreitet verfügbaren Speicherplatz"
+
+msgid "Partition resized successfully"
+msgstr "Partitionsgröße erfolgreich geändert"
+
+msgid "Failed to resize partition"
+msgstr "Ändern der Partitionsgröße fehlgeschlagen"
+
+msgid "Failed to resize partition: "
+msgstr "Ändern der Partitionsgröße fehlgeschlagen: "
+
+msgid "Failed to start partition resize"
+msgstr "Starten der Partitionsgrößenänderung fehlgeschlagen"
+
+msgid "Selected partition cannot be resized. Only unmounted Ext2/3/4 partitions with available space can be resized."
+msgstr "Ausgewählte Partition kann nicht in der Größe geändert werden. Nur ausgehängte Ext2/3/4-Partitionen mit verfügbarem Speicherplatz können in der Größe geändert werden."
+
+msgid "MB"
+msgstr "MB"
+
+msgid "GB"
+msgstr "GB"
+
+msgid "TB"
+msgstr "TB"
+
+msgid "Cannot Create Partition"
+msgstr "Partition kann nicht erstellt werden"
+
+msgid "Insufficient Space"
+msgstr "Unzureichender Speicherplatz"
+
+msgid "Cannot read partition information"
+msgstr "Partitionsinformationen können nicht gelesen werden"
+
+msgid "Invalid extended partition"
+msgstr "Ungültige erweiterte Partition"
+
+msgid "Extended partition not found or has invalid size"
+msgstr "Erweiterte Partition nicht gefunden oder hat ungültige Größe"
+
+msgid "Extended partition size: %s MB"
+msgstr "Größe der erweiterten Partition: %s MB"
+
+msgid "Used by logical partitions: %s MB"
+msgstr "Von logischen Partitionen verwendet: %s MB"
+
+msgid "Available for new logical: %s MB"
+msgstr "Verfügbar für neue logische Partition: %s MB"
+
+msgid "Required minimum: 10 MB"
+msgstr "Erforderliches Minimum: 10 MB"
+
+msgid "Not enough free space in extended partition /dev/%s"
+msgstr "Nicht genug freier Speicherplatz in erweiterter Partition /dev/%s"
+
+msgid "Extended partition already exists. You can create primary partitions or select the extended partition to create logical partitions inside."
+msgstr "Erweiterte Partition existiert bereits. Sie können primäre Partitionen erstellen oder die erweiterte Partition auswählen, um darin logische Partitionen zu erstellen."
+
+msgid "Creating partition inside extended partition. Only logical partitions can be created here."
+msgstr "Erstellen einer Partition innerhalb der erweiterten Partition. Hier können nur logische Partitionen erstellt werden."
+
+msgid "No partition table detected. A primary partition will be created and a partition table will be initialized."
+msgstr "Keine Partitionstabelle erkannt. Eine primäre Partition wird erstellt und eine Partitionstabelle wird initialisiert."
+
+msgid "No partition table - select to create"
+msgstr "Keine Partitionstabelle - zum Erstellen auswählen"
+
+msgid "No partitions - select to create"
+msgstr "Keine Partitionen - zum Erstellen auswählen"
+
+msgid "Select to enable partition creation"
+msgstr "Zum Aktivieren der Partitionserstellung auswählen"
+
+msgid "Select unallocated space"
+msgstr "Nicht zugewiesenen Speicherplatz auswählen"
+
+msgid "Unallocated space"
+msgstr "Nicht zugewiesener Speicherplatz"
+
+msgid "Expand Ext2/Ext3/Ext4"
+msgstr "Ext2/Ext3/Ext4 erweitern"
+
+msgid "Wipe"
+msgstr "Löschen"
+
+msgid "Select all partitions for wiping"
+msgstr "Alle Partitionen zum Löschen auswählen"
+
+msgid "Please enable wipe mode first"
+msgstr "Bitte aktivieren Sie zuerst den Löschmodus"
+
+msgid "Cannot wipe disk with mounted partitions. Please unmount all partitions first."
+msgstr "Festplatte mit eingehängten Partitionen kann nicht gelöscht werden. Bitte hängen Sie zuerst alle Partitionen aus."
+
+msgid "Wipe Disk"
+msgstr "Festplatte löschen"
+
+msgid "WARNING"
+msgstr "WARNUNG"
+
+msgid "This will completely erase the partition table and all data on /dev/%s!"
+msgstr "Dies wird die Partitionstabelle und alle Daten auf /dev/%s vollständig löschen!"
+
+msgid "All partitions will be deleted and the disk will be unallocated."
+msgstr "Alle Partitionen werden gelöscht und die Festplatte wird nicht zugewiesen."
+
+msgid "THIS OPERATION CANNOT BE UNDONE!"
+msgstr "DIESER VORGANG KANN NICHT RÜCKGÄNGIG GEMACHT WERDEN!"
+
+msgid "Number of partitions to be deleted: %d"
+msgstr "Anzahl der zu löschenden Partitionen: %d"
+
+msgid "Are you absolutely sure you want to continue?"
+msgstr "Sind Sie absolut sicher, dass Sie fortfahren möchten?"
+
+msgid "Wiping disk partition table..."
+msgstr "Lösche Festplatten-Partitionstabelle..."
+
+msgid "Disk partition table has been successfully erased"
+msgstr "Die Partitionstabelle der Festplatte wurde erfolgreich gelöscht"
+
+msgid "Failed to wipe disk"
+msgstr "Festplatte konnte nicht gelöscht werden"
+
+msgid "Failed to start disk wipe"
+msgstr "Löschen der Festplatte konnte nicht gestartet werden"
+
+msgid "Failed to wipe disk: "
+msgstr "Festplatte konnte nicht gelöscht werden: "
+
+msgid "Disk Wipe Support"
+msgstr "Unterstützung für Festplattenlöschung"
+
+msgid "Packages required to support disk wiping functionality (clearing partition table)."
+msgstr "Pakete, die zur Unterstützung der Festplattenlöschfunktion erforderlich sind (Löschen der Partitionstabelle)."
+
+msgid "Check Disk Wipe packages"
+msgstr "Festplattenlösch-Pakete überprüfen"
+
+msgid "Disk Wipe"
+msgstr "Festplatte löschen"
+
+msgid "dd from BusyBox"
+msgstr "dd von BusyBox"
+
+msgid "Disk Wipe (dd command)"
+msgstr "Festplatte löschen (dd-Befehl)"
+
+msgid "Log file cleared successfully"
+msgstr "Protokolldatei erfolgreich gelöscht"
+
+msgid "Unable to clear the file"
+msgstr "Datei konnte nicht gelöscht werden"
+
+msgid "alternative"
+msgstr "Alternative"
+
+# SMART
+
+msgid "Attribute"
+msgstr "Attribut"
+
+msgid "Id"
+msgstr "Id"
+
+msgid "Raw"
+msgstr "Raw"
+
+msgid "Value"
+msgstr "Wert"
+
+msgid "Worst"
+msgstr "Schlechtester"
+
+msgid "Thresh"
+msgstr "Schwelle"
+
+msgid "Value"
+msgstr "Wert"
+
+msgid "NVMe S.M.A.R.T. Health Status"
+msgstr "NVMe S.M.A.R.T. Gesundheitsstatus"
+
+msgid "OK"
+msgstr "OK"
+
+msgid "WARNING"
+msgstr "WARNUNG"
+
+msgid "Power On Time"
+msgstr "Betriebszeit"
+
+msgid "Power On Hours"
+msgstr "Betriebsstunden"
+
+msgid "Disk Usage"
+msgstr "Festplattennutzung"
+
+msgid "Disk Wear Level"
+msgstr "Abnutzungsgrad der Festplatte"
+
+msgid "Available Spare"
+msgstr "Verfügbare Reserve"
+
+msgid "Available Spare Threshold"
+msgstr "Verfügbare Reservenschwelle"
+
+msgid "hour"
+msgstr "Stunde"
+
+msgid "hours"
+msgstr "Stunden"
+
+msgid "h"
+msgstr "Std"
+
+msgid "year"
+msgstr "Jahr"
+
+msgid "years"
+msgstr "Jahre"
+
+msgid "month"
+msgstr "Monat"
+
+msgid "months"
+msgstr "Monate"
+
+msgid "day"
+msgstr "Tag"
+
+msgid "days"
+msgstr "Tage"
+
+msgid "worn"
+msgstr "abgenutzt"
+
+msgid "remaining"
+msgstr "verbleibend"
+
+msgid "S.M.A.R.T. Health Status"
+msgstr "Allgemeiner Gesundheitszustand der Festplatte S.M.A.R.T."
+
+msgid "No S.M.A.R.T. attributes found."
+msgstr "Keine S.M.A.R.T.-Attribute gefunden."
+
+msgid "Loading S.M.A.R.T. data..."
+msgstr "Lade S.M.A.R.T.-Daten..."
+
+msgid "Unable to read S.M.A.R.T. data."
+msgstr "S.M.A.R.T.-Daten können nicht gelesen werden."
+
+msgid "Error reading S.M.A.R.T. data."
+msgstr "Fehler beim Lesen der S.M.A.R.T.-Daten."
+
+# SMART & Disk Info
+
+msgid "Raw Read Error Rate"
+msgstr "Lesefehlerrate"
+
+msgid "Throughput Performance"
+msgstr "Durchsatzleistung"
+
+msgid "Spin Up Time"
+msgstr "Anlaufzeit"
+
+msgid "Start Stop Count"
+msgstr "Start/Stopp-Anzahl"
+
+msgid "Reallocated Sector Count"
+msgstr "Anzahl neu zugeordneter Sektoren"
+
+msgid "Seek Error Rate"
+msgstr "Positionierungsfehlerrate"
+
+msgid "Seek Time Performance"
+msgstr "Positionierungsleistung"
+
+msgid "Power On Hours"
+msgstr "Betriebsstunden"
+
+msgid "Spin Retry Count"
+msgstr "Anzahl Anlaufwiederholungen"
+
+msgid "Calibration Retry Count"
+msgstr "Anzahl Kalibrierungswiederholungen"
+
+msgid "Power Cycle Count"
+msgstr "Anzahl Einschaltzyklen"
+
+msgid "Read Soft Error Rate"
+msgstr "Soft-Lesefehlerrate"
+
+msgid "Airflow Temperature"
+msgstr "Luftstromtemperatur"
+
+msgid "Temperature Celsius"
+msgstr "Temperatur"
+
+msgid "Hardware ECC Recovered"
+msgstr "Hardware-ECC wiederhergestellt"
+
+msgid "Current Pending Sector"
+msgstr "Instabile Sektoren"
+
+msgid "Offline Uncorrectable"
+msgstr "Offline nicht korrigierbar"
+
+msgid "UDMA CRC Error Count"
+msgstr "UDMA-CRC-Fehleranzahl"
+
+msgid "Multi Zone Error Rate"
+msgstr "Mehrzonen-Fehlerrate"
+
+msgid "Wear Leveling Count"
+msgstr "Abnutzungsausgleichszähler"
+
+msgid "Used Reserved Block Count Total"
+msgstr "Verwendete reservierte Blöcke (gesamt)"
+
+msgid "Used Reserved Block Count Chip"
+msgstr "Verwendete reservierte Blöcke (Chip)"
+
+msgid "Unused Reserved Block Count Total"
+msgstr "Ungenutzte reservierte Blöcke"
+
+msgid "Program Fail Count Total"
+msgstr "Anzahl Programmierfehler"
+
+msgid "Erase Fail Count Total"
+msgstr "Anzahl Löschfehler"
+
+msgid "Runtime Bad Block"
+msgstr "Fehlerhafte Blöcke"
+
+msgid "Uncorrectable Error Count"
+msgstr "Anzahl nicht korrigierbarer Fehler"
+
+msgid "Temperature Exceed Count"
+msgstr "Anzahl Temperaturüberschreitungen"
+
+msgid "Erase Fail Count"
+msgstr "Anzahl Löschfehler"
+
+msgid "Reported Uncorrectable Errors"
+msgstr "Gemeldete nicht korrigierbare Fehler"
+
+msgid "High Fly Writes"
+msgstr "High-Fly-Schreibvorgänge"
+
+msgid "G-Sense Error Rate"
+msgstr "G-Sensor-Fehlerrate"
+
+msgid "Power-Off Retract Count"
+msgstr "Anzahl Kopfrückzüge beim Ausschalten"
+
+msgid "Load Cycle Count"
+msgstr "Anzahl Parkzyklen"
+
+msgid "Temperature Case"
+msgstr "Gehäusetemperatur"
+
+msgid "Reallocated Event Count"
+msgstr "Anzahl Neuzuordnungsereignisse"
+
+msgid "Transfer Error Rate"
+msgstr "Übertragungsfehlerrate"
+
+msgid "Free Fall Sensor"
+msgstr "Freifallsensor"
+
+msgid "Total LBAs Written"
+msgstr "Gesamtanzahl geschriebener LBAs"
+
+msgid "Total LBAs Read"
+msgstr "Gesamtanzahl gelesener LBAs"
+
+msgid "Read Error Retry Rate"
+msgstr "Lesewiederholungsrate"
+
+msgid "Minimum W/E Cycle"
+msgstr "Minimaler Schreib-/Löschzyklus"
+
+msgid "Maximum W/E Cycle"
+msgstr "Maximaler Schreib-/Löschzyklus"
+
+msgid "Average W/E Cycle"
+msgstr "Durchschnittlicher Schreib-/Löschzyklus"
+
+msgid "Media Wearout Indicator"
+msgstr "Medienabnutzungsindikator"
+
+msgid "Available Reserved Space"
+msgstr "Verfügbarer reservierter Speicherplatz"
+
+msgid "SSD Life Left"
+msgstr "Verbleibende SSD-Lebensdauer"
+
+msgid "Remaining Lifetime Percentage"
+msgstr "Verbleibende Lebensdauer (Prozent)"
+
+msgid "Percentage Lifetime Remaining"
+msgstr "Prozent verbleibende Lebensdauer"
+
+msgid "Remaining Life"
+msgstr "Verbleibende Lebensdauer"
+
+msgid "Lifetime Writes GiB"
+msgstr "Geschriebene Daten (GiB)"
+
+msgid "Lifetime Reads GiB"
+msgstr "Gelesene Daten (GiB)"
+
+msgid "Program Fail Count"
+msgstr "Anzahl Programmierfehler"
+
+msgid "Unexpected Power Loss Count"
+msgstr "Anzahl unerwarteter Stromausfälle"
+
+msgid "Thermal Throttle Status"
+msgstr "Thermische Drosselungsstatus"
+
+msgid "End-to-End Error"
+msgstr "End-to-End-Fehler"
+
+msgid "Workload Host Reads Percentage"
+msgstr "Prozentsatz Host-Lesevorgänge"
+
+msgid "Workload Media Wear Indicator"
+msgstr "Workload-Medienabnutzungsindikator"
+
+msgid "Timed Workload Media Wear"
+msgstr "Zeitbasierte Workload-Medienabnutzung"
+
+msgid "Workload Timer"
+msgstr "Workload-Timer"
+
+msgid "Percentage Rated Life Used"
+msgstr "Prozent verbrauchte Lebensdauer"
+
+msgid "Head Flying Hours"
+msgstr "Kopfflugstunden"
+
+msgid "Read Channel Margin"
+msgstr "Lesekanalreserve"
+
+msgid "Loaded Hours"
+msgstr "Betriebsstunden entparkt"
+
+msgid "Load/Unload Retry Count"
+msgstr "Anzahl Park-/Entparkwiederholungen"
+
+msgid "GMR Head Amplitude"
+msgstr "GMR-Kopfamplitude"
+
+msgid "Drive Temperature"
+msgstr "Laufwerkstemperatur"
+
+msgid "Endurance Remaining"
+msgstr "Verbleibende Ausdauer"
+
+msgid "Power On Hours and Milliseconds"
+msgstr "Betriebsstunden (Stunden und Millisekunden)"
+
+msgid "Head Health"
+msgstr "Kopfzustand"
+
+msgid "POR Recovery Count"
+msgstr "POR-Wiederherstellungsanzahl"
+
+msgid "Unused Reserve NAND Blocks"
+msgstr "Ungenutzte NAND-Reserveblöcke"
+
+msgid "SSD Protect Mode"
+msgstr "SSD-Schutzmodus"
+
+msgid "Host Writes 32MiB"
+msgstr "Host-Schreibvorgänge (32MiB)"
+
+msgid "NAND Writes 32MiB"
+msgstr "NAND-Schreibvorgänge (32MiB)"
+
+msgid "Remaining Life Left"
+msgstr "Verbleibende Lebensdauer"
+
+msgid "Grown Bad Block Count"
+msgstr "Anzahl neuer fehlerhafter Blöcke"
+
+msgid "Soft Read Error Rate"
+msgstr "Soft-Lesefehlerrate"
+
+msgid "Data Address Mark Errors"
+msgstr "Datenadressmarkierungsfehler"
+
+msgid "Run Out Cancel"
+msgstr "Überlaufabbruch"
+
+msgid "Soft ECC Correction"
+msgstr "Soft-ECC-Korrektur"
+
+msgid "TA Increase Count"
+msgstr "TA-Erhöhungsanzahl"
+
+msgid "Shock Count Write Operation"
+msgstr "Anzahl Erschütterungen beim Schreiben"
+
+msgid "Shock Rate Write Operation"
+msgstr "Erschütterungsrate beim Schreiben"
+
+msgid "Flying Height"
+msgstr "Flughöhe"
+
+msgid "Spin High Current"
+msgstr "Hoher Anlaufstrom"
+
+msgid "Spin Buzz"
+msgstr "Anlauf-Buzz"
+
+msgid "Offline Seek Performance"
+msgstr "Offline-Positionierungsleistung"
+
+msgid "Vibration During Write"
+msgstr "Vibrationen beim Schreiben"
+
+msgid "Shock During Write"
+msgstr "Erschütterungen beim Schreiben"
+
+msgid "Disk Shift"
+msgstr "Festplattenverschiebung"
+
+msgid "Load Retry Count"
+msgstr "Anzahl Ladewiederholungen"
+
+msgid "Load Friction"
+msgstr "Ladereibung"
+
+msgid "Load-in Time"
+msgstr "Ladezeit"
+
+msgid "Torque Amplification Count"
+msgstr "Anzahl Drehmomentverstärkungen"
+
+msgid "Write Error Rate"
+msgstr "Schreibfehlerrate"
+
+msgid "Serial Number"
+msgstr "Seriennummer"
+
+msgid "LU WWN Device Id"
+msgstr "LU WWN Geräte-ID"
+
+msgid "Firmware Version"
+msgstr "Firmware-Version"
+
+msgid "User Capacity"
+msgstr "Nutzbare Kapazität"
+
+msgid "Capacity"
+msgstr "Kapazität"
+
+msgid "Sector Size"
+msgstr "Sektorgröße"
+
+msgid "Sector Sizes"
+msgstr "Sektorgrößen"
+
+msgid "Rotation Rate"
+msgstr "Drehzahl"
+
+msgid "Form Factor"
+msgstr "Formfaktor"
+
+msgid "Device is"
+msgstr "Gerät"
+
+msgid "ATA Version is"
+msgstr "ATA-Version"
+
+msgid "SATA Version is"
+msgstr "SATA-Version"
+
+msgid "Local Time is"
+msgstr "Ortszeit"
+
+msgid "SMART support is"
+msgstr "SMART-Unterstützung"
+
+msgid "SMART Status"
+msgstr "SMART-Status"
+
+msgid "Device"
+msgstr "Gerät"
+
+msgid "Model Number"
+msgstr "Modell"
+
+msgid "Firmware Revision"
+msgstr "Firmware-Revision"
+
+msgid "PCI Vendor/Subsystem ID"
+msgstr "PCI-Hersteller-/Subsystem-ID"
+
+msgid "IEEE OUI Identifier"
+msgstr "IEEE-OUI-Kennung"
+
+msgid "Total NVM Capacity"
+msgstr "Gesamt-NVM-Kapazität"
+
+msgid "Unallocated NVM Capacity"
+msgstr "Nicht zugeordnete NVM-Kapazität"
+
+msgid "Controller ID"
+msgstr "Controller-ID"
+
+msgid "Number of Namespaces"
+msgstr "Anzahl der Adressräume"
+
+msgid "Namespace 1 Size/Capacity"
+msgstr "Größe/Kapazität Adressraum 1"
+
+msgid "Namespace 1 Formatted LBA Size"
+msgstr "LBA-Größe Adressraum 1"
+
+msgid "Namespace 1 IEEE EUI-64"
+msgstr "IEEE EUI-64 Adressraum 1"
+
+msgid "logical/physical"
+msgstr "logisch/physisch"
+
+msgid "bytes"
+msgstr "Bytes"
+
+msgid "blocks"
+msgstr "Blöcke"
+
+msgid "Solid State Device"
+msgstr "Solid State Disk"
+
+# Reserved space 
+
+msgid "Reserved space"
+msgstr "Reservierter Speicherplatz"
+
+msgid "Space reserved for root (default: 5%)"
+msgstr "Für Root reservierter Speicherplatz (Standard: 5%)"
+
+msgid "Used Reserved Block Count Total"
+msgstr "Gesamtzahl verwendeter reservierter Blöcke"
+
+msgid "Used Reserved Block Count Chip"
+msgstr "Anzahl verwendeter reservierter Blöcke pro Chip"
+
+msgid "Unused Reserved Block Count Total"
+msgstr "Gesamtzahl ungenutzter reservierter Blöcke"
+
+msgid "Available Reserved Space"
+msgstr "Verfügbarer reservierter Speicherplatz"
+
+# NVMe
+
+msgid "Critical Warning"
+msgstr "Kritische Warnung"
+
+msgid "Percentage Used"
+msgstr "Prozentsatz verwendet"
+
+msgid "Data Units Read"
+msgstr "Gelesene Dateneinheiten"
+
+msgid "Data Units Written"
+msgstr "Geschriebene Dateneinheiten"
+
+msgid "Host Read Commands"
+msgstr "Host-Lesebefehle"
+
+msgid "Host Write Commands"
+msgstr "Host-Schreibbefehle"
+
+msgid "Controller Busy Time"
+msgstr "Controller-Auslastungszeit"
+
+msgid "Power Cycles"
+msgstr "Einschaltzyklen"
+
+msgid "Unsafe Shutdowns"
+msgstr "Unsichere Abschaltungen"
+
+msgid "Media Errors"
+msgstr "Medienfehler"
+
+msgid "Error Log Entries"
+msgstr "Fehlerprotokolleinträge"
diff --git a/package/luci-app-mini-diskmanager/po/fr/mini-diskmanager.po b/package/luci-app-mini-diskmanager/po/fr/mini-diskmanager.po
new file mode 100644
index 0000000000..e9ba3e1d05
--- /dev/null
+++ b/package/luci-app-mini-diskmanager/po/fr/mini-diskmanager.po
@@ -0,0 +1,1312 @@
+msgid ""
+msgstr ""
+"Project-Id-Version: luci-app-mini-diskmanager\n"
+"PO-Revision-Date: \n"
+"Last-Translator: \n"
+"Language-Team: Rafał Wabik (IceG)\n"
+"Language: fr\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+msgid "Disk Manager"
+msgstr "Gestionnaire de disques"
+
+msgid "-- Select a disk --"
+msgstr "-- Sélectionner un disque --"
+
+msgid "Disk"
+msgstr "Disque"
+
+msgid "Refresh"
+msgstr "Actualiser"
+
+msgid "Mounting actions"
+msgstr "Actions de montage"
+
+msgid "Actions on partitions"
+msgstr "Opérations sur les partitions"
+
+msgid "Mount"
+msgstr "Monter"
+
+msgid "Unmount"
+msgstr "Démonter"
+
+msgid "Create"
+msgstr "Créer"
+
+msgid "Delete"
+msgstr "Supprimer"
+
+msgid "Format"
+msgstr "Formater"
+
+msgid "Please select a disk to view its partitions"
+msgstr "Veuillez sélectionner un disque pour voir ses partitions"
+
+msgid "Please select a disk first"
+msgstr "Veuillez d'abord sélectionner un disque"
+
+msgid "Please select a partition first"
+msgstr "Veuillez d'abord sélectionner une partition"
+
+msgid "Loading disk information..."
+msgstr "Chargement des informations du disque..."
+
+msgid "Error loading disk information: "
+msgstr "Erreur de chargement des informations du disque : "
+
+msgid "Disk Information"
+msgstr "Informations du disque"
+
+msgid "Temperature"
+msgstr "Température"
+
+msgid "S.M.A.R.T."
+msgstr "S.M.A.R.T."
+
+msgid "S.M.A.R.T. Status"
+msgstr "État S.M.A.R.T."
+
+msgid "Partitions"
+msgstr "Partitions"
+
+msgid "Mount Status"
+msgstr "État du montage"
+
+msgid "Mounted"
+msgstr "Monté"
+
+msgid "Not mounted"
+msgstr "Non monté"
+
+msgid "Partition Layout"
+msgstr "Disposition des partitions"
+
+msgid "Partition"
+msgstr "Partition"
+
+msgid "Type / Filesystem"
+msgstr "Type / Système de fichiers"
+
+msgid "Filesystem"
+msgstr "Système de fichiers"
+
+msgid "Mount Point"
+msgstr "Point de montage"
+
+msgid "Label"
+msgstr "Étiquette"
+
+msgid "Size"
+msgstr "Taille"
+
+msgid "Used"
+msgstr "Utilisé"
+
+msgid "Unused"
+msgstr "Libre"
+
+msgid "Flags"
+msgstr "Drapeaux"
+
+msgid "No partitions found"
+msgstr "Aucune partition trouvée"
+
+msgid "Unallocated"
+msgstr "Non alloué"
+
+msgid "Area without partition table"
+msgstr "Zone sans table de partition"
+
+msgid "Free Space"
+msgstr "Espace libre"
+
+msgid "Primary"
+msgstr "Primaire"
+
+msgid "Extended"
+msgstr "Étendue"
+
+msgid "Logical"
+msgstr "Logique"
+
+msgid "Create partition"
+msgstr "Créer une partition"
+
+msgid "Cancel"
+msgstr "Annuler"
+
+msgid "File system"
+msgstr "Système de fichiers"
+
+msgid "Volume label"
+msgstr "Étiquette du volume"
+
+msgid "Partition size"
+msgstr "Taille de la partition"
+
+msgid "Enter size"
+msgstr "Entrer la taille"
+
+msgid "Use all available space"
+msgstr "Utiliser tout l'espace disponible"
+
+msgid "Available: %s MB / %s GB / %s TB"
+msgstr "Disponible : %s Mo / %s Go / %s To"
+
+msgid "Please enter a valid size"
+msgstr "Veuillez entrer une taille valide"
+
+msgid "Size is too small"
+msgstr "La taille est trop petite"
+
+msgid "Creating partition..."
+msgstr "Création de la partition..."
+
+msgid "Partition created successfully"
+msgstr "Partition créée avec succès"
+
+msgid "Failed to create partition"
+msgstr "Échec de la création de la partition"
+
+msgid "Format Partition"
+msgstr "Formater la partition"
+
+msgid "Warning"
+msgstr "Avertissement"
+
+msgid "This will erase all data on /dev/%s"
+msgstr "Cela effacera toutes les données sur /dev/%s"
+
+msgid "Formatting partition..."
+msgstr "Formatage de la partition..."
+
+msgid "Partition formatted successfully"
+msgstr "Partition formatée avec succès"
+
+msgid "Failed to format partition"
+msgstr "Échec du formatage de la partition"
+
+msgid "Delete Partition"
+msgstr "Supprimer la partition"
+
+msgid "Are you sure you want to continue?"
+msgstr "Êtes-vous sûr de vouloir continuer ?"
+
+msgid "Deleting partition..."
+msgstr "Suppression de la partition..."
+
+msgid "Partition deleted successfully"
+msgstr "Partition supprimée avec succès"
+
+msgid "Failed to delete partition"
+msgstr "Échec de la suppression de la partition"
+
+msgid "No partitions to mount"
+msgstr "Aucune partition à monter"
+
+msgid "No mounted partitions found"
+msgstr "Aucune partition montée trouvée"
+
+msgid "No partitions to unmount"
+msgstr "Aucune partition à démonter"
+
+msgid "Mounted to %s"
+msgstr "Monté sur %s"
+
+msgid "Unmounted %s"
+msgstr "Démonté %s"
+
+msgid "Failed to mount: "
+msgstr "Échec du montage : "
+
+msgid "Failed to unmount: "
+msgstr "Échec du démontage : "
+
+msgid "Failed to check operation status: "
+msgstr "Échec de la vérification de l'état de l'opération : "
+
+msgid "Partition created but device node did not appear in time"
+msgstr "Partition créée mais le nœud de périphérique n'est pas apparu à temps"
+
+msgid "Partition created but device node did not appear; please refresh manually"
+msgstr "Partition créée mais le nœud de périphérique n'est pas apparu ; veuillez actualiser manuellement"
+
+msgid "PASSED"
+msgstr "RÉUSSI"
+
+msgid "FAILED"
+msgstr "ÉCHOUÉ"
+
+msgid "Cannot create partition on mounted disk. Please unmount first."
+msgstr "Impossible de créer une partition sur un disque monté. Veuillez d'abord démonter."
+
+msgid "No unallocated space available on this disk"
+msgstr "Aucun espace non alloué disponible sur ce disque"
+
+msgid "Cannot format mounted partition. Please unmount first."
+msgstr "Impossible de formater une partition montée. Veuillez d'abord la démonter."
+
+msgid "Failed to refresh partition data: "
+msgstr "Échec de l'actualisation des données de partition : "
+
+msgid "Cannot delete partition on mounted disk. Please unmount first."
+msgstr "Impossible de supprimer une partition sur un disque monté. Veuillez d'abord démonter."
+
+msgid "This will delete partition /dev/%s and all its data!"
+msgstr "Cela supprimera la partition /dev/%s et toutes ses données !"
+
+msgid "Failed to load disk information: "
+msgstr "Échec du chargement des informations du disque : "
+
+msgid "Click to select"
+msgstr "Cliquer pour sélectionner"
+
+msgid "System partition cannot be selected"
+msgstr "La partition système ne peut pas être sélectionnée"
+
+msgid "Free"
+msgstr "Libre"
+
+msgid "Select a disk"
+msgstr "Sélectionner un disque"
+
+msgid "Create a new partition on the selected disk"
+msgstr "Créer une nouvelle partition sur le disque sélectionné"
+
+msgid "Partition layout"
+msgstr "Disposition des partitions"
+
+msgid "Partition type"
+msgstr "Type de partition"
+
+msgid "Refresh partition data"
+msgstr "Actualiser les données de partition"
+
+msgid "MBR (Master Boot Record)"
+msgstr "MBR (Master Boot Record)"
+
+msgid "GPT (GUID Partition Table)"
+msgstr "GPT (Table de partition GUID)"
+
+msgid "The Mini Disk Manager package allows users to easily manage disks and partitions."
+msgstr "Le package Mini Gestionnaire de disques permet aux utilisateurs de gérer facilement les disques et les partitions."
+
+msgid "Configuration"
+msgstr "Configuration"
+
+msgid "Package and Driver Verification"
+msgstr "Vérification des packages et des pilotes"
+
+msgid "Check and install required drivers for storage devices."
+msgstr "Vérifier et installer les pilotes requis pour les périphériques de stockage."
+
+msgid "Filesystem Support"
+msgstr "Support des systèmes de fichiers"
+
+msgid "Check USB drivers"
+msgstr "Vérifier les pilotes USB"
+
+msgid "USB drivers"
+msgstr "Pilotes USB"
+
+msgid "Check NVMe drivers"
+msgstr "Vérifier les pilotes NVMe"
+
+msgid "NVMe drivers"
+msgstr "Pilotes NVMe"
+
+msgid "Check ATA/SATA drivers"
+msgstr "Vérifier les pilotes ATA/SATA"
+
+msgid "ATA/SATA drivers"
+msgstr "Pilotes ATA/SATA"
+
+msgid "Storage drive support"
+msgstr "Support des lecteurs de stockage"
+
+msgid "Check SCSI drivers"
+msgstr "Vérifier les pilotes SCSI"
+
+msgid "SCSI drivers"
+msgstr "Pilotes SCSI"
+
+msgid "Disk management packages"
+msgstr "Packages de gestion des disques"
+
+msgid "Check Disk Management packages"
+msgstr "Vérifier les packages de gestion des disques"
+
+msgid "Disk Management (fdisk, parted, losetup)"
+msgstr "Gestion des disques (fdisk, parted, losetup)"
+
+msgid "Extended partition support (gdisk)"
+msgstr "Support des partitions étendues (gdisk)"
+
+msgid "GPT partition support (parted, gdisk)"
+msgstr "Support des partitions GPT (parted, gdisk)"
+
+msgid "Partition size modification support (resize2fs)"
+msgstr "Support de modification de taille de partition (resize2fs)"
+
+msgid "Disk and partition modification support (sfdisk)"
+msgstr "Support de modification de disque et partition (sfdisk)"
+
+msgid "Partition scanning and updating support (partx)"
+msgstr "Support de numérisation et mise à jour des partitions (partx)"
+
+msgid "Filesystem packages"
+msgstr "Packages de systèmes de fichiers"
+
+msgid "Check Filesystem packages"
+msgstr "Vérifier les packages de systèmes de fichiers"
+
+msgid "Filesystems"
+msgstr "Systèmes de fichiers"
+
+msgid "EXT2"
+msgstr "EXT2"
+
+msgid "EXT3"
+msgstr "EXT3"
+
+msgid "EXT4"
+msgstr "EXT4"
+
+msgid "EXFAT"
+msgstr "EXFAT"
+
+msgid "F2FS"
+msgstr "F2FS"
+
+msgid "FAT32"
+msgstr "FAT32"
+
+msgid "NTFS-3G"
+msgstr "NTFS-3G"
+
+msgid "All Required"
+msgstr "Tous requis"
+
+msgid "Please do NOT refresh or leave this page until verification is complete."
+msgstr "Veuillez NE PAS actualiser ou quitter cette page jusqu'à ce que la vérification soit terminée."
+
+msgid "Verify"
+msgstr "Vérifier"
+
+msgid "Check All"
+msgstr "Tout vérifier"
+
+msgid "Install"
+msgstr "Installer"
+
+msgid "Install All"
+msgstr "Tout installer"
+
+msgid "Verify Selected"
+msgstr "Vérifier la sélection"
+
+msgid "Install Selected"
+msgstr "Installer la sélection"
+
+msgid "Verify Required"
+msgstr "Vérifier les requis"
+
+msgid "Install Required"
+msgstr "Installer les requis"
+
+msgid "Component"
+msgstr "Composant"
+
+msgid "Status"
+msgstr "État"
+
+msgid "Action"
+msgstr "Action"
+
+msgid "Installed"
+msgstr "Installé"
+
+msgid "Not installed"
+msgstr "Non installé"
+
+msgid "Package installation failed for: "
+msgstr "Échec de l'installation du package pour : "
+
+msgid "Verification/installation in progress..."
+msgstr "Vérification/installation en cours..."
+
+msgid "Verification in progress..."
+msgstr "Vérification en cours..."
+
+msgid "Installation in progress..."
+msgstr "Installation en cours..."
+
+msgid "Waiting for package verification..."
+msgstr "En attente de la vérification du package..."
+
+msgid "All packages installed successfully"
+msgstr "Tous les packages installés avec succès"
+
+msgid "Some packages failed to install"
+msgstr "Certains packages n'ont pas pu être installés"
+
+msgid "Installed via filesystem support"
+msgstr "Installé via le support du système de fichiers"
+
+msgid "About Package"
+msgstr "À propos du package"
+
+msgid "Star"
+msgstr "Étoile"
+
+msgid "Star the package repository on Github"
+msgstr "Mettre une étoile au dépôt du package sur Github"
+
+msgid "Sponsor"
+msgstr "Sponsor"
+
+msgid "Become a sponsor if you want to support the development of the project and its author"
+msgstr "Devenez un sponsor si vous souhaitez soutenir le développement du projet et son auteur"
+
+msgid "Write on forum"
+msgstr "Écrire sur le forum"
+
+msgid "Write in the topic of the package on the forum eko.one.pl"
+msgstr "Écrire dans le sujet du package sur le forum eko.one.pl"
+
+msgid "Open discussion"
+msgstr "Ouvrir une discussion"
+
+msgid "Open a package discussion on Github"
+msgstr "Ouvrir une discussion sur le package sur Github"
+
+msgid "Report a bug"
+msgstr "Signaler un bug"
+
+msgid "Report a bug on the package Github page"
+msgstr "Signaler un bug sur la page Github du package"
+
+msgid "Package name"
+msgstr "Nom du package"
+
+msgid "Author (package maintainer)"
+msgstr "Auteur (mainteneur du package)"
+
+msgid "Information about package author and available support options."
+msgstr "Informations sur l'auteur du package et les options de support disponibles."
+
+# ---
+
+msgid "All available space"
+msgstr "Tout l'espace disponible"
+
+msgid "Cannot delete mounted partition. Please unmount first."
+msgstr "Impossible de supprimer une partition montée. Veuillez d'abord la démonter."
+
+msgid "Failed to create partition: "
+msgstr "Échec de la création de la partition : "
+
+msgid "Failed to detect supported filesystems"
+msgstr "Échec de la détection des systèmes de fichiers supportés"
+
+msgid "Failed to format partition: "
+msgstr "Échec du formatage de la partition : "
+
+msgid "Failed to parse JSON response: "
+msgstr "Échec de l'analyse de la réponse JSON : "
+
+msgid "Failed to start formatting"
+msgstr "Échec du démarrage du formatage"
+
+msgid "Failed to start partition creation"
+msgstr "Échec du démarrage de la création de partition"
+
+msgid "Failed to start partition deletion"
+msgstr "Échec du démarrage de la suppression de partition"
+
+msgid "Fill in size"
+msgstr "Remplir la taille"
+
+msgid "Linux Swap"
+msgstr "Linux Swap"
+
+msgid "Loading..."
+msgstr "Chargement..."
+
+msgid "No filesystem packages detected — user cannot choose unsupported filesystem formats."
+msgstr "Aucun package de système de fichiers détecté — l'utilisateur ne peut pas choisir de formats de système de fichiers non supportés."
+
+msgid "No partition types available. Maximum partitions reached."
+msgstr "Aucun type de partition disponible. Nombre maximum de partitions atteint."
+
+msgid "No supported filesystems detected on this system"
+msgstr "Aucun système de fichiers supporté détecté sur ce système"
+
+msgid "Optional"
+msgstr "Optionnel"
+
+msgid "Partition created but selected filesystem is not available for formatting on this system"
+msgstr "Partition créée mais le système de fichiers sélectionné n'est pas disponible pour le formatage sur ce système"
+
+msgid "Partition data refreshed"
+msgstr "Données de partition actualisées"
+
+msgid "Please select a filesystem"
+msgstr "Veuillez sélectionner un système de fichiers"
+
+msgid "RPC call failed: "
+msgstr "Échec de l'appel RPC : "
+
+msgid "Refreshing..."
+msgstr "Actualisation..."
+
+msgid "Selected filesystem is not supported on this system"
+msgstr "Le système de fichiers sélectionné n'est pas supporté sur ce système"
+
+msgid "Selected partition is not mounted"
+msgstr "La partition sélectionnée n'est pas montée"
+
+msgid "unknown error"
+msgstr "erreur inconnue"
+
+msgid "Packages & Drivers"
+msgstr "Packages et pilotes"
+
+msgid "Mini Disk Manager log"
+msgstr "Journal du Mini Gestionnaire de disques"
+
+msgid "Mini Disk Manager Log"
+msgstr "Journal du Mini Gestionnaire de disques"
+
+msgid "Packages required to support various file systems."
+msgstr "Packages requis pour supporter différents systèmes de fichiers."
+
+msgid "Expand"
+msgstr "Étendre"
+
+msgid "Resize"
+msgstr "Redimensionner"
+
+msgid "Resize Partition"
+msgstr "Redimensionner la partition"
+
+msgid "Resize partition /dev/%s"
+msgstr "Redimensionner la partition /dev/%s"
+
+msgid "Resizing partition..."
+msgstr "Redimensionnement de la partition..."
+
+msgid "Resizing a partition can cause data loss if not done correctly."
+msgstr "Le redimensionnement d'une partition peut causer une perte de données s'il n'est pas effectué correctement."
+
+msgid "Please ensure you have a backup of important data before proceeding."
+msgstr "Veuillez vous assurer d'avoir une sauvegarde des données importantes avant de continuer."
+
+msgid "Current size: %s MB / %s GB / %s TB"
+msgstr "Taille actuelle : %s Mo / %s Go / %s To"
+
+msgid "Available space: %s MB / %s GB / %s TB"
+msgstr "Espace disponible : %s Mo / %s Go / %s To"
+
+msgid "Maximum size to be obtained: %s MB / %s GB / %s TB"
+msgstr "Taille maximale à obtenir : %s Mo / %s Go / %s To"
+
+msgid "Maximum new size"
+msgstr "Taille maximale nouvelle"
+
+msgid "New size"
+msgstr "Nouvelle taille"
+
+msgid "Enter new size"
+msgstr "Entrer la nouvelle taille"
+
+msgid "New size must be larger than current size"
+msgstr "La nouvelle taille doit être supérieure à la taille actuelle"
+
+msgid "New size exceeds available space"
+msgstr "La nouvelle taille dépasse l'espace disponible"
+
+msgid "Partition resized successfully"
+msgstr "Partition redimensionnée avec succès"
+
+msgid "Failed to resize partition"
+msgstr "Échec du redimensionnement de la partition"
+
+msgid "Failed to resize partition: "
+msgstr "Échec du redimensionnement de la partition : "
+
+msgid "Failed to start partition resize"
+msgstr "Échec du démarrage du redimensionnement de partition"
+
+msgid "Selected partition cannot be resized. Only unmounted Ext2/3/4 partitions with available space can be resized."
+msgstr "La partition sélectionnée ne peut pas être redimensionnée. Seules les partitions Ext2/3/4 non montées avec de l'espace disponible peuvent être redimensionnées."
+
+msgid "MB"
+msgstr "Mo"
+
+msgid "GB"
+msgstr "Go"
+
+msgid "TB"
+msgstr "To"
+
+msgid "Cannot Create Partition"
+msgstr "Impossible de créer la partition"
+
+msgid "Insufficient Space"
+msgstr "Espace insuffisant"
+
+msgid "Cannot read partition information"
+msgstr "Impossible de lire les informations de partition"
+
+msgid "Invalid extended partition"
+msgstr "Partition étendue invalide"
+
+msgid "Extended partition not found or has invalid size"
+msgstr "Partition étendue introuvable ou de taille invalide"
+
+msgid "Extended partition size: %s MB"
+msgstr "Taille de la partition étendue : %s Mo"
+
+msgid "Used by logical partitions: %s MB"
+msgstr "Utilisé par les partitions logiques : %s Mo"
+
+msgid "Available for new logical: %s MB"
+msgstr "Disponible pour une nouvelle logique : %s Mo"
+
+msgid "Required minimum: 10 MB"
+msgstr "Minimum requis : 10 Mo"
+
+msgid "Not enough free space in extended partition /dev/%s"
+msgstr "Pas assez d'espace libre dans la partition étendue /dev/%s"
+
+msgid "Extended partition already exists. You can create primary partitions or select the extended partition to create logical partitions inside."
+msgstr "La partition étendue existe déjà. Vous pouvez créer des partitions primaires ou sélectionner la partition étendue pour créer des partitions logiques à l'intérieur."
+
+msgid "Creating partition inside extended partition. Only logical partitions can be created here."
+msgstr "Création d'une partition à l'intérieur de la partition étendue. Seules les partitions logiques peuvent être créées ici."
+
+msgid "No partition table detected. A primary partition will be created and a partition table will be initialized."
+msgstr "Aucune table de partition détectée. Une partition primaire sera créée et une table de partition sera initialisée."
+
+msgid "No partition table - select to create"
+msgstr "Pas de table de partition - sélectionner pour créer"
+
+msgid "No partitions - select to create"
+msgstr "Pas de partitions - sélectionner pour créer"
+
+msgid "Select to enable partition creation"
+msgstr "Sélectionner pour activer la création de partition"
+
+msgid "Select unallocated space"
+msgstr "Sélectionner l'espace non alloué"
+
+msgid "Unallocated space"
+msgstr "Espace non alloué"
+
+msgid "Expand Ext2/Ext3/Ext4"
+msgstr "Étendre Ext2/Ext3/Ext4"
+
+msgid "Wipe"
+msgstr "Effacer"
+
+msgid "Select all partitions for wiping"
+msgstr "Sélectionner toutes les partitions pour effacement"
+
+msgid "Please enable wipe mode first"
+msgstr "Veuillez d'abord activer le mode effacement"
+
+msgid "Cannot wipe disk with mounted partitions. Please unmount all partitions first."
+msgstr "Impossible d'effacer le disque avec des partitions montées. Veuillez d'abord démonter toutes les partitions."
+
+msgid "Wipe Disk"
+msgstr "Effacer le disque"
+
+msgid "WARNING"
+msgstr "AVERTISSEMENT"
+
+msgid "This will completely erase the partition table and all data on /dev/%s!"
+msgstr "Cela effacera complètement la table de partition et toutes les données sur /dev/%s !"
+
+msgid "THIS OPERATION CANNOT BE UNDONE!"
+msgstr "CETTE OPÉRATION NE PEUT PAS ÊTRE ANNULÉE !"
+
+msgid "Number of partitions to be deleted: %d"
+msgstr "Nombre de partitions à supprimer : %d"
+
+msgid "Are you absolutely sure you want to continue?"
+msgstr "Êtes-vous absolument sûr de vouloir continuer ?"
+
+msgid "Wiping disk partition table..."
+msgstr "Effacement de la table de partition du disque..."
+
+msgid "Disk partition table has been successfully erased"
+msgstr "La table de partition du disque a été effacée avec succès"
+
+msgid "Failed to wipe disk"
+msgstr "Échec de l'effacement du disque"
+
+msgid "Failed to start disk wipe"
+msgstr "Échec du démarrage de l'effacement du disque"
+
+msgid "Failed to wipe disk: "
+msgstr "Échec de l'effacement du disque : "
+
+msgid "Disk Wipe Support"
+msgstr "Support d'effacement de disque"
+
+msgid "Packages required to support disk wiping functionality (clearing partition table)."
+msgstr "Packages requis pour supporter la fonctionnalité d'effacement de disque (suppression de la table de partition)."
+
+msgid "Check Disk Wipe packages"
+msgstr "Vérifier les packages d'effacement de disque"
+
+msgid "Disk Wipe"
+msgstr "Effacement de disque"
+
+msgid "dd from BusyBox"
+msgstr "dd depuis BusyBox"
+
+msgid "Disk Wipe (dd command)"
+msgstr "Effacement de disque (commande dd)"
+
+msgid "alternative"
+msgstr "alternative"
+
+# SMART
+
+msgid "Attribute"
+msgstr "Attribut"
+
+msgid "Id"
+msgstr "Id"
+
+msgid "Raw"
+msgstr "Brut"
+
+msgid "Value"
+msgstr "Valeur"
+
+msgid "Worst"
+msgstr "Pire"
+
+msgid "Thresh"
+msgstr "Seuil"
+
+msgid "Value"
+msgstr "Valeur"
+
+msgid "NVMe S.M.A.R.T. Health Status"
+msgstr "État de santé NVMe S.M.A.R.T."
+
+msgid "OK"
+msgstr "OK"
+
+msgid "WARNING"
+msgstr "AVERTISSEMENT"
+
+msgid "Power On Time"
+msgstr "Temps de fonctionnement"
+
+msgid "Power On Hours"
+msgstr "Heures de fonctionnement"
+
+msgid "Disk Usage"
+msgstr "Utilisation du disque"
+
+msgid "Disk Wear Level"
+msgstr "Niveau d'usure du disque"
+
+msgid "Available Spare"
+msgstr "Réserve disponible"
+
+msgid "Available Spare Threshold"
+msgstr "Seuil de réserve disponible"
+
+msgid "hour"
+msgstr "heure"
+
+msgid "hours"
+msgstr "heures"
+
+msgid "h"
+msgstr "h"
+
+msgid "year"
+msgstr "an"
+
+msgid "years"
+msgstr "ans"
+
+msgid "month"
+msgstr "mois"
+
+msgid "months"
+msgstr "mois"
+
+msgid "day"
+msgstr "jour"
+
+msgid "days"
+msgstr "jours"
+
+msgid "worn"
+msgstr "usé"
+
+msgid "remaining"
+msgstr "restant"
+
+msgid "S.M.A.R.T. Health Status"
+msgstr "État de santé général du disque S.M.A.R.T."
+
+msgid "No S.M.A.R.T. attributes found."
+msgstr "Aucun attribut S.M.A.R.T. trouvé."
+
+msgid "Loading S.M.A.R.T. data..."
+msgstr "Chargement des données S.M.A.R.T..."
+
+msgid "Unable to read S.M.A.R.T. data."
+msgstr "Impossible de lire les données S.M.A.R.T."
+
+msgid "Error reading S.M.A.R.T. data."
+msgstr "Erreur lors de la lecture des données S.M.A.R.T."
+
+# SMART & Disk Info
+
+msgid "Raw Read Error Rate"
+msgstr "Taux d'erreurs de lecture"
+
+msgid "Throughput Performance"
+msgstr "Performance du débit"
+
+msgid "Spin Up Time"
+msgstr "Temps de démarrage"
+
+msgid "Start Stop Count"
+msgstr "Nombre de démarrages/arrêts"
+
+msgid "Reallocated Sector Count"
+msgstr "Nombre de secteurs réalloués"
+
+msgid "Seek Error Rate"
+msgstr "Taux d'erreurs de positionnement"
+
+msgid "Seek Time Performance"
+msgstr "Performance du temps de positionnement"
+
+msgid "Power On Hours"
+msgstr "Heures de fonctionnement"
+
+msgid "Spin Retry Count"
+msgstr "Nombre de tentatives de démarrage"
+
+msgid "Calibration Retry Count"
+msgstr "Nombre de tentatives de calibration"
+
+msgid "Power Cycle Count"
+msgstr "Nombre de cycles d'alimentation"
+
+msgid "Read Soft Error Rate"
+msgstr "Taux d'erreurs de lecture soft"
+
+msgid "Airflow Temperature"
+msgstr "Température du flux d'air"
+
+msgid "Temperature Celsius"
+msgstr "Température"
+
+msgid "Hardware ECC Recovered"
+msgstr "Erreurs ECC récupérées matériellement"
+
+msgid "Current Pending Sector"
+msgstr "Secteurs instables"
+
+msgid "Offline Uncorrectable"
+msgstr "Secteurs non corrigibles hors ligne"
+
+msgid "UDMA CRC Error Count"
+msgstr "Nombre d'erreurs CRC UDMA"
+
+msgid "Multi Zone Error Rate"
+msgstr "Taux d'erreurs multizone"
+
+msgid "Wear Leveling Count"
+msgstr "Compteur d'usure"
+
+msgid "Used Reserved Block Count Total"
+msgstr "Blocs réservés utilisés (total)"
+
+msgid "Used Reserved Block Count Chip"
+msgstr "Blocs réservés utilisés (puce)"
+
+msgid "Unused Reserved Block Count Total"
+msgstr "Blocs réservés non utilisés"
+
+msgid "Program Fail Count Total"
+msgstr "Nombre d'erreurs d'écriture"
+
+msgid "Erase Fail Count Total"
+msgstr "Nombre d'erreurs d'effacement"
+
+msgid "Runtime Bad Block"
+msgstr "Blocs défectueux"
+
+msgid "Uncorrectable Error Count"
+msgstr "Nombre d'erreurs non corrigibles"
+
+msgid "Temperature Exceed Count"
+msgstr "Nombre de dépassements de température"
+
+msgid "Erase Fail Count"
+msgstr "Nombre d'erreurs d'effacement"
+
+msgid "Reported Uncorrectable Errors"
+msgstr "Erreurs non corrigibles signalées"
+
+msgid "High Fly Writes"
+msgstr "Écritures en vol élevé"
+
+msgid "G-Sense Error Rate"
+msgstr "Taux d'erreurs capteur G"
+
+msgid "Power-Off Retract Count"
+msgstr "Nombre de rétractations de têtes à l'arrêt"
+
+msgid "Load Cycle Count"
+msgstr "Nombre de cycles de parking des têtes"
+
+msgid "Temperature Case"
+msgstr "Température du boîtier"
+
+msgid "Reallocated Event Count"
+msgstr "Nombre d'événements de réallocation"
+
+msgid "Transfer Error Rate"
+msgstr "Taux d'erreurs de transfert"
+
+msgid "Free Fall Sensor"
+msgstr "Capteur de chute libre"
+
+msgid "Total LBAs Written"
+msgstr "Total de LBA écrits"
+
+msgid "Total LBAs Read"
+msgstr "Total de LBA lus"
+
+msgid "Read Error Retry Rate"
+msgstr "Taux de tentatives de lecture"
+
+msgid "Minimum W/E Cycle"
+msgstr "Cycle minimum écriture/effacement"
+
+msgid "Maximum W/E Cycle"
+msgstr "Cycle maximum écriture/effacement"
+
+msgid "Average W/E Cycle"
+msgstr "Cycle moyen écriture/effacement"
+
+msgid "Media Wearout Indicator"
+msgstr "Indicateur d'usure du support"
+
+msgid "Available Reserved Space"
+msgstr "Espace réservé disponible"
+
+msgid "SSD Life Left"
+msgstr "Durée de vie restante SSD"
+
+msgid "Remaining Lifetime Percentage"
+msgstr "Pourcentage de durée de vie restante"
+
+msgid "Percentage Lifetime Remaining"
+msgstr "Pourcentage de vie restante"
+
+msgid "Remaining Life"
+msgstr "Durée de vie restante"
+
+msgid "Lifetime Writes GiB"
+msgstr "Données écrites (Gio)"
+
+msgid "Lifetime Reads GiB"
+msgstr "Données lues (Gio)"
+
+msgid "Program Fail Count"
+msgstr "Nombre d'erreurs de programmation"
+
+msgid "Unexpected Power Loss Count"
+msgstr "Nombre de pertes d'alimentation inattendues"
+
+msgid "Thermal Throttle Status"
+msgstr "État de limitation thermique"
+
+msgid "End-to-End Error"
+msgstr "Erreur de bout en bout"
+
+msgid "Workload Host Reads Percentage"
+msgstr "Pourcentage de lectures hôte"
+
+msgid "Workload Media Wear Indicator"
+msgstr "Indicateur d'usure du support (charge de travail)"
+
+msgid "Timed Workload Media Wear"
+msgstr "Usure du support (charge de travail chronométrée)"
+
+msgid "Workload Timer"
+msgstr "Minuteur de charge de travail"
+
+msgid "Percentage Rated Life Used"
+msgstr "Pourcentage de durée de vie utilisée"
+
+msgid "Head Flying Hours"
+msgstr "Heures de vol des têtes"
+
+msgid "Read Channel Margin"
+msgstr "Marge du canal de lecture"
+
+msgid "Loaded Hours"
+msgstr "Heures de fonctionnement déparquées"
+
+msgid "Load/Unload Retry Count"
+msgstr "Nombre de tentatives parking/déparking"
+
+msgid "GMR Head Amplitude"
+msgstr "Amplitude de tête GMR"
+
+msgid "Drive Temperature"
+msgstr "Température du lecteur"
+
+msgid "Endurance Remaining"
+msgstr "Endurance restante"
+
+msgid "Power On Hours and Milliseconds"
+msgstr "Heures de fonctionnement (heures et millisecondes)"
+
+msgid "Head Health"
+msgstr "État des têtes"
+
+msgid "POR Recovery Count"
+msgstr "Nombre de récupérations POR"
+
+msgid "Unused Reserve NAND Blocks"
+msgstr "Blocs NAND réservés non utilisés"
+
+msgid "SSD Protect Mode"
+msgstr "Mode de protection SSD"
+
+msgid "Host Writes 32MiB"
+msgstr "Écritures hôte (32 Mio)"
+
+msgid "NAND Writes 32MiB"
+msgstr "Écritures NAND (32 Mio)"
+
+msgid "Remaining Life Left"
+msgstr "Durée de vie restante"
+
+msgid "Grown Bad Block Count"
+msgstr "Nombre de nouveaux blocs défectueux"
+
+msgid "Soft Read Error Rate"
+msgstr "Taux d'erreurs de lecture soft"
+
+msgid "Data Address Mark Errors"
+msgstr "Erreurs de marqueur d'adresse de données"
+
+msgid "Run Out Cancel"
+msgstr "Annulation de dépassement"
+
+msgid "Soft ECC Correction"
+msgstr "Correction ECC soft"
+
+msgid "TA Increase Count"
+msgstr "Nombre d'augmentations TA"
+
+msgid "Shock Count Write Operation"
+msgstr "Nombre de chocs lors de l'écriture"
+
+msgid "Shock Rate Write Operation"
+msgstr "Taux de chocs lors de l'écriture"
+
+msgid "Flying Height"
+msgstr "Hauteur de vol des têtes"
+
+msgid "Spin High Current"
+msgstr "Courant élevé au démarrage"
+
+msgid "Spin Buzz"
+msgstr "Buzz au démarrage"
+
+msgid "Offline Seek Performance"
+msgstr "Performance de positionnement hors ligne"
+
+msgid "Vibration During Write"
+msgstr "Vibrations lors de l'écriture"
+
+msgid "Shock During Write"
+msgstr "Chocs lors de l'écriture"
+
+msgid "Disk Shift"
+msgstr "Déplacement du disque"
+
+msgid "Load Retry Count"
+msgstr "Nombre de tentatives de chargement"
+
+msgid "Load Friction"
+msgstr "Friction de chargement"
+
+msgid "Load-in Time"
+msgstr "Temps de chargement"
+
+msgid "Torque Amplification Count"
+msgstr "Nombre d'amplifications de couple"
+
+msgid "Write Error Rate"
+msgstr "Taux d'erreurs d'écriture"
+
+msgid "Serial Number"
+msgstr "Numéro de série"
+
+msgid "LU WWN Device Id"
+msgstr "ID de périphérique LU WWN"
+
+msgid "Firmware Version"
+msgstr "Version du micrologiciel"
+
+msgid "User Capacity"
+msgstr "Capacité utilisable"
+
+msgid "Capacity"
+msgstr "Capacité"
+
+msgid "Sector Size"
+msgstr "Taille du secteur"
+
+msgid "Sector Sizes"
+msgstr "Tailles des secteurs"
+
+msgid "Rotation Rate"
+msgstr "Vitesse de rotation"
+
+msgid "Form Factor"
+msgstr "Facteur de forme"
+
+msgid "Device is"
+msgstr "Périphérique"
+
+msgid "ATA Version is"
+msgstr "Version ATA"
+
+msgid "SATA Version is"
+msgstr "Version SATA"
+
+msgid "Local Time is"
+msgstr "Heure locale"
+
+msgid "SMART support is"
+msgstr "Support SMART"
+
+msgid "SMART Status"
+msgstr "État SMART"
+
+msgid "Device"
+msgstr "Périphérique"
+
+msgid "Model Number"
+msgstr "Modèle"
+
+msgid "Firmware Revision"
+msgstr "Révision du micrologiciel"
+
+msgid "PCI Vendor/Subsystem ID"
+msgstr "ID fournisseur/sous-système PCI"
+
+msgid "IEEE OUI Identifier"
+msgstr "Identifiant IEEE OUI"
+
+msgid "Total NVM Capacity"
+msgstr "Capacité totale NVM"
+
+msgid "Unallocated NVM Capacity"
+msgstr "Capacité NVM non allouée"
+
+msgid "Controller ID"
+msgstr "ID du contrôleur"
+
+msgid "Number of Namespaces"
+msgstr "Nombre d'espaces d'adressage"
+
+msgid "Namespace 1 Size/Capacity"
+msgstr "Taille/capacité de l'espace d'adressage 1"
+
+msgid "Namespace 1 Formatted LBA Size"
+msgstr "Taille LBA de l'espace d'adressage 1"
+
+msgid "Namespace 1 IEEE EUI-64"
+msgstr "IEEE EUI-64 de l'espace d'adressage 1"
+
+msgid "logical/physical"
+msgstr "logique/physique"
+
+msgid "bytes"
+msgstr "octets"
+
+msgid "blocks"
+msgstr "blocs"
+
+msgid "Solid State Device"
+msgstr "Disque SSD"
+
+# Reserved space
+
+msgid "Reserved space"
+msgstr "Espace réservé"
+
+msgid "Space reserved for root (default: 5%)"
+msgstr "Espace réservé pour root (par défaut : 5%)"
+
+msgid "Used Reserved Block Count Total"
+msgstr "Nombre total de blocs réservés utilisés"
+
+msgid "Used Reserved Block Count Chip"
+msgstr "Nombre de blocs réservés utilisés par puce"
+
+msgid "Unused Reserved Block Count Total"
+msgstr "Nombre total de blocs réservés inutilisés"
+
+msgid "Available Reserved Space"
+msgstr "Espace réservé disponible"
+
+# NVMe
+
+msgid "Critical Warning"
+msgstr "Avertissement critique"
+
+msgid "Percentage Used"
+msgstr "Pourcentage utilisé"
+
+msgid "Data Units Read"
+msgstr "Unités de données lues"
+
+msgid "Data Units Written"
+msgstr "Unités de données écrites"
+
+msgid "Host Read Commands"
+msgstr "Commandes de lecture hôte"
+
+msgid "Host Write Commands"
+msgstr "Commandes d'écriture hôte"
+
+msgid "Controller Busy Time"
+msgstr "Temps d'occupation du contrôleur"
+
+msgid "Power Cycles"
+msgstr "Cycles d'alimentation"
+
+msgid "Unsafe Shutdowns"
+msgstr "Arrêts non sécurisés"
+
+msgid "Media Errors"
+msgstr "Erreurs du support"
+
+msgid "Error Log Entries"
+msgstr "Entrées du journal d'erreurs"
diff --git a/package/luci-app-mini-diskmanager/po/it/mini-diskmanager.po b/package/luci-app-mini-diskmanager/po/it/mini-diskmanager.po
new file mode 100644
index 0000000000..39350a4761
--- /dev/null
+++ b/package/luci-app-mini-diskmanager/po/it/mini-diskmanager.po
@@ -0,0 +1,1247 @@
+msgid ""
+msgstr ""
+"Project-Id-Version: luci-app-mini-diskmanager\n"
+"Language-Team: Rafał Wabik (IceG)\n"
+
+msgid "Disk Manager"
+msgstr "Gestione Dischi"
+
+msgid "-- Select a disk --"
+msgstr "-- Seleziona un disco --"
+
+msgid "Disk"
+msgstr "Disco"
+
+msgid "Refresh"
+msgstr "Aggiorna"
+
+msgid "Mounting actions"
+msgstr "Azioni di montaggio"
+
+msgid "Actions on partitions"
+msgstr "Operazioni sulle partizioni"
+
+msgid "Mount"
+msgstr "Monta"
+
+msgid "Unmount"
+msgstr "Smonta"
+
+msgid "Create"
+msgstr "Crea"
+
+msgid "Delete"
+msgstr "Elimina"
+
+msgid "Format"
+msgstr "Formatta"
+
+msgid "Please select a disk to view its partitions"
+msgstr "Seleziona un disco per visualizzare le sue partizioni"
+
+msgid "Please select a disk first"
+msgstr "Seleziona prima un disco"
+
+msgid "Please select a partition first"
+msgstr "Seleziona prima una partizione"
+
+msgid "Loading disk information..."
+msgstr "Caricamento informazioni disco..."
+
+msgid "Error loading disk information: "
+msgstr "Errore nel caricamento delle informazioni del disco: "
+
+msgid "Disk Information"
+msgstr "Informazioni disco"
+
+msgid "Temperature"
+msgstr "Temperatura"
+
+msgid "S.M.A.R.T."
+msgstr "S.M.A.R.T."
+
+msgid "S.M.A.R.T. Status"
+msgstr "Stato S.M.A.R.T."
+
+msgid "Partitions"
+msgstr "Partizioni"
+
+msgid "Mount Status"
+msgstr "Stato montaggio"
+
+msgid "Mounted"
+msgstr "Montato"
+
+msgid "Not mounted"
+msgstr "Non montato"
+
+msgid "Partition Layout"
+msgstr "Layout partizioni"
+
+msgid "Partition"
+msgstr "Partizione"
+
+msgid "Type / Filesystem"
+msgstr "Tipo / Filesystem"
+
+msgid "Mount Point"
+msgstr "Punto di montaggio"
+
+msgid "Label"
+msgstr "Etichetta"
+
+msgid "Size"
+msgstr "Dimensione"
+
+msgid "Used"
+msgstr "Utilizzato"
+
+msgid "Unused"
+msgstr "Libero"
+
+msgid "Flags"
+msgstr "Flag"
+
+msgid "No partitions found"
+msgstr "Nessuna partizione trovata"
+
+msgid "Unallocated"
+msgstr "Non allocato"
+
+msgid "Area without partition table"
+msgstr "Area senza tabella partizioni"
+
+msgid "Free Space"
+msgstr "Spazio libero"
+
+msgid "Primary"
+msgstr "Primaria"
+
+msgid "Extended"
+msgstr "Estesa"
+
+msgid "Logical"
+msgstr "Logica"
+
+msgid "Create partition"
+msgstr "Crea partizione"
+
+msgid "Cancel"
+msgstr "Annulla"
+
+msgid "File system"
+msgstr "File system"
+
+msgid "Volume label"
+msgstr "Etichetta volume"
+
+msgid "Partition size"
+msgstr "Dimensione partizione"
+
+msgid "Enter size"
+msgstr "Inserisci dimensione"
+
+msgid "Use all available space"
+msgstr "Usa tutto lo spazio disponibile"
+
+msgid "Available: %s MB / %s GB / %s TB"
+msgstr "Disponibile: %s MB / %s GB / %s TB"
+
+msgid "Please enter a valid size"
+msgstr "Inserisci una dimensione valida"
+
+msgid "Size is too small"
+msgstr "La dimensione è troppo piccola"
+
+msgid "Creating partition..."
+msgstr "Creazione partizione..."
+
+msgid "Partition created successfully"
+msgstr "Partizione creata con successo"
+
+msgid "Failed to create partition"
+msgstr "Impossibile creare la partizione"
+
+msgid "Format Partition"
+msgstr "Formatta partizione"
+
+msgid "Warning"
+msgstr "Avviso"
+
+msgid "This will erase all data on /dev/%s"
+msgstr "Questo cancellerà tutti i dati su /dev/%s"
+
+msgid "Formatting partition..."
+msgstr "Formattazione partizione..."
+
+msgid "Partition formatted successfully"
+msgstr "Partizione formattata con successo"
+
+msgid "Failed to format partition"
+msgstr "Impossibile formattare la partizione"
+
+msgid "Delete Partition"
+msgstr "Elimina partizione"
+
+msgid "Are you sure you want to continue?"
+msgstr "Sei sicuro di voler continuare?"
+
+msgid "Deleting partition..."
+msgstr "Eliminazione partizione..."
+
+msgid "Partition deleted successfully"
+msgstr "Partizione eliminata con successo"
+
+msgid "Failed to delete partition"
+msgstr "Impossibile eliminare la partizione"
+
+msgid "No partitions to mount"
+msgstr "Nessuna partizione da montare"
+
+msgid "No mounted partitions found"
+msgstr "Nessuna partizione montata trovata"
+
+msgid "No partitions to unmount"
+msgstr "Nessuna partizione da smontare"
+
+msgid "Mounted to %s"
+msgstr "Montato su %s"
+
+msgid "Unmounted %s"
+msgstr "Smontato %s"
+
+msgid "Failed to mount: "
+msgstr "Impossibile montare: "
+
+msgid "Failed to unmount: "
+msgstr "Impossibile smontare: "
+
+msgid "Failed to check operation status: "
+msgstr "Impossibile verificare lo stato dell'operazione: "
+
+msgid "Partition created but device node did not appear in time"
+msgstr "Partizione creata ma il nodo del dispositivo non è apparso in tempo"
+
+msgid "Partition created but device node did not appear; please refresh manually"
+msgstr "Partizione creata ma il nodo del dispositivo non è apparso; aggiorna manualmente"
+
+msgid "PASSED"
+msgstr "SUPERATO"
+
+msgid "FAILED"
+msgstr "FALLITO"
+
+msgid "Cannot create partition on mounted disk. Please unmount first."
+msgstr "Impossibile creare la partizione su disco montato. Smontare prima."
+
+msgid "No unallocated space available on this disk"
+msgstr "Nessuno spazio non allocato disponibile su questo disco"
+
+msgid "Cannot format mounted partition. Please unmount first."
+msgstr "Impossibile formattare la partizione montata. Smontare prima."
+
+msgid "Failed to refresh partition data: "
+msgstr "Impossibile aggiornare i dati della partizione: "
+
+msgid "Cannot delete partition on mounted disk. Please unmount first."
+msgstr "Impossibile eliminare la partizione su disco montato. Smontare prima."
+
+msgid "This will delete partition /dev/%s and all its data!"
+msgstr "Questo eliminerà la partizione /dev/%s e tutti i suoi dati!"
+
+msgid "Failed to load disk information: "
+msgstr "Impossibile caricare le informazioni del disco: "
+
+msgid "Click to select"
+msgstr "Clicca per selezionare"
+
+msgid "System partition cannot be selected"
+msgstr "La partizione di sistema non può essere selezionata"
+
+msgid "Free"
+msgstr "Libero"
+
+msgid "Select a disk"
+msgstr "Seleziona un disco"
+
+msgid "Create a new partition on the selected disk"
+msgstr "Crea una nuova partizione sul disco selezionato"
+
+msgid "Partition layout"
+msgstr "Layout partizioni"
+
+msgid "Partition type"
+msgstr "Tipo partizione"
+
+msgid "Refresh partition data"
+msgstr "Aggiorna dati partizioni"
+
+msgid "MBR (Master Boot Record)"
+msgstr "MBR (Master Boot Record)"
+
+msgid "GPT (GUID Partition Table)"
+msgstr "GPT (Tabella Partizioni GUID)"
+
+msgid "The Mini Disk Manager package allows users to easily manage disks and partitions."
+msgstr "Il pacchetto Mini Disk Manager consente agli utenti di gestire facilmente dischi e partizioni."
+
+msgid "Configuration"
+msgstr "Configurazione"
+
+msgid "Package and Driver Verification"
+msgstr "Verifica pacchetti e driver"
+
+msgid "Check and install required drivers for storage devices."
+msgstr "Controlla e installa i driver necessari per i dispositivi di archiviazione."
+
+msgid "Filesystem Support"
+msgstr "Supporto filesystem"
+
+msgid "Check USB drivers"
+msgstr "Controlla driver USB"
+
+msgid "USB drivers"
+msgstr "Driver USB"
+
+msgid "Check NVMe drivers"
+msgstr "Controlla driver NVMe"
+
+msgid "NVMe drivers"
+msgstr "Driver NVMe"
+
+msgid "Check ATA/SATA drivers"
+msgstr "Controlla driver ATA/SATA"
+
+msgid "ATA/SATA drivers"
+msgstr "Driver ATA/SATA"
+
+msgid "Check Linux filesystem packages"
+msgstr "Controlla pacchetti filesystem Linux"
+
+msgid "Linux filesystems"
+msgstr "Filesystem Linux"
+
+msgid "Check Windows filesystem packages"
+msgstr "Controlla pacchetti filesystem Windows"
+
+msgid "Windows filesystems"
+msgstr "Filesystem Windows"
+
+msgid "Linux Filesystem Packages"
+msgstr "Pacchetti filesystem Linux"
+
+msgid "Windows Filesystem Packages"
+msgstr "Pacchetti filesystem Windows"
+
+msgid "Disk Manager Log"
+msgstr "Log gestione dischi"
+
+msgid "Loading package data…"
+msgstr "Caricamento dati pacchetti…"
+
+msgid "Loading log file…"
+msgstr "Caricamento file di log…"
+
+msgid "Log file content"
+msgstr "Contenuto file di log"
+
+msgid "Log file is empty"
+msgstr "Il file di log è vuoto"
+
+msgid "Unable to read log file"
+msgstr "Impossibile leggere il file di log"
+
+msgid "Log file cleared successfully"
+msgstr "File di log cancellato con successo"
+
+msgid "Unable to clear the file"
+msgstr "Impossibile cancellare il file"
+
+msgid "Installed"
+msgstr "Installato"
+
+msgid "Install…"
+msgstr "Installa…"
+
+msgid "Clear"
+msgstr "Cancella"
+
+msgid "Download"
+msgstr "Scarica"
+
+msgid "Close"
+msgstr "Chiudi"
+
+msgid "Failed to load package data"
+msgstr "Impossibile caricare i dati del pacchetto"
+
+msgid "more info in log"
+msgstr "maggiori informazioni nel log"
+
+msgid "The tab allows users to support the package."
+msgstr "La scheda consente agli utenti di supportare il pacchetto."
+
+msgid "Package support"
+msgstr "Supporto pacchetto"
+
+msgid "Mini Disk Manager Info"
+msgstr "Informazioni Mini Disk Manager"
+
+msgid "Luci-app-mdmanager"
+msgstr "Luci-app-mdmanager"
+
+msgid "Buy a coffee"
+msgstr "Offrimi un caffè"
+
+msgid "Buy a coffee if you want to support the development of the project and the author"
+msgstr "Offrimi un caffè se vuoi supportare lo sviluppo del progetto e l'autore"
+
+msgid "Become a sponsor"
+msgstr "Diventa sponsor"
+
+msgid "Become a sponsor if you want to support the development of the project and the author"
+msgstr "Diventa sponsor se vuoi supportare lo sviluppo del progetto e l'autore"
+
+msgid "Write on forum"
+msgstr "Scrivi sul forum"
+
+msgid "Write in the topic of the package on the forum eko.one.pl"
+msgstr "Scrivi nell'argomento del pacchetto sul forum eko.one.pl"
+
+msgid "Open discussion"
+msgstr "Apri discussione"
+
+msgid "Open a package discussion on Github"
+msgstr "Apri una discussione sul pacchetto su Github"
+
+msgid "Report a bug"
+msgstr "Segnala un bug"
+
+msgid "Report a bug on the package Github page"
+msgstr "Segnala un bug nella pagina Github del pacchetto"
+
+msgid "Package name"
+msgstr "Nome pacchetto"
+
+msgid "Author (package maintainer)"
+msgstr "Autore (manutentore pacchetto)"
+
+msgid "Information about package author and available support options."
+msgstr "Informazioni sull'autore del pacchetto e opzioni di supporto disponibili."
+
+# --
+
+msgid "All available space"
+msgstr "Tutto lo spazio disponibile"
+
+msgid "Cannot delete mounted partition. Please unmount first."
+msgstr "Impossibile eliminare la partizione montata. Smontare prima."
+
+msgid "Failed to create partition: "
+msgstr "Impossibile creare la partizione: "
+
+msgid "Failed to detect supported filesystems"
+msgstr "Impossibile rilevare i filesystem supportati"
+
+msgid "Failed to format partition: "
+msgstr "Impossibile formattare la partizione: "
+
+msgid "Failed to parse JSON response: "
+msgstr "Impossibile analizzare la risposta JSON: "
+
+msgid "Failed to start formatting"
+msgstr "Impossibile avviare la formattazione"
+
+msgid "Failed to start partition creation"
+msgstr "Impossibile avviare la creazione della partizione"
+
+msgid "Failed to start partition deletion"
+msgstr "Impossibile avviare l'eliminazione della partizione"
+
+msgid "Fill in size"
+msgstr "Inserisci dimensione"
+
+msgid "Linux Swap"
+msgstr "Linux Swap"
+
+msgid "Loading..."
+msgstr "Caricamento..."
+
+msgid "No filesystem packages detected — user cannot choose unsupported filesystem formats."
+msgstr "Nessun pacchetto filesystem rilevato — l'utente non può scegliere formati filesystem non supportati."
+
+msgid "No partition types available. Maximum partitions reached."
+msgstr "Nessun tipo di partizione disponibile. Numero massimo di partizioni raggiunto."
+
+msgid "No supported filesystems detected on this system"
+msgstr "Nessun filesystem supportato rilevato su questo sistema"
+
+msgid "Optional"
+msgstr "Facoltativo"
+
+msgid "Partition created but selected filesystem is not available for formatting on this system"
+msgstr "Partizione creata ma il filesystem selezionato non è disponibile per la formattazione su questo sistema"
+
+msgid "Partition data refreshed"
+msgstr "Dati partizione aggiornati"
+
+msgid "Please select a filesystem"
+msgstr "Seleziona un filesystem"
+
+msgid "RPC call failed: "
+msgstr "Chiamata RPC fallita: "
+
+msgid "Refreshing..."
+msgstr "Aggiornamento..."
+
+msgid "Selected filesystem is not supported on this system"
+msgstr "Il filesystem selezionato non è supportato su questo sistema"
+
+msgid "Selected partition is not mounted"
+msgstr "La partizione selezionata non è montata"
+
+msgid "unknown error"
+msgstr "errore sconosciuto"
+
+msgid "Packages & Drivers"
+msgstr "Pacchetti e driver"
+
+msgid "Mini Disk Manager log"
+msgstr "Log Mini Disk Manager"
+
+msgid "Mini Disk Manager Log"
+msgstr "Log Mini Disk Manager"
+
+msgid "Packages required to support various file systems."
+msgstr "Pacchetti necessari per supportare vari file system."
+
+msgid "Expand"
+msgstr "Espandi"
+
+msgid "Resize"
+msgstr "Ridimensiona"
+
+msgid "Resize Partition"
+msgstr "Ridimensiona partizione"
+
+msgid "Resize partition /dev/%s"
+msgstr "Ridimensiona partizione /dev/%s"
+
+msgid "Resizing partition..."
+msgstr "Ridimensionamento partizione..."
+
+msgid "Resizing a partition can cause data loss if not done correctly."
+msgstr "Il ridimensionamento di una partizione può causare perdita di dati se non eseguito correttamente."
+
+msgid "Please ensure you have a backup of important data before proceeding."
+msgstr "Assicurarsi di avere un backup dei dati importanti prima di procedere."
+
+msgid "Current size: %s MB / %s GB / %s TB"
+msgstr "Dimensione attuale: %s MB / %s GB / %s TB"
+
+msgid "Available space: %s MB / %s GB / %s TB"
+msgstr "Spazio disponibile: %s MB / %s GB / %s TB"
+
+msgid "Maximum size to be obtained: %s MB / %s GB / %s TB"
+msgstr "Dimensione massima ottenibile: %s MB / %s GB / %s TB"
+
+msgid "Maximum new size"
+msgstr "Nuova dimensione massima"
+
+msgid "New size"
+msgstr "Nuova dimensione"
+
+msgid "Enter new size"
+msgstr "Inserisci nuova dimensione"
+
+msgid "New size must be larger than current size"
+msgstr "La nuova dimensione deve essere maggiore della dimensione attuale"
+
+msgid "New size exceeds available space"
+msgstr "La nuova dimensione supera lo spazio disponibile"
+
+msgid "Partition resized successfully"
+msgstr "Partizione ridimensionata con successo"
+
+msgid "Failed to resize partition"
+msgstr "Impossibile ridimensionare la partizione"
+
+msgid "Failed to resize partition: "
+msgstr "Impossibile ridimensionare la partizione: "
+
+msgid "Failed to start partition resize"
+msgstr "Impossibile avviare il ridimensionamento della partizione"
+
+msgid "Selected partition cannot be resized. Only unmounted Ext2/3/4 partitions with available space can be resized."
+msgstr "La partizione selezionata non può essere ridimensionata. Solo le partizioni Ext2/3/4 smontate con spazio disponibile possono essere ridimensionate."
+
+msgid "MB"
+msgstr "MB"
+
+msgid "GB"
+msgstr "GB"
+
+msgid "TB"
+msgstr "TB"
+
+msgid "Cannot Create Partition"
+msgstr "Impossibile creare la partizione"
+
+msgid "Insufficient Space"
+msgstr "Spazio insufficiente"
+
+msgid "Cannot read partition information"
+msgstr "Impossibile leggere le informazioni della partizione"
+
+msgid "Invalid extended partition"
+msgstr "Partizione estesa non valida"
+
+msgid "Extended partition not found or has invalid size"
+msgstr "Partizione estesa non trovata o ha dimensione non valida"
+
+msgid "Extended partition size: %s MB"
+msgstr "Dimensione partizione estesa: %s MB"
+
+msgid "Used by logical partitions: %s MB"
+msgstr "Utilizzato dalle partizioni logiche: %s MB"
+
+msgid "Available for new logical: %s MB"
+msgstr "Disponibile per nuova logica: %s MB"
+
+msgid "Required minimum: 10 MB"
+msgstr "Minimo richiesto: 10 MB"
+
+msgid "Not enough free space in extended partition /dev/%s"
+msgstr "Spazio libero insufficiente nella partizione estesa /dev/%s"
+
+msgid "Extended partition already exists. You can create primary partitions or select the extended partition to create logical partitions inside."
+msgstr "La partizione estesa esiste già. Puoi creare partizioni primarie o selezionare la partizione estesa per creare partizioni logiche all'interno."
+
+msgid "Creating partition inside extended partition. Only logical partitions can be created here."
+msgstr "Creazione partizione all'interno della partizione estesa. Qui possono essere create solo partizioni logiche."
+
+msgid "No partition table detected. A primary partition will be created and a partition table will be initialized."
+msgstr "Nessuna tabella partizioni rilevata. Verrà creata una partizione primaria e inizializzata una tabella partizioni."
+
+msgid "No partition table - select to create"
+msgstr "Nessuna tabella partizioni - seleziona per creare"
+
+msgid "No partitions - select to create"
+msgstr "Nessuna partizione - seleziona per creare"
+
+msgid "Select to enable partition creation"
+msgstr "Seleziona per abilitare la creazione della partizione"
+
+msgid "Select unallocated space"
+msgstr "Seleziona spazio non allocato"
+
+msgid "Unallocated space"
+msgstr "Spazio non allocato"
+
+msgid "Expand Ext2/Ext3/Ext4"
+msgstr "Espandi Ext2/Ext3/Ext4"
+
+msgid "Wipe"
+msgstr "Cancella"
+
+msgid "Select all partitions for wiping"
+msgstr "Seleziona tutte le partizioni per la cancellazione"
+
+msgid "Please enable wipe mode first"
+msgstr "Abilita prima la modalità di cancellazione"
+
+msgid "Cannot wipe disk with mounted partitions. Please unmount all partitions first."
+msgstr "Impossibile cancellare il disco con partizioni montate. Smonta prima tutte le partizioni."
+
+msgid "Wipe Disk"
+msgstr "Cancella disco"
+
+msgid "WARNING"
+msgstr "AVVISO"
+
+msgid "This will completely erase the partition table and all data on /dev/%s!"
+msgstr "Questo cancellerà completamente la tabella delle partizioni e tutti i dati su /dev/%s!"
+
+msgid "All partitions will be deleted and the disk will be unallocated."
+msgstr "Tutte le partizioni verranno eliminate e il disco sarà non allocato."
+
+msgid "THIS OPERATION CANNOT BE UNDONE!"
+msgstr "QUESTA OPERAZIONE NON PUÒ ESSERE ANNULLATA!"
+
+msgid "Number of partitions to be deleted: %d"
+msgstr "Numero di partizioni da eliminare: %d"
+
+msgid "Are you absolutely sure you want to continue?"
+msgstr "Sei assolutamente sicuro di voler continuare?"
+
+msgid "Wiping disk partition table..."
+msgstr "Cancellazione tabella partizioni disco..."
+
+msgid "Disk partition table has been successfully erased"
+msgstr "La tabella delle partizioni del disco è stata cancellata con successo"
+
+msgid "Failed to wipe disk"
+msgstr "Impossibile cancellare il disco"
+
+msgid "Failed to start disk wipe"
+msgstr "Impossibile avviare la cancellazione del disco"
+
+msgid "Failed to wipe disk: "
+msgstr "Impossibile cancellare il disco: "
+
+msgid "Disk Wipe Support"
+msgstr "Supporto cancellazione disco"
+
+msgid "Packages required to support disk wiping functionality (clearing partition table)."
+msgstr "Pacchetti necessari per supportare la funzionalità di cancellazione del disco (cancellazione della tabella delle partizioni)."
+
+msgid "Check Disk Wipe packages"
+msgstr "Verifica pacchetti cancellazione disco"
+
+msgid "Disk Wipe"
+msgstr "Cancellazione disco"
+
+msgid "dd from BusyBox"
+msgstr "dd da BusyBox"
+
+msgid "Disk Wipe (dd command)"
+msgstr "Cancellazione disco (comando dd)"
+
+msgid "alternative"
+msgstr "alternativa"
+
+# SMART
+
+msgid "Attribute"
+msgstr "Attributo"
+
+msgid "Id"
+msgstr "Id"
+
+msgid "Raw"
+msgstr "Grezzo"
+
+msgid "Value"
+msgstr "Valore"
+
+msgid "Worst"
+msgstr "Peggiore"
+
+msgid "Thresh"
+msgstr "Soglia"
+
+msgid "Value"
+msgstr "Valore"
+
+msgid "NVMe S.M.A.R.T. Health Status"
+msgstr "Stato di salute NVMe S.M.A.R.T."
+
+msgid "OK"
+msgstr "OK"
+
+msgid "WARNING"
+msgstr "AVVISO"
+
+msgid "Power On Time"
+msgstr "Tempo di funzionamento"
+
+msgid "Power On Hours"
+msgstr "Ore di funzionamento"
+
+msgid "Disk Usage"
+msgstr "Utilizzo del disco"
+
+msgid "Disk Wear Level"
+msgstr "Livello di usura del disco"
+
+msgid "Available Spare"
+msgstr "Riserva disponibile"
+
+msgid "Available Spare Threshold"
+msgstr "Soglia di riserva disponibile"
+
+msgid "hour"
+msgstr "ora"
+
+msgid "hours"
+msgstr "ore"
+
+msgid "h"
+msgstr "h"
+
+msgid "year"
+msgstr "anno"
+
+msgid "years"
+msgstr "anni"
+
+msgid "month"
+msgstr "mese"
+
+msgid "months"
+msgstr "mesi"
+
+msgid "day"
+msgstr "giorno"
+
+msgid "days"
+msgstr "giorni"
+
+msgid "worn"
+msgstr "consumato"
+
+msgid "remaining"
+msgstr "rimanente"
+
+msgid "S.M.A.R.T. Health Status"
+msgstr "Stato di salute generale del disco S.M.A.R.T."
+
+msgid "No S.M.A.R.T. attributes found."
+msgstr "Nessun attributo S.M.A.R.T. trovato."
+
+msgid "Loading S.M.A.R.T. data..."
+msgstr "Caricamento dati S.M.A.R.T..."
+
+msgid "Unable to read S.M.A.R.T. data."
+msgstr "Impossibile leggere i dati S.M.A.R.T."
+
+msgid "Error reading S.M.A.R.T. data."
+msgstr "Errore nella lettura dei dati S.M.A.R.T."
+
+# SMART & Disk Info
+
+msgid "Raw Read Error Rate"
+msgstr "Taux d'erreurs de lecture"
+
+msgid "Throughput Performance"
+msgstr "Performance du débit"
+
+msgid "Spin Up Time"
+msgstr "Temps de démarrage"
+
+msgid "Start Stop Count"
+msgstr "Nombre de démarrages/arrêts"
+
+msgid "Reallocated Sector Count"
+msgstr "Nombre de secteurs réalloués"
+
+msgid "Seek Error Rate"
+msgstr "Taux d'erreurs de positionnement"
+
+msgid "Seek Time Performance"
+msgstr "Performance du temps de positionnement"
+
+msgid "Power On Hours"
+msgstr "Heures de fonctionnement"
+
+msgid "Spin Retry Count"
+msgstr "Nombre de tentatives de démarrage"
+
+msgid "Calibration Retry Count"
+msgstr "Nombre de tentatives de calibration"
+
+msgid "Power Cycle Count"
+msgstr "Nombre de cycles d'alimentation"
+
+msgid "Read Soft Error Rate"
+msgstr "Taux d'erreurs de lecture soft"
+
+msgid "Airflow Temperature"
+msgstr "Température du flux d'air"
+
+msgid "Temperature Celsius"
+msgstr "Température"
+
+msgid "Hardware ECC Recovered"
+msgstr "Erreurs ECC récupérées matériellement"
+
+msgid "Current Pending Sector"
+msgstr "Secteurs instables"
+
+msgid "Offline Uncorrectable"
+msgstr "Secteurs non corrigibles hors ligne"
+
+msgid "UDMA CRC Error Count"
+msgstr "Nombre d'erreurs CRC UDMA"
+
+msgid "Multi Zone Error Rate"
+msgstr "Taux d'erreurs multizone"
+
+msgid "Wear Leveling Count"
+msgstr "Compteur d'usure"
+
+msgid "Used Reserved Block Count Total"
+msgstr "Blocs réservés utilisés (total)"
+
+msgid "Used Reserved Block Count Chip"
+msgstr "Blocs réservés utilisés (puce)"
+
+msgid "Unused Reserved Block Count Total"
+msgstr "Blocs réservés non utilisés"
+
+msgid "Program Fail Count Total"
+msgstr "Nombre d'erreurs d'écriture"
+
+msgid "Erase Fail Count Total"
+msgstr "Nombre d'erreurs d'effacement"
+
+msgid "Runtime Bad Block"
+msgstr "Blocs défectueux"
+
+msgid "Uncorrectable Error Count"
+msgstr "Nombre d'erreurs non corrigibles"
+
+msgid "Temperature Exceed Count"
+msgstr "Nombre de dépassements de température"
+
+msgid "Erase Fail Count"
+msgstr "Nombre d'erreurs d'effacement"
+
+msgid "Reported Uncorrectable Errors"
+msgstr "Erreurs non corrigibles signalées"
+
+msgid "High Fly Writes"
+msgstr "Écritures en vol élevé"
+
+msgid "G-Sense Error Rate"
+msgstr "Taux d'erreurs capteur G"
+
+msgid "Power-Off Retract Count"
+msgstr "Nombre de rétractations de têtes à l'arrêt"
+
+msgid "Load Cycle Count"
+msgstr "Nombre de cycles de parking des têtes"
+
+msgid "Temperature Case"
+msgstr "Température du boîtier"
+
+msgid "Reallocated Event Count"
+msgstr "Nombre d'événements de réallocation"
+
+msgid "Transfer Error Rate"
+msgstr "Taux d'erreurs de transfert"
+
+msgid "Free Fall Sensor"
+msgstr "Capteur de chute libre"
+
+msgid "Total LBAs Written"
+msgstr "Total de LBA écrits"
+
+msgid "Total LBAs Read"
+msgstr "Total de LBA lus"
+
+msgid "Read Error Retry Rate"
+msgstr "Taux de tentatives de lecture"
+
+msgid "Minimum W/E Cycle"
+msgstr "Cycle minimum écriture/effacement"
+
+msgid "Maximum W/E Cycle"
+msgstr "Cycle maximum écriture/effacement"
+
+msgid "Average W/E Cycle"
+msgstr "Cycle moyen écriture/effacement"
+
+msgid "Media Wearout Indicator"
+msgstr "Indicateur d'usure du support"
+
+msgid "Available Reserved Space"
+msgstr "Espace réservé disponible"
+
+msgid "SSD Life Left"
+msgstr "Durée de vie restante SSD"
+
+msgid "Remaining Lifetime Percentage"
+msgstr "Pourcentage de durée de vie restante"
+
+msgid "Percentage Lifetime Remaining"
+msgstr "Pourcentage de vie restante"
+
+msgid "Remaining Life"
+msgstr "Durée de vie restante"
+
+msgid "Lifetime Writes GiB"
+msgstr "Données écrites (Gio)"
+
+msgid "Lifetime Reads GiB"
+msgstr "Données lues (Gio)"
+
+msgid "Program Fail Count"
+msgstr "Nombre d'erreurs de programmation"
+
+msgid "Unexpected Power Loss Count"
+msgstr "Nombre de pertes d'alimentation inattendues"
+
+msgid "Thermal Throttle Status"
+msgstr "État de limitation thermique"
+
+msgid "End-to-End Error"
+msgstr "Erreur de bout en bout"
+
+msgid "Workload Host Reads Percentage"
+msgstr "Pourcentage de lectures hôte"
+
+msgid "Workload Media Wear Indicator"
+msgstr "Indicateur d'usure du support (charge de travail)"
+
+msgid "Timed Workload Media Wear"
+msgstr "Usure du support (charge de travail chronométrée)"
+
+msgid "Workload Timer"
+msgstr "Minuteur de charge de travail"
+
+msgid "Percentage Rated Life Used"
+msgstr "Pourcentage de durée de vie utilisée"
+
+msgid "Head Flying Hours"
+msgstr "Heures de vol des têtes"
+
+msgid "Read Channel Margin"
+msgstr "Marge du canal de lecture"
+
+msgid "Loaded Hours"
+msgstr "Heures de fonctionnement déparquées"
+
+msgid "Load/Unload Retry Count"
+msgstr "Nombre de tentatives parking/déparking"
+
+msgid "GMR Head Amplitude"
+msgstr "Amplitude de tête GMR"
+
+msgid "Drive Temperature"
+msgstr "Température du lecteur"
+
+msgid "Endurance Remaining"
+msgstr "Endurance restante"
+
+msgid "Power On Hours and Milliseconds"
+msgstr "Heures de fonctionnement (heures et millisecondes)"
+
+msgid "Head Health"
+msgstr "État des têtes"
+
+msgid "POR Recovery Count"
+msgstr "Nombre de récupérations POR"
+
+msgid "Unused Reserve NAND Blocks"
+msgstr "Blocs NAND réservés non utilisés"
+
+msgid "SSD Protect Mode"
+msgstr "Mode de protection SSD"
+
+msgid "Host Writes 32MiB"
+msgstr "Écritures hôte (32 Mio)"
+
+msgid "NAND Writes 32MiB"
+msgstr "Écritures NAND (32 Mio)"
+
+msgid "Remaining Life Left"
+msgstr "Durée de vie restante"
+
+msgid "Grown Bad Block Count"
+msgstr "Nombre de nouveaux blocs défectueux"
+
+msgid "Soft Read Error Rate"
+msgstr "Taux d'erreurs de lecture soft"
+
+msgid "Data Address Mark Errors"
+msgstr "Erreurs de marqueur d'adresse de données"
+
+msgid "Run Out Cancel"
+msgstr "Annulation de dépassement"
+
+msgid "Soft ECC Correction"
+msgstr "Correction ECC soft"
+
+msgid "TA Increase Count"
+msgstr "Nombre d'augmentations TA"
+
+msgid "Shock Count Write Operation"
+msgstr "Nombre de chocs lors de l'écriture"
+
+msgid "Shock Rate Write Operation"
+msgstr "Taux de chocs lors de l'écriture"
+
+msgid "Flying Height"
+msgstr "Hauteur de vol des têtes"
+
+msgid "Spin High Current"
+msgstr "Courant élevé au démarrage"
+
+msgid "Spin Buzz"
+msgstr "Buzz au démarrage"
+
+msgid "Offline Seek Performance"
+msgstr "Performance de positionnement hors ligne"
+
+msgid "Vibration During Write"
+msgstr "Vibrations lors de l'écriture"
+
+msgid "Shock During Write"
+msgstr "Chocs lors de l'écriture"
+
+msgid "Disk Shift"
+msgstr "Déplacement du disque"
+
+msgid "Load Retry Count"
+msgstr "Nombre de tentatives de chargement"
+
+msgid "Load Friction"
+msgstr "Friction de chargement"
+
+msgid "Load-in Time"
+msgstr "Temps de chargement"
+
+msgid "Torque Amplification Count"
+msgstr "Nombre d'amplifications de couple"
+
+msgid "Write Error Rate"
+msgstr "Taux d'erreurs d'écriture"
+
+msgid "Serial Number"
+msgstr "Numéro de série"
+
+msgid "LU WWN Device Id"
+msgstr "ID de périphérique LU WWN"
+
+msgid "Firmware Version"
+msgstr "Version du micrologiciel"
+
+msgid "User Capacity"
+msgstr "Capacité utilisable"
+
+msgid "Capacity"
+msgstr "Capacité"
+
+msgid "Sector Size"
+msgstr "Taille du secteur"
+
+msgid "Sector Sizes"
+msgstr "Tailles des secteurs"
+
+msgid "Rotation Rate"
+msgstr "Vitesse de rotation"
+
+msgid "Form Factor"
+msgstr "Facteur de forme"
+
+msgid "Device is"
+msgstr "Périphérique"
+
+msgid "ATA Version is"
+msgstr "Version ATA"
+
+msgid "SATA Version is"
+msgstr "Version SATA"
+
+msgid "Local Time is"
+msgstr "Heure locale"
+
+msgid "SMART support is"
+msgstr "Support SMART"
+
+msgid "SMART Status"
+msgstr "État SMART"
+
+msgid "Device"
+msgstr "Périphérique"
+
+msgid "Model Number"
+msgstr "Modèle"
+
+msgid "Firmware Revision"
+msgstr "Révision du micrologiciel"
+
+msgid "PCI Vendor/Subsystem ID"
+msgstr "ID fournisseur/sous-système PCI"
+
+msgid "IEEE OUI Identifier"
+msgstr "Identifiant IEEE OUI"
+
+msgid "Total NVM Capacity"
+msgstr "Capacité totale NVM"
+
+msgid "Unallocated NVM Capacity"
+msgstr "Capacité NVM non allouée"
+
+msgid "Controller ID"
+msgstr "ID du contrôleur"
+
+msgid "Number of Namespaces"
+msgstr "Nombre d'espaces d'adressage"
+
+msgid "Namespace 1 Size/Capacity"
+msgstr "Taille/capacité de l'espace d'adressage 1"
+
+msgid "Namespace 1 Formatted LBA Size"
+msgstr "Taille LBA de l'espace d'adressage 1"
+
+msgid "Namespace 1 IEEE EUI-64"
+msgstr "IEEE EUI-64 de l'espace d'adressage 1"
+
+msgid "logical/physical"
+msgstr "logique/physique"
+
+msgid "bytes"
+msgstr "octets"
+
+msgid "blocks"
+msgstr "blocs"
+
+msgid "Solid State Device"
+msgstr "Disque SSD"
+
+# Reserved space
+
+msgid "Reserved space"
+msgstr "Spazio riservato"
+
+msgid "Space reserved for root (default: 5%)"
+msgstr "Spazio riservato per root (predefinito: 5%)"
+
+msgid "Used Reserved Block Count Total"
+msgstr "Conteggio totale blocchi riservati utilizzati"
+
+msgid "Used Reserved Block Count Chip"
+msgstr "Conteggio blocchi riservati utilizzati per chip"
+
+msgid "Unused Reserved Block Count Total"
+msgstr "Conteggio totale blocchi riservati non utilizzati"
+
+msgid "Available Reserved Space"
+msgstr "Spazio riservato disponibile"
+
+# NVMe
+
+msgid "Critical Warning"
+msgstr "Avviso critico"
+
+msgid "Percentage Used"
+msgstr "Percentuale utilizzata"
+
+msgid "Data Units Read"
+msgstr "Unità dati lette"
+
+msgid "Data Units Written"
+msgstr "Unità dati scritte"
+
+msgid "Host Read Commands"
+msgstr "Comandi di lettura host"
+
+msgid "Host Write Commands"
+msgstr "Comandi di scrittura host"
+
+msgid "Controller Busy Time"
+msgstr "Tempo di occupazione controller"
+
+msgid "Power Cycles"
+msgstr "Cicli di alimentazione"
+
+msgid "Unsafe Shutdowns"
+msgstr "Arresti non sicuri"
+
+msgid "Media Errors"
+msgstr "Errori del supporto"
+
+msgid "Error Log Entries"
+msgstr "Voci del registro errori"
diff --git a/package/luci-app-mini-diskmanager/po/pl/mini-diskmanager.po b/package/luci-app-mini-diskmanager/po/pl/mini-diskmanager.po
new file mode 100644
index 0000000000..2d9994e883
--- /dev/null
+++ b/package/luci-app-mini-diskmanager/po/pl/mini-diskmanager.po
@@ -0,0 +1,1259 @@
+msgid ""
+msgstr ""
+"Project-Id-Version: luci-app-mini-diskmanager\n"
+"Language-Team: Rafał Wabik (IceG)\n"
+
+msgid "Disk Manager"
+msgstr "Menedżer dysków"
+
+msgid "-- Select a disk --"
+msgstr "-- Wybierz dysk --"
+
+msgid "Disk"
+msgstr "Dysk"
+
+msgid "Refresh"
+msgstr "Odśwież"
+
+msgid "Mounting actions"
+msgstr "Akcje montowania"
+
+msgid "Actions on partitions"
+msgstr "Operacje na partycjach"
+
+msgid "Mount"
+msgstr "Zamontuj"
+
+msgid "Unmount"
+msgstr "Odmontuj"
+
+msgid "Create"
+msgstr "Utwórz"
+
+msgid "Delete"
+msgstr "Usuń"
+
+msgid "Format"
+msgstr "Formatuj"
+
+msgid "Please select a disk to view its partitions"
+msgstr "Proszę wybrać dysk, aby zobaczyć jego partycje"
+
+msgid "Please select a disk first"
+msgstr "Proszę najpierw wybrać dysk"
+
+msgid "Please select a partition first"
+msgstr "Proszę najpierw wybrać partycję"
+
+msgid "Loading disk information..."
+msgstr "Ładowanie informacji o dysku..."
+
+msgid "Error loading disk information: "
+msgstr "Błąd wczytywania informacji o dysku: "
+
+msgid "Disk Information"
+msgstr "Informacje o dysku"
+
+msgid "Temperature"
+msgstr "Temperatura"
+
+msgid "S.M.A.R.T."
+msgstr "S.M.A.R.T."
+
+msgid "S.M.A.R.T. Status"
+msgstr "Status S.M.A.R.T."
+
+msgid "Partitions"
+msgstr "Partycje"
+
+msgid "Mount Status"
+msgstr "Status montowania"
+
+msgid "Mounted"
+msgstr "Zamontowany"
+
+msgid "Not mounted"
+msgstr "Niezamontowany"
+
+msgid "Partition Layout"
+msgstr "Układ partycji"
+
+msgid "Partition"
+msgstr "Partycja"
+
+msgid "Type / Filesystem"
+msgstr "Typ / System plików"
+
+msgid "Filesystem"
+msgstr "System plików"
+
+msgid "Mount Point"
+msgstr "Punkt montowania"
+
+msgid "Label"
+msgstr "Etykieta"
+
+msgid "Size"
+msgstr "Rozmiar"
+
+msgid "Used"
+msgstr "Użyte"
+
+msgid "Unused"
+msgstr "Wolne"
+
+msgid "Flags"
+msgstr "Flagi"
+
+msgid "No partitions found"
+msgstr "Nie znaleziono partycji"
+
+msgid "Unallocated"
+msgstr "Nieprzydzielone"
+
+msgid "Area without partition table"
+msgstr "Obszar bez tabeli partycji"
+
+msgid "Free Space"
+msgstr "Wolne miejsce"
+
+msgid "Primary"
+msgstr "Podstawowa"
+
+msgid "Extended"
+msgstr "Rozszerzona"
+
+msgid "Logical"
+msgstr "Logiczna"
+
+msgid "Create partition"
+msgstr "Utwórz partycję"
+
+msgid "Cancel"
+msgstr "Anuluj"
+
+msgid "File system"
+msgstr "System plików"
+
+msgid "Volume label"
+msgstr "Etykieta woluminu"
+
+msgid "Partition size"
+msgstr "Rozmiar partycji"
+
+msgid "Enter size"
+msgstr "Wprowadź rozmiar"
+
+msgid "Use all available space"
+msgstr "Użyj całego dostępnego miejsca"
+
+msgid "Available: %s MB / %s GB / %s TB"
+msgstr "Dostępne: %s MB / %s GB / %s TB"
+
+msgid "Please enter a valid size"
+msgstr "Wprowadź prawidłowy rozmiar"
+
+msgid "Size is too small"
+msgstr "Rozmiar jest zbyt mały"
+
+msgid "Creating partition..."
+msgstr "Tworzenie partycji..."
+
+msgid "Partition created successfully"
+msgstr "Partycja utworzona pomyślnie"
+
+msgid "Failed to create partition"
+msgstr "Nie udało się utworzyć partycji"
+
+msgid "Format Partition"
+msgstr "Formatuj partycję"
+
+msgid "Warning"
+msgstr "Ostrzeżenie"
+
+msgid "This will erase all data on /dev/%s"
+msgstr "To usunie wszystkie dane na /dev/%s"
+
+msgid "Formatting partition..."
+msgstr "Formatowanie partycji..."
+
+msgid "Partition formatted successfully"
+msgstr "Partycja sformatowana pomyślnie"
+
+msgid "Failed to format partition"
+msgstr "Nie udało się sformatować partycji"
+
+msgid "Delete Partition"
+msgstr "Usuń partycję"
+
+msgid "Are you sure you want to continue?"
+msgstr "Czy na pewno chcesz kontynuować?"
+
+msgid "Deleting partition..."
+msgstr "Usuwanie partycji..."
+
+msgid "Partition deleted successfully"
+msgstr "Partycja została pomyślnie usunięta"
+
+msgid "Failed to delete partition"
+msgstr "Nie udało się usunąć partycji"
+
+msgid "No partitions to mount"
+msgstr "Brak partycji do zamontowania"
+
+msgid "No mounted partitions found"
+msgstr "Nie znaleziono zamontowanych partycji"
+
+msgid "No partitions to unmount"
+msgstr "Brak partycji do odmontowania"
+
+msgid "Mounted to %s"
+msgstr "Zamontowano w %s"
+
+msgid "Unmounted %s"
+msgstr "Odmontowano %s"
+
+msgid "Failed to mount: "
+msgstr "Nie udało się zamontować: "
+
+msgid "Failed to unmount: "
+msgstr "Nie udało się odmontować: "
+
+msgid "Failed to check operation status: "
+msgstr "Nie udało się sprawdzić statusu operacji: "
+
+msgid "Partition created but device node did not appear in time"
+msgstr "Partycja została utworzona, ale urządzenie nie pojawiło się na czas"
+
+msgid "Partition created but device node did not appear; please refresh manually"
+msgstr "Partycja została utworzona, ale urządzenie się nie pojawiło — odśwież ręcznie"
+
+msgid "PASSED"
+msgstr "ZALICZONY"
+
+msgid "FAILED"
+msgstr "NIEZALICZONY"
+
+msgid "Cannot create partition on mounted disk. Please unmount first."
+msgstr "Nie można utworzyć partycji na zamontowanym dysku. Proszę najpierw odmontować."
+
+msgid "No unallocated space available on this disk"
+msgstr "Brak wolnego miejsca na tym dysku"
+
+msgid "Cannot format mounted partition. Please unmount first."
+msgstr "Nie można sformatować zamontowanej partycji. Proszę najpierw ją odmontować."
+
+msgid "Failed to refresh partition data: "
+msgstr "Nie udało się odświeżyć danych partycji: "
+
+msgid "Cannot delete partition on mounted disk. Please unmount first."
+msgstr "Nie można usunąć partycji z zamontowanego dysku. Proszę najpierw odmontować."
+
+msgid "This will delete partition /dev/%s and all its data!"
+msgstr "Ta operacja spowoduje usunięcie partycji /dev/%s i wszystkich jej danych!"
+
+msgid "Failed to load disk information: "
+msgstr "Nie udało się załadować informacji o dysku: "
+
+msgid "Click to select"
+msgstr "Kliknij, aby wybrać"
+
+msgid "System partition cannot be selected"
+msgstr "Nie możesz wskazać partycji systemowej"
+
+msgid "Free"
+msgstr "Wolne"
+
+msgid "Select a disk"
+msgstr "Wybierz dysk"
+
+msgid "Create a new partition on the selected disk"
+msgstr "Utwórz nową partycję na wybranym dysku"
+
+msgid "Partition layout"
+msgstr "Układ partycji"
+
+msgid "Partition type"
+msgstr "Typ partycji"
+
+msgid "Refresh partition data"
+msgstr "Odśwież dane partycji"
+
+msgid "MBR (Master Boot Record)"
+msgstr "MBR (Główny Rekord Rozruchowy)"
+
+msgid "GPT (GUID Partition Table)"
+msgstr "GPT (Tabela Partycji GUID)"
+
+msgid "The Mini Disk Manager package allows users to easily manage disks and partitions."
+msgstr "Mini Menedżer Dysków pozwala użytkownikowi w prosty sposób zarządzać dyskami oraz partycjami."
+
+msgid "Configuration"
+msgstr "Konfiguracja"
+
+msgid "Package and Driver Verification"
+msgstr "Weryfikacja pakietów i sterowników"
+
+msgid "Check and install required drivers for storage devices."
+msgstr "Sprawdź i zainstaluj wymagane sterowniki dla urządzeń pamięci masowej."
+
+msgid "Filesystem Support"
+msgstr "Obsługa systemów plików"
+
+msgid "Check USB drivers"
+msgstr "Sprawdź sterowniki USB"
+
+msgid "USB drivers"
+msgstr "Sterowniki USB"
+
+msgid "Check NVMe drivers"
+msgstr "Sprawdź sterowniki NVMe"
+
+msgid "NVMe drivers"
+msgstr "Sterowniki NVMe"
+
+msgid "Check ATA/SATA drivers"
+msgstr "Sprawdź sterowniki ATA/SATA"
+
+msgid "ATA/SATA drivers"
+msgstr "Sterowniki ATA/SATA"
+
+msgid "Check Linux filesystem packages"
+msgstr "Sprawdź pakiety systemów plików Linux"
+
+msgid "Linux filesystems"
+msgstr "Systemy plików Linux"
+
+msgid "Check Windows filesystem packages"
+msgstr "Sprawdź pakiety systemów plików Windows"
+
+msgid "Windows filesystems"
+msgstr "Systemy plików Windows"
+
+msgid "View disk manager log"
+msgstr "Pokaż dziennik menedżera dysków"
+
+msgid "View log"
+msgstr "Pokaż dziennik"
+
+msgid "USB Drivers"
+msgstr "Sterowniki USB"
+
+msgid "NVMe Drivers"
+msgstr "Sterowniki NVMe"
+
+msgid "ATA/SATA Drivers"
+msgstr "Sterowniki ATA/SATA"
+
+msgid "Linux Filesystem Packages"
+msgstr "Pakiety systemów plików Linux"
+
+msgid "Windows Filesystem Packages"
+msgstr "Pakiety systemów plików Windows"
+
+msgid "Disk Manager Log"
+msgstr "Dziennik menedżera dysków"
+
+msgid "Loading package data…"
+msgstr "Ładowanie danych o pakietach…"
+
+msgid "Loading log file…"
+msgstr "Ładowanie pliku dziennika…"
+
+msgid "Log file content"
+msgstr "Zawartość pliku dziennika"
+
+msgid "Log file is empty"
+msgstr "Plik dziennika jest pusty"
+
+msgid "Unable to read log file"
+msgstr "Nie można odczytać pliku dziennika"
+
+msgid "Log file cleared successfully"
+msgstr "Plik dziennika wyczyszczony pomyślnie"
+
+msgid "Unable to clear the file"
+msgstr "Nie można wyczyścić pliku"
+
+msgid "Installed"
+msgstr "Zainstalowany"
+
+msgid "Install…"
+msgstr "Instaluj…"
+
+msgid "Clear"
+msgstr "Wyczyść"
+
+msgid "Download"
+msgstr "Pobierz"
+
+msgid "Close"
+msgstr "Zamknij"
+
+msgid "Failed to load package data"
+msgstr "Nie udało się załadować danych o pakietach"
+
+msgid "more info in log"
+msgstr "więcej informacji w dzienniku pakietu"
+
+msgid "The tab allows users to support the package."
+msgstr "Ta zakładka umożliwia użytkownikowi wsparcie pakietu."
+
+msgid "Package support"
+msgstr "Wsparcie pakietu"
+
+msgid "Mini Disk Manager Info"
+msgstr "Mini Menedżer Dysków - informacje"
+
+msgid "Luci-app-mdmanager"
+msgstr "Luci-app-mdmanager"
+
+msgid "Buy a coffee"
+msgstr "Postaw kawę"
+
+msgid "Buy a coffee if you want to support the development of the project and the author"
+msgstr "Postaw kawę, jeśli chcesz wesprzeć rozwój projektu i jego autora"
+
+msgid "Become a sponsor"
+msgstr "Zostań sponsorem"
+
+msgid "Become a sponsor if you want to support the development of the project and the author"
+msgstr "Zostań sponsorem, jeśli chcesz wesprzeć rozwój projektu i jego autora"
+
+msgid "Write on forum"
+msgstr "Napisz na forum"
+
+msgid "Write in the topic of the package on the forum eko.one.pl"
+msgstr "Napisz w wątku pakietu na forum eko.one.pl"
+
+msgid "Open discussion"
+msgstr "Otwórz dyskusję"
+
+msgid "Open a package discussion on Github"
+msgstr "Otwórz dyskusję o pakiecie na GitHubie"
+
+msgid "Report a bug"
+msgstr "Zgłoś błąd"
+
+msgid "Report a bug on the package Github page"
+msgstr "Zgłoś błąd na stronie pakietu w serwisie GitHub"
+
+msgid "Package name"
+msgstr "Nazwa pakietu"
+
+msgid "Author (package maintainer)"
+msgstr "Autor (opiekun pakietu)"
+
+msgid "Information about package author and available support options."
+msgstr "Informacje o autorze pakietu i dostępnych opcjach wsparcia."
+
+# --
+
+msgid "All available space"
+msgstr "Cała dostępna przestrzeń"
+
+msgid "Cannot delete mounted partition. Please unmount first."
+msgstr "Nie można usunąć zamontowanej partycji. Proszę najpierw ją odmontować."
+
+msgid "Failed to create partition: "
+msgstr "Nie udało się utworzyć partycji: "
+
+msgid "Failed to detect supported filesystems"
+msgstr "Nie udało się wykryć obsługiwanych systemów plików"
+
+msgid "Failed to format partition: "
+msgstr "Nie udało się sformatować partycji: "
+
+msgid "Failed to parse JSON response: "
+msgstr "Nie udało się przetworzyć odpowiedzi JSON: "
+
+msgid "Failed to start formatting"
+msgstr "Nie udało się rozpocząć formatowania"
+
+msgid "Failed to start partition creation"
+msgstr "Nie udało się rozpocząć tworzenia partycji"
+
+msgid "Failed to start partition deletion"
+msgstr "Nie udało się rozpocząć usuwania partycji"
+
+msgid "Fill in size"
+msgstr "Uzupełnij rozmiar"
+
+msgid "Linux Swap"
+msgstr "Linux Swap"
+
+msgid "Loading..."
+msgstr "Ładowanie..."
+
+msgid "No filesystem packages detected — user cannot choose unsupported filesystem formats."
+msgstr "Nie wykryto pakietów systemów plików — użytkownik nie może wybrać formatów nieobsługiwanych przez system."
+
+msgid "No partition types available. Maximum partitions reached."
+msgstr "Brak dostępnych typów partycji. Osiągnięto maksymalną liczbę partycji."
+
+msgid "No supported filesystems detected on this system"
+msgstr "Nie wykryto obsługiwanych systemów plików w tym systemie"
+
+msgid "Optional"
+msgstr "Opcjonalne"
+
+msgid "Partition created but selected filesystem is not available for formatting on this system"
+msgstr "Partycja została utworzona, ale wybrany system plików nie jest dostępny do formatowania w tym systemie"
+
+msgid "Partition data refreshed"
+msgstr "Dane partycji zostały odświeżone"
+
+msgid "Please select a filesystem"
+msgstr "Proszę wybrać system plików"
+
+msgid "RPC call failed: "
+msgstr "Wywołanie RPC nie powiodło się: "
+
+msgid "Refreshing..."
+msgstr "Odświeżanie..."
+
+msgid "Selected filesystem is not supported on this system"
+msgstr "Wybrany system plików nie jest obsługiwany w tym systemie"
+
+msgid "Selected partition is not mounted"
+msgstr "Wybrana partycja nie jest zamontowana"
+
+msgid "unknown error"
+msgstr "nieznany błąd"
+
+msgid "Packages & Drivers"
+msgstr "Pakiety oraz sterowniki"
+
+msgid "Mini Disk Manager log"
+msgstr "Mini Menedżer Dysków dziennik"
+
+msgid "Mini Disk Manager Log"
+msgstr "Mini Menedżer Dysków dziennik"
+
+msgid "Packages required to support various file systems."
+msgstr "Pakiety wymagane do obsługi różnych systemów plików."
+
+msgid "Expand"
+msgstr "Rozszerz"
+
+msgid "Resize"
+msgstr "Zmień rozmiar"
+
+msgid "Resize Partition"
+msgstr "Zmień rozmiar partycji"
+
+msgid "Resize partition /dev/%s"
+msgstr "Zmień rozmiar partycji /dev/%s"
+
+msgid "Resizing partition..."
+msgstr "Zmiana rozmiaru partycji..."
+
+msgid "Resizing a partition can cause data loss if not done correctly."
+msgstr "Zmiana rozmiaru partycji może spowodować utratę danych, jeśli nie zostanie wykonana poprawnie."
+
+msgid "Please ensure you have a backup of important data before proceeding."
+msgstr "Upewnij się, że masz kopię zapasową ważnych danych przed kontynuowaniem."
+
+msgid "Current size: %s MB / %s GB / %s TB"
+msgstr "Obecny rozmiar: %s MB / %s GB / %s TB"
+
+msgid "Available space: %s MB / %s GB / %s TB"
+msgstr "Dostępne miejsce: %s MB / %s GB / %s TB"
+
+msgid "Maximum size to be obtained: %s MB / %s GB / %s TB"
+msgstr "Maksymalny rozmiar do uzyskania: %s MB / %s GB / %s TB"
+
+msgid "Maximum new size"
+msgstr "Maksymalny nowy rozmiar"
+
+msgid "New size"
+msgstr "Nowy rozmiar"
+
+msgid "Enter new size"
+msgstr "Wprowadź nowy rozmiar"
+
+msgid "New size must be larger than current size"
+msgstr "Nowy rozmiar musi być większy niż obecny rozmiar"
+
+msgid "New size exceeds available space"
+msgstr "Nowy rozmiar przekracza dostępne miejsce"
+
+msgid "Partition resized successfully"
+msgstr "Pomyślnie zmieniono rozmiar partycji"
+
+msgid "Failed to resize partition"
+msgstr "Nie udało się zmienić rozmiaru partycji"
+
+msgid "Failed to resize partition: "
+msgstr "Nie udało się zmienić rozmiaru partycji: "
+
+msgid "Failed to start partition resize"
+msgstr "Nie udało się rozpocząć zmiany rozmiaru partycji"
+
+msgid "Selected partition cannot be resized. Only unmounted Ext2/3/4 partitions with available space can be resized."
+msgstr "Nie można zmienić rozmiaru wybranej partycji. Można zmieniać rozmiar tylko odmontowanych partycji Ext2/3/4 z dostępnym miejscem."
+
+msgid "MB"
+msgstr "MB"
+
+msgid "GB"
+msgstr "GB"
+
+msgid "TB"
+msgstr "TB"
+
+msgid "Cannot Create Partition"
+msgstr "Nie można utworzyć partycji"
+
+msgid "Insufficient Space"
+msgstr "Niewystarczające miejsce"
+
+msgid "Cannot read partition information"
+msgstr "Nie można odczytać informacji o partycji"
+
+msgid "Invalid extended partition"
+msgstr "Nieprawidłowa partycja rozszerzona"
+
+msgid "Extended partition not found or has invalid size"
+msgstr "Nie znaleziono partycji rozszerzonej lub ma nieprawidłowy rozmiar"
+
+msgid "Extended partition size: %s MB"
+msgstr "Rozmiar partycji rozszerzonej: %s MB"
+
+msgid "Used by logical partitions: %s MB"
+msgstr "Używane przez partycje logiczne: %s MB"
+
+msgid "Available for new logical: %s MB"
+msgstr "Dostępne dla nowej logicznej: %s MB"
+
+msgid "Required minimum: 10 MB"
+msgstr "Wymagane minimum: 10 MB"
+
+msgid "Not enough free space in extended partition /dev/%s"
+msgstr "Za mało wolnego miejsca w partycji rozszerzonej /dev/%s"
+
+msgid "Extended partition already exists. You can create primary partitions or select the extended partition to create logical partitions inside."
+msgstr "Partycja rozszerzona już istnieje. Możesz utworzyć partycje podstawowe lub wybrać partycję rozszerzoną, aby utworzyć partycje logiczne wewnątrz."
+
+msgid "Creating partition inside extended partition. Only logical partitions can be created here."
+msgstr "Tworzenie partycji wewnątrz partycji rozszerzonej. Można tu tworzyć tylko partycje logiczne."
+
+msgid "No partition table detected. A primary partition will be created and a partition table will be initialized."
+msgstr "Nie wykryto tablicy partycji. Zostanie utworzona partycja podstawowa i zainicjowana tablica partycji."
+
+msgid "No partition table - select to create"
+msgstr "Brak tablicy partycji - zaznacz aby utworzyć"
+
+msgid "No partitions - select to create"
+msgstr "Brak partycji - zaznacz aby utworzyć"
+
+msgid "Select to enable partition creation"
+msgstr "Zaznacz aby włączyć tworzenie partycji"
+
+msgid "Select unallocated space"
+msgstr "Wybierz nieprzydzielone miejsce"
+
+msgid "Unallocated space"
+msgstr "Nieprzydzielone miejsce"
+
+msgid "Expand Ext2/Ext3/Ext4"
+msgstr "Rozszerzanie Ext2/Ext3/Ext4"
+
+msgid "Wipe"
+msgstr "Wymaż"
+
+msgid "Select all partitions for wiping"
+msgstr "Zaznacz wszystkie partycje do wymazania"
+
+msgid "Please enable wipe mode first"
+msgstr "Najpierw włącz tryb wymazywania"
+
+msgid "Cannot wipe disk with mounted partitions. Please unmount all partitions first."
+msgstr "Nie można wymazać dysku z zamontowanymi partycjami. Najpierw odmontuj wszystkie partycje."
+
+msgid "Wipe Disk"
+msgstr "Wymaż dysk"
+
+msgid "WARNING"
+msgstr "OSTRZEŻENIE"
+
+msgid "This will completely erase the partition table and all data on /dev/%s!"
+msgstr "Ta operacja usunie całkowicie tablicę partycji i wszystkie dane na /dev/%s!"
+
+msgid "THIS OPERATION CANNOT BE UNDONE!"
+msgstr "TEJ OPERACJI NIE MOŻNA COFNĄĆ!"
+
+msgid "Number of partitions to be deleted: %d"
+msgstr "Liczba partycji do usunięcia: %d"
+
+msgid "Are you absolutely sure you want to continue?"
+msgstr "Czy na pewno chcesz kontynuować?"
+
+msgid "Wiping disk partition table..."
+msgstr "Wymazywanie tablicy partycji dysku..."
+
+msgid "Disk partition table has been successfully erased"
+msgstr "Tablica partycji dla dysku została pomyślnie wymazana"
+
+msgid "Failed to wipe disk"
+msgstr "Nie udało się wymazać dysku"
+
+msgid "Failed to start disk wipe"
+msgstr "Nie udało się rozpocząć wymazywania dysku"
+
+msgid "Failed to wipe disk: "
+msgstr "Nie udało się wymazać dysku: "
+
+msgid "Disk Wipe Support"
+msgstr "Wsparcie wymazywania dysku"
+
+msgid "Packages required to support disk wiping functionality (clearing partition table)."
+msgstr "Pakiety wymagane do działania opcji wymazywania dysku (usuwanie tablicy partycji)."
+
+msgid "Check Disk Wipe packages"
+msgstr "Sprawdź pakiety do wymazywania dysku"
+
+msgid "Disk Wipe"
+msgstr "Wymazywanie dysku"
+
+msgid "dd from BusyBox"
+msgstr "dd z BusyBox"
+
+msgid "Disk Wipe (dd command)"
+msgstr "Wymazywanie dysku (komenda dd)"
+
+msgid "alternative"
+msgstr "alternatywnie"
+
+# MORE SMART
+
+msgid "Attribute"
+msgstr "Atrybut"
+
+msgid "Id"
+msgstr "Id"
+
+msgid "Raw"
+msgstr "Raw"
+
+msgid "Worst"
+msgstr "Najgorszy"
+
+msgid "Thresh"
+msgstr "Próg"
+
+msgid "Value"
+msgstr "Wartość"
+
+msgid "NVMe S.M.A.R.T. Health Status"
+msgstr "Status zdrowia NVMe (S.M.A.R.T.)"
+
+msgid "OK"
+msgstr "OK"
+
+msgid "WARNING"
+msgstr "OSTRZEŻENIE"
+
+msgid "Power On Time"
+msgstr "Czas pracy"
+
+msgid "Power On Hours"
+msgstr "Godziny pracy"
+
+msgid "Disk Usage"
+msgstr "Zużycie dysku"
+
+msgid "Disk Wear Level"
+msgstr "Poziom zużycia dysku"
+
+msgid "Available Spare"
+msgstr "Dostępna rezerwa"
+
+msgid "Available Spare Threshold"
+msgstr "Próg dostępnej rezerwy"
+
+msgid "hour"
+msgstr "godzina"
+
+msgid "hours"
+msgstr "godzin(-y)"
+
+msgid "h"
+msgstr "godz"
+
+msgid "year"
+msgstr "rok"
+
+msgid "years"
+msgstr "lata"
+
+msgid "month"
+msgstr "miesiąc"
+
+msgid "months"
+msgstr "miesiące(-ęcy)"
+
+msgid "day"
+msgstr "dzień"
+
+msgid "days"
+msgstr "dni"
+
+msgid "worn"
+msgstr "zużyte"
+
+msgid "remaining"
+msgstr "pozostało"
+
+msgid "S.M.A.R.T. Health Status"
+msgstr "Ogólny stan zdrowia dysku (S.M.A.R.T.)"
+
+msgid "No S.M.A.R.T. attributes found."
+msgstr "Nie znaleziono atrybutów S.M.A.R.T."
+
+msgid "Loading S.M.A.R.T. data..."
+msgstr "Ładowanie danych S.M.A.R.T..."
+
+msgid "Unable to read S.M.A.R.T. data."
+msgstr "Nie można odczytać danych S.M.A.R.T."
+
+msgid "Error reading S.M.A.R.T. data."
+msgstr "Błąd odczytu danych S.M.A.R.T."
+
+# SMART & Disk Info
+
+msgid "Raw Read Error Rate"
+msgstr "Współczynnik błędów odczytu"
+
+msgid "Throughput Performance"
+msgstr "Wydajność przepustowości"
+
+msgid "Spin Up Time"
+msgstr "Czas rozkręcania"
+
+msgid "Start Stop Count"
+msgstr "Liczba starów/zatrzymań"
+
+msgid "Reallocated Sector Count"
+msgstr "Liczba przemapowanych sektorów"
+
+msgid "Seek Error Rate"
+msgstr "Współczynnik błędów pozycjonowania"
+
+msgid "Seek Time Performance"
+msgstr "Wydajność pozycjonowania"
+
+msgid "Power On Hours"
+msgstr "Czas pracy"
+
+msgid "Spin Retry Count"
+msgstr "Liczba ponowień rozkręcania"
+
+msgid "Calibration Retry Count"
+msgstr "Liczba ponowień kalibracji"
+
+msgid "Power Cycle Count"
+msgstr "Liczba cykli zasilania"
+
+msgid "Read Soft Error Rate"
+msgstr "Współczynnik miękkich błędów odczytu"
+
+msgid "Airflow Temperature"
+msgstr "Temperatura przepływu powietrza"
+
+msgid "Temperature Celsius"
+msgstr "Temperatura"
+
+msgid "Hardware ECC Recovered"
+msgstr "Błędy ECC naprawione sprzętowo"
+
+msgid "Current Pending Sector"
+msgstr "Niestabilne sektory"
+
+msgid "Offline Uncorrectable"
+msgstr "Nienaprawialne sektory offline"
+
+msgid "UDMA CRC Error Count"
+msgstr "Liczba błędów CRC UDMA"
+
+msgid "Multi Zone Error Rate"
+msgstr "Współczynnik błędów wielostrefowych"
+
+msgid "Wear Leveling Count"
+msgstr "Licznik zużycia"
+
+msgid "Used Reserved Block Count Total"
+msgstr "Użyte bloki rezerwowe (całość)"
+
+msgid "Used Reserved Block Count Chip"
+msgstr "Użyte bloki rezerwowe (chip)"
+
+msgid "Unused Reserved Block Count Total"
+msgstr "Niewykorzystane bloki rezerwowe"
+
+msgid "Program Fail Count Total"
+msgstr "Liczba błędów zapisu"
+
+msgid "Erase Fail Count Total"
+msgstr "Liczba błędów kasowania"
+
+msgid "Runtime Bad Block"
+msgstr "Uszkodzone bloki"
+
+msgid "Uncorrectable Error Count"
+msgstr "Liczba błędów nienaprawialnych"
+
+msgid "Temperature Exceed Count"
+msgstr "Liczba przekroczeń temperatury"
+
+msgid "Erase Fail Count"
+msgstr "Liczba błędów kasowania"
+
+msgid "Reported Uncorrectable Errors"
+msgstr "Zgłoszone błędy nienaprawialne"
+
+msgid "High Fly Writes"
+msgstr "Zapisy w wysokim locie"
+
+msgid "G-Sense Error Rate"
+msgstr "Współczynnik błędów czujnika przeciążeń"
+
+msgid "Power-Off Retract Count"
+msgstr "Liczba cofnięć głowic przy wyłączeniu"
+
+msgid "Load Cycle Count"
+msgstr "Liczba cykli parkowania głowic"
+
+msgid "Temperature Case"
+msgstr "Temperatura obudowy"
+
+msgid "Reallocated Event Count"
+msgstr "Liczba zdarzeń przemapowania"
+
+msgid "Transfer Error Rate"
+msgstr "Współczynnik błędów przesyłu"
+
+msgid "Free Fall Sensor"
+msgstr "Czujnik swobodnego spadku"
+
+msgid "Total LBAs Written"
+msgstr "Całkowita liczba zapisanych LBA"
+
+msgid "Total LBAs Read"
+msgstr "Całkowita liczba odczytanych LBA"
+
+msgid "Read Error Retry Rate"
+msgstr "Współczynnik ponowień odczytu"
+
+msgid "Minimum W/E Cycle"
+msgstr "Minimalny cykl zapisu/kasowania"
+
+msgid "Maximum W/E Cycle"
+msgstr "Maksymalny cykl zapisu/kasowania"
+
+msgid "Average W/E Cycle"
+msgstr "Średni cykl zapisu/kasowania"
+
+msgid "Media Wearout Indicator"
+msgstr "Wskaźnik zużycia nośnika"
+
+msgid "Available Reserved Space"
+msgstr "Dostępna przestrzeń rezerwowa"
+
+msgid "SSD Life Left"
+msgstr "Pozostały żywotność SSD"
+
+msgid "Remaining Lifetime Percentage"
+msgstr "Pozostała żywotność (procent)"
+
+msgid "Percentage Lifetime Remaining"
+msgstr "Procent pozostałej żywotności"
+
+msgid "Remaining Life"
+msgstr "Pozostała żywotność"
+
+msgid "Lifetime Writes GiB"
+msgstr "Zapisane dane (GiB)"
+
+msgid "Lifetime Reads GiB"
+msgstr "Odczytane dane (GiB)"
+
+msgid "Program Fail Count"
+msgstr "Liczba błędów programowania"
+
+msgid "Unexpected Power Loss Count"
+msgstr "Liczba nieoczekiwanych utrat zasilania"
+
+msgid "Thermal Throttle Status"
+msgstr "Status ograniczenia termicznego"
+
+msgid "End-to-End Error"
+msgstr "Błąd end-to-end"
+
+msgid "Workload Host Reads Percentage"
+msgstr "Procent odczytów hosta"
+
+msgid "Workload Media Wear Indicator"
+msgstr "Wskaźnik zużycia nośnika (obciążenie)"
+
+msgid "Timed Workload Media Wear"
+msgstr "Zużycie nośnika (czasowe obciążenie)"
+
+msgid "Workload Timer"
+msgstr "Timer obciążenia"
+
+msgid "Percentage Rated Life Used"
+msgstr "Procent zużytej żywotności"
+
+msgid "Head Flying Hours"
+msgstr "Czas lotu głowic"
+
+msgid "Read Channel Margin"
+msgstr "Margines kanału odczytu"
+
+msgid "Loaded Hours"
+msgstr "Czas pracy z odparkowaniem"
+
+msgid "Load/Unload Retry Count"
+msgstr "Liczba ponowień parkowania/odparkowania"
+
+msgid "GMR Head Amplitude"
+msgstr "Amplituda głowicy GMR"
+
+msgid "Drive Temperature"
+msgstr "Temperatura dysku"
+
+msgid "Endurance Remaining"
+msgstr "Pozostała wytrzymałość"
+
+msgid "Power On Hours and Milliseconds"
+msgstr "Czas pracy (godziny i milisekundy)"
+
+msgid "Head Health"
+msgstr "Stan głowic"
+
+msgid "POR Recovery Count"
+msgstr "Liczba odzyskań POR"
+
+msgid "Unused Reserve NAND Blocks"
+msgstr "Niewykorzystane bloki NAND rezerwowe"
+
+msgid "SSD Protect Mode"
+msgstr "Tryb ochrony SSD"
+
+msgid "Host Writes 32MiB"
+msgstr "Zapisy hosta (32MiB)"
+
+msgid "NAND Writes 32MiB"
+msgstr "Zapisy NAND (32MiB)"
+
+msgid "Remaining Life Left"
+msgstr "Pozostała żywotność"
+
+msgid "Grown Bad Block Count"
+msgstr "Liczba nowych uszkodzonych bloków"
+
+msgid "Soft Read Error Rate"
+msgstr "Współczynnik miękkich błędów odczytu"
+
+msgid "Data Address Mark Errors"
+msgstr "Błędy znacznika adresu danych"
+
+msgid "Run Out Cancel"
+msgstr "Anulowanie przekroczenia"
+
+msgid "Soft ECC Correction"
+msgstr "Miękka korekta ECC"
+
+msgid "TA Increase Count"
+msgstr "Liczba wzrostów TA"
+
+msgid "Shock Count Write Operation"
+msgstr "Liczba wstrząsów przy zapisie"
+
+msgid "Shock Rate Write Operation"
+msgstr "Współczynnik wstrząsów przy zapisie"
+
+msgid "Flying Height"
+msgstr "Wysokość lotu głowic"
+
+msgid "Spin High Current"
+msgstr "Wysoki prąd rozruchu"
+
+msgid "Spin Buzz"
+msgstr "Buzz rozruchu"
+
+msgid "Offline Seek Performance"
+msgstr "Wydajność pozycjonowania offline"
+
+msgid "Vibration During Write"
+msgstr "Wibracje podczas zapisu"
+
+msgid "Shock During Write"
+msgstr "Wstrząsy podczas zapisu"
+
+msgid "Disk Shift"
+msgstr "Przesunięcie dysku"
+
+msgid "Load Retry Count"
+msgstr "Liczba ponowień załadowania"
+
+msgid "Load Friction"
+msgstr "Tarcie ładowania"
+
+msgid "Load-in Time"
+msgstr "Czas załadowania"
+
+msgid "Torque Amplification Count"
+msgstr "Liczba wzmocnień momentu obrotowego"
+
+msgid "Write Error Rate"
+msgstr "Współczynnik błędów zapisu"
+
+msgid "Serial Number"
+msgstr "Numer seryjny"
+
+msgid "LU WWN Device Id"
+msgstr "Identyfikator LU WWN"
+
+msgid "Firmware Version"
+msgstr "Wersja firmware"
+
+msgid "User Capacity"
+msgstr "Pojemność użyteczna"
+
+msgid "Capacity"
+msgstr "Pojemność"
+
+msgid "Sector Size"
+msgstr "Rozmiar sektora"
+
+msgid "Sector Sizes"
+msgstr "Rozmiary sektorów"
+
+msgid "Rotation Rate"
+msgstr "Prędkość obrotowa"
+
+msgid "Form Factor"
+msgstr "Format"
+
+msgid "Device is"
+msgstr "Urządzenie"
+
+msgid "ATA Version is"
+msgstr "Wersja ATA"
+
+msgid "SATA Version is"
+msgstr "Wersja SATA"
+
+msgid "Local Time is"
+msgstr "Czas lokalny"
+
+msgid "SMART support is"
+msgstr "Obsługa SMART"
+
+msgid "SMART Status"
+msgstr "Status SMART"
+
+msgid "Device"
+msgstr "Urządzenie"
+
+msgid "Model Number"
+msgstr "Model"
+
+msgid "Firmware Revision"
+msgstr "Wersja firmware"
+
+msgid "PCI Vendor/Subsystem ID"
+msgstr "ID producenta/podsystemu PCI"
+
+msgid "IEEE OUI Identifier"
+msgstr "Identyfikator IEEE OUI"
+
+msgid "Total NVM Capacity"
+msgstr "Całkowita pojemność NVM"
+
+msgid "Unallocated NVM Capacity"
+msgstr "Nieprzydzielona pojemność NVM"
+
+msgid "Controller ID"
+msgstr "ID kontrolera"
+
+msgid "Number of Namespaces"
+msgstr "Liczba obszarów adresowych"
+
+msgid "Namespace 1 Size/Capacity"
+msgstr "Rozmiar/pojemność obszaru adresowego 1"
+
+msgid "Namespace 1 Formatted LBA Size"
+msgstr "Rozmiar LBA obszaru adresowego 1"
+
+msgid "Namespace 1 IEEE EUI-64"
+msgstr "IEEE EUI-64 obszaru adresowego 1"
+
+msgid "logical/physical"
+msgstr "logiczny/fizyczny"
+
+msgid "bytes"
+msgstr "bajtów"
+
+msgid "blocks"
+msgstr "bloków"
+
+msgid "Solid State Device"
+msgstr "Dysk SSD"
+
+# Reserved space
+
+msgid "Reserved space"
+msgstr "Przestrzeń zarezerwowana"
+
+msgid "Space reserved for root (default: 5%)"
+msgstr "Przestrzeń zarezerwowana dla roota (domyślnie: 5%)"
+
+msgid "Used Reserved Block Count Total"
+msgstr "Całkowita liczba użytych bloków zarezerwowanych"
+
+msgid "Used Reserved Block Count Chip"
+msgstr "Liczba użytych bloków zarezerwowanych układu"
+
+msgid "Unused Reserved Block Count Total"
+msgstr "Całkowita liczba nieużywanych bloków zarezerwowanych"
+
+msgid "Available Reserved Space"
+msgstr "Dostępna przestrzeń zarezerwowana"
+
+# NVMe
+
+msgid "Critical Warning"
+msgstr "Ostrzeżenie krytyczne"
+
+msgid "Percentage Used"
+msgstr "Procent wykorzystania"
+
+msgid "Data Units Read"
+msgstr "Odczytane jednostki danych"
+
+msgid "Data Units Written"
+msgstr "Zapisane jednostki danych"
+
+msgid "Host Read Commands"
+msgstr "Polecenia odczytu hosta"
+
+msgid "Host Write Commands"
+msgstr "Polecenia zapisu hosta"
+
+msgid "Controller Busy Time"
+msgstr "Czas zajętości kontrolera"
+
+msgid "Power Cycles"
+msgstr "Cykle zasilania"
+
+msgid "Unsafe Shutdowns"
+msgstr "Niebezpieczne wyłączenia"
+
+msgid "Media Errors"
+msgstr "Błędy nośnika"
+
+msgid "Error Log Entries"
+msgstr "Wpisy dziennika błędów"
diff --git a/package/luci-app-mini-diskmanager/po/ru/mini-diskmanager.po b/package/luci-app-mini-diskmanager/po/ru/mini-diskmanager.po
new file mode 100644
index 0000000000..1b606d2926
--- /dev/null
+++ b/package/luci-app-mini-diskmanager/po/ru/mini-diskmanager.po
@@ -0,0 +1,1254 @@
+msgid ""
+msgstr ""
+"Project-Id-Version: luci-app-mini-diskmanager\n"
+"Language-Team: Rafał Wabik (IceG)\n"
+"Language: ru\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+msgid "Disk Manager"
+msgstr "Менеджер дисков"
+
+msgid "-- Select a disk --"
+msgstr "-- Выберите диск --"
+
+msgid "Disk"
+msgstr "Диск"
+
+msgid "Refresh"
+msgstr "Обновить"
+
+msgid "Mounting actions"
+msgstr "Действия монтирования"
+
+msgid "Actions on partitions"
+msgstr "Операции с разделами"
+
+msgid "Mount"
+msgstr "Монтировать"
+
+msgid "Unmount"
+msgstr "Размонтировать"
+
+msgid "Create"
+msgstr "Создать"
+
+msgid "Delete"
+msgstr "Удалить"
+
+msgid "Format"
+msgstr "Форматировать"
+
+msgid "Please select a disk to view its partitions"
+msgstr "Выберите диск для просмотра его разделов"
+
+msgid "Please select a disk first"
+msgstr "Сначала выберите диск"
+
+msgid "Please select a partition first"
+msgstr "Сначала выберите раздел"
+
+msgid "Loading disk information..."
+msgstr "Загрузка информации о диске..."
+
+msgid "Error loading disk information: "
+msgstr "Ошибка загрузки информации о диске: "
+
+msgid "Disk Information"
+msgstr "Информация о диске"
+
+msgid "Temperature"
+msgstr "Температура"
+
+msgid "S.M.A.R.T."
+msgstr "S.M.A.R.T."
+
+msgid "S.M.A.R.T. Status"
+msgstr "Статус S.M.A.R.T."
+
+msgid "Partitions"
+msgstr "Разделы"
+
+msgid "Mount Status"
+msgstr "Статус монтирования"
+
+msgid "Mounted"
+msgstr "Смонтирован"
+
+msgid "Not mounted"
+msgstr "Не смонтирован"
+
+msgid "Partition Layout"
+msgstr "Схема разделов"
+
+msgid "Partition"
+msgstr "Раздел"
+
+msgid "Type / Filesystem"
+msgstr "Тип / Файловая система"
+
+msgid "Filesystem"
+msgstr "Файловая система"
+
+msgid "Mount Point"
+msgstr "Точка монтирования"
+
+msgid "Label"
+msgstr "Метка"
+
+msgid "Size"
+msgstr "Размер"
+
+msgid "Used"
+msgstr "Использовано"
+
+msgid "Unused"
+msgstr "Свободно"
+
+msgid "Flags"
+msgstr "Флаги"
+
+msgid "No partitions found"
+msgstr "Разделы не найдены"
+
+msgid "Unallocated"
+msgstr "Не распределено"
+
+msgid "Area without partition table"
+msgstr "Область без таблицы разделов"
+
+msgid "Free Space"
+msgstr "Свободное место"
+
+msgid "Primary"
+msgstr "Первичный"
+
+msgid "Extended"
+msgstr "Расширенный"
+
+msgid "Logical"
+msgstr "Логический"
+
+msgid "Create partition"
+msgstr "Создать раздел"
+
+msgid "Cancel"
+msgstr "Отмена"
+
+msgid "File system"
+msgstr "Файловая система"
+
+msgid "Volume label"
+msgstr "Метка тома"
+
+msgid "Partition size"
+msgstr "Размер раздела"
+
+msgid "Enter size"
+msgstr "Введите размер"
+
+msgid "Use all available space"
+msgstr "Использовать всё доступное место"
+
+msgid "Available: %s MB / %s GB / %s TB"
+msgstr "Доступно: %s МБ / %s ГБ / %s ТБ"
+
+msgid "Please enter a valid size"
+msgstr "Введите корректный размер"
+
+msgid "Size is too small"
+msgstr "Размер слишком мал"
+
+msgid "Creating partition..."
+msgstr "Создание раздела..."
+
+msgid "Partition created successfully"
+msgstr "Раздел успешно создан"
+
+msgid "Failed to create partition"
+msgstr "Не удалось создать раздел"
+
+msgid "Format Partition"
+msgstr "Форматировать раздел"
+
+msgid "Warning"
+msgstr "Предупреждение"
+
+msgid "This will erase all data on /dev/%s"
+msgstr "Это удалит все данные на /dev/%s"
+
+msgid "Formatting partition..."
+msgstr "Форматирование раздела..."
+
+msgid "Partition formatted successfully"
+msgstr "Раздел успешно отформатирован"
+
+msgid "Failed to format partition"
+msgstr "Не удалось отформатировать раздел"
+
+msgid "Delete Partition"
+msgstr "Удалить раздел"
+
+msgid "Are you sure you want to continue?"
+msgstr "Вы уверены, что хотите продолжить?"
+
+msgid "Deleting partition..."
+msgstr "Удаление раздела..."
+
+msgid "Partition deleted successfully"
+msgstr "Раздел успешно удалён"
+
+msgid "Failed to delete partition"
+msgstr "Не удалось удалить раздел"
+
+msgid "No partitions to mount"
+msgstr "Нет разделов для монтирования"
+
+msgid "No mounted partitions found"
+msgstr "Не найдено смонтированных разделов"
+
+msgid "No partitions to unmount"
+msgstr "Нет разделов для размонтирования"
+
+msgid "Mounted to %s"
+msgstr "Смонтировано в %s"
+
+msgid "Unmounted %s"
+msgstr "Размонтировано %s"
+
+msgid "Failed to mount: "
+msgstr "Не удалось смонтировать: "
+
+msgid "Failed to unmount: "
+msgstr "Не удалось размонтировать: "
+
+msgid "Failed to check operation status: "
+msgstr "Не удалось проверить статус операции: "
+
+msgid "Partition created but device node did not appear in time"
+msgstr "Раздел создан, но узел устройства не появился вовремя"
+
+msgid "Partition created but device node did not appear; please refresh manually"
+msgstr "Раздел создан, но узел устройства не появился; обновите вручную"
+
+msgid "PASSED"
+msgstr "ПРОЙДЕН"
+
+msgid "FAILED"
+msgstr "НЕ ПРОЙДЕН"
+
+msgid "Cannot create partition on mounted disk. Please unmount first."
+msgstr "Невозможно создать раздел на смонтированном диске. Сначала размонтируйте."
+
+msgid "No unallocated space available on this disk"
+msgstr "На этом диске нет нераспределённого места"
+
+msgid "Cannot format mounted partition. Please unmount first."
+msgstr "Невозможно отформатировать смонтированный раздел. Сначала размонтируйте."
+
+msgid "Failed to refresh partition data: "
+msgstr "Не удалось обновить данные раздела: "
+
+msgid "Cannot delete partition on mounted disk. Please unmount first."
+msgstr "Невозможно удалить раздел на смонтированном диске. Сначала размонтируйте."
+
+msgid "This will delete partition /dev/%s and all its data!"
+msgstr "Это удалит раздел /dev/%s и все его данные!"
+
+msgid "Failed to load disk information: "
+msgstr "Не удалось загрузить информацию о диске: "
+
+msgid "Click to select"
+msgstr "Нажмите для выбора"
+
+msgid "System partition cannot be selected"
+msgstr "Системный раздел не может быть выбран"
+
+msgid "Free"
+msgstr "Свободно"
+
+msgid "Select a disk"
+msgstr "Выберите диск"
+
+msgid "Create a new partition on the selected disk"
+msgstr "Создать новый раздел на выбранном диске"
+
+msgid "Partition layout"
+msgstr "Схема разделов"
+
+msgid "Partition type"
+msgstr "Тип раздела"
+
+msgid "Refresh partition data"
+msgstr "Обновить данные разделов"
+
+msgid "MBR (Master Boot Record)"
+msgstr "MBR (Главная загрузочная запись)"
+
+msgid "GPT (GUID Partition Table)"
+msgstr "GPT (Таблица разделов GUID)"
+
+msgid "The Mini Disk Manager package allows users to easily manage disks and partitions."
+msgstr "Пакет Mini Disk Manager позволяет пользователям легко управлять дисками и разделами."
+
+msgid "Configuration"
+msgstr "Конфигурация"
+
+msgid "Package and Driver Verification"
+msgstr "Проверка пакетов и драйверов"
+
+msgid "Check and install required drivers for storage devices."
+msgstr "Проверка и установка необходимых драйверов для устройств хранения."
+
+msgid "Filesystem Support"
+msgstr "Поддержка файловых систем"
+
+msgid "Check USB drivers"
+msgstr "Проверить драйверы USB"
+
+msgid "USB drivers"
+msgstr "Драйверы USB"
+
+msgid "Check NVMe drivers"
+msgstr "Проверить драйверы NVMe"
+
+msgid "NVMe drivers"
+msgstr "Драйверы NVMe"
+
+msgid "Check ATA/SATA drivers"
+msgstr "Проверить драйверы ATA/SATA"
+
+msgid "ATA/SATA drivers"
+msgstr "Драйверы ATA/SATA"
+
+msgid "Check Linux filesystem packages"
+msgstr "Проверить пакеты файловых систем Linux"
+
+msgid "Linux filesystems"
+msgstr "Файловые системы Linux"
+
+msgid "Check Windows filesystem packages"
+msgstr "Проверить пакеты файловых систем Windows"
+
+msgid "Windows filesystems"
+msgstr "Файловые системы Windows"
+
+msgid "Linux Filesystem Packages"
+msgstr "Пакеты файловых систем Linux"
+
+msgid "Windows Filesystem Packages"
+msgstr "Пакеты файловых систем Windows"
+
+msgid "Disk Manager Log"
+msgstr "Журнал менеджера дисков"
+
+msgid "Loading package data…"
+msgstr "Загрузка данных пакетов…"
+
+msgid "Loading log file…"
+msgstr "Загрузка файла журнала…"
+
+msgid "Log file content"
+msgstr "Содержимое файла журнала"
+
+msgid "Log file is empty"
+msgstr "Файл журнала пуст"
+
+msgid "Unable to read log file"
+msgstr "Невозможно прочитать файл журнала"
+
+msgid "Log file cleared successfully"
+msgstr "Файл журнала успешно очищен"
+
+msgid "Unable to clear the file"
+msgstr "Невозможно очистить файл"
+
+msgid "Installed"
+msgstr "Установлено"
+
+msgid "Install…"
+msgstr "Установить…"
+
+msgid "Clear"
+msgstr "Очистить"
+
+msgid "Download"
+msgstr "Скачать"
+
+msgid "Close"
+msgstr "Закрыть"
+
+msgid "Failed to load package data"
+msgstr "Не удалось загрузить данные пакета"
+
+msgid "more info in log"
+msgstr "подробности в журнале"
+
+msgid "The tab allows users to support the package."
+msgstr "Вкладка позволяет пользователям поддержать пакет."
+
+msgid "Package support"
+msgstr "Поддержка пакета"
+
+msgid "Mini Disk Manager Info"
+msgstr "Информация о Mini Disk Manager"
+
+msgid "Luci-app-mdmanager"
+msgstr "Luci-app-mdmanager"
+
+msgid "Buy a coffee"
+msgstr "Угостить кофе"
+
+msgid "Buy a coffee if you want to support the development of the project and the author"
+msgstr "Угостите кофе, если хотите поддержать разработку проекта и автора"
+
+msgid "Become a sponsor"
+msgstr "Стать спонсором"
+
+msgid "Become a sponsor if you want to support the development of the project and the author"
+msgstr "Станьте спонсором, если хотите поддержать разработку проекта и автора"
+
+msgid "Write on forum"
+msgstr "Написать на форуме"
+
+msgid "Write in the topic of the package on the forum eko.one.pl"
+msgstr "Напишите в теме пакета на форуме eko.one.pl"
+
+msgid "Open discussion"
+msgstr "Открыть обсуждение"
+
+msgid "Open a package discussion on Github"
+msgstr "Открыть обсуждение пакета на Github"
+
+msgid "Report a bug"
+msgstr "Сообщить об ошибке"
+
+msgid "Report a bug on the package Github page"
+msgstr "Сообщить об ошибке на странице пакета в Github"
+
+msgid "Package name"
+msgstr "Название пакета"
+
+msgid "Author (package maintainer)"
+msgstr "Автор (сопровождающий пакета)"
+
+msgid "Information about package author and available support options."
+msgstr "Информация об авторе пакета и доступных вариантах поддержки."
+
+# --
+
+msgid "All available space"
+msgstr "Всё доступное место"
+
+msgid "Cannot delete mounted partition. Please unmount first."
+msgstr "Невозможно удалить смонтированный раздел. Сначала размонтируйте."
+
+msgid "Failed to create partition: "
+msgstr "Не удалось создать раздел: "
+
+msgid "Failed to detect supported filesystems"
+msgstr "Не удалось обнаружить поддерживаемые файловые системы"
+
+msgid "Failed to format partition: "
+msgstr "Не удалось отформатировать раздел: "
+
+msgid "Failed to parse JSON response: "
+msgstr "Не удалось разобрать JSON-ответ: "
+
+msgid "Failed to start formatting"
+msgstr "Не удалось начать форматирование"
+
+msgid "Failed to start partition creation"
+msgstr "Не удалось начать создание раздела"
+
+msgid "Failed to start partition deletion"
+msgstr "Не удалось начать удаление раздела"
+
+msgid "Fill in size"
+msgstr "Заполните размер"
+
+msgid "Linux Swap"
+msgstr "Linux Swap"
+
+msgid "Loading..."
+msgstr "Загрузка..."
+
+msgid "No filesystem packages detected — user cannot choose unsupported filesystem formats."
+msgstr "Пакеты файловых систем не обнаружены — пользователь не может выбрать неподдерживаемые форматы файловых систем."
+
+msgid "No partition types available. Maximum partitions reached."
+msgstr "Нет доступных типов разделов. Достигнуто максимальное количество разделов."
+
+msgid "No supported filesystems detected on this system"
+msgstr "В этой системе не обнаружено поддерживаемых файловых систем"
+
+msgid "Optional"
+msgstr "Необязательно"
+
+msgid "Partition created but selected filesystem is not available for formatting on this system"
+msgstr "Раздел создан, но выбранная файловая система недоступна для форматирования в этой системе"
+
+msgid "Partition data refreshed"
+msgstr "Данные раздела обновлены"
+
+msgid "Please select a filesystem"
+msgstr "Выберите файловую систему"
+
+msgid "RPC call failed: "
+msgstr "Вызов RPC не удался: "
+
+msgid "Refreshing..."
+msgstr "Обновление..."
+
+msgid "Selected filesystem is not supported on this system"
+msgstr "Выбранная файловая система не поддерживается в этой системе"
+
+msgid "Selected partition is not mounted"
+msgstr "Выбранный раздел не смонтирован"
+
+msgid "unknown error"
+msgstr "неизвестная ошибка"
+
+msgid "Packages & Drivers"
+msgstr "Пакеты и драйверы"
+
+msgid "Mini Disk Manager log"
+msgstr "Журнал Mini Disk Manager"
+
+msgid "Mini Disk Manager Log"
+msgstr "Журнал Mini Disk Manager"
+
+msgid "Packages required to support various file systems."
+msgstr "Пакеты, необходимые для поддержки различных файловых систем."
+
+msgid "Expand"
+msgstr "Расширить"
+
+msgid "Resize"
+msgstr "Изменить размер"
+
+msgid "Resize Partition"
+msgstr "Изменить размер раздела"
+
+msgid "Resize partition /dev/%s"
+msgstr "Изменить размер раздела /dev/%s"
+
+msgid "Resizing partition..."
+msgstr "Изменение размера раздела..."
+
+msgid "Resizing a partition can cause data loss if not done correctly."
+msgstr "Изменение размера раздела может привести к потере данных, если выполнено неправильно."
+
+msgid "Please ensure you have a backup of important data before proceeding."
+msgstr "Убедитесь, что у вас есть резервная копия важных данных перед продолжением."
+
+msgid "Current size: %s MB / %s GB / %s TB"
+msgstr "Текущий размер: %s МБ / %s ГБ / %s ТБ"
+
+msgid "Available space: %s MB / %s GB / %s TB"
+msgstr "Доступное место: %s МБ / %s ГБ / %s ТБ"
+
+msgid "Maximum size to be obtained: %s MB / %s GB / %s TB"
+msgstr "Максимальный размер для получения: %s МБ / %s ГБ / %s ТБ"
+
+msgid "Maximum new size"
+msgstr "Максимальный новый размер"
+
+msgid "New size"
+msgstr "Новый размер"
+
+msgid "Enter new size"
+msgstr "Введите новый размер"
+
+msgid "New size must be larger than current size"
+msgstr "Новый размер должен быть больше текущего размера"
+
+msgid "New size exceeds available space"
+msgstr "Новый размер превышает доступное место"
+
+msgid "Partition resized successfully"
+msgstr "Размер раздела успешно изменён"
+
+msgid "Failed to resize partition"
+msgstr "Не удалось изменить размер раздела"
+
+msgid "Failed to resize partition: "
+msgstr "Не удалось изменить размер раздела: "
+
+msgid "Failed to start partition resize"
+msgstr "Не удалось начать изменение размера раздела"
+
+msgid "Selected partition cannot be resized. Only unmounted Ext2/3/4 partitions with available space can be resized."
+msgstr "Выбранный раздел не может быть изменён. Изменять размер можно только для размонтированных разделов Ext2/3/4 с доступным местом."
+
+msgid "MB"
+msgstr "МБ"
+
+msgid "GB"
+msgstr "ГБ"
+
+msgid "TB"
+msgstr "ТБ"
+
+msgid "Cannot Create Partition"
+msgstr "Невозможно создать раздел"
+
+msgid "Insufficient Space"
+msgstr "Недостаточно места"
+
+msgid "Cannot read partition information"
+msgstr "Невозможно прочитать информацию о разделе"
+
+msgid "Invalid extended partition"
+msgstr "Неверный расширенный раздел"
+
+msgid "Extended partition not found or has invalid size"
+msgstr "Расширенный раздел не найден или имеет неверный размер"
+
+msgid "Extended partition size: %s MB"
+msgstr "Размер расширенного раздела: %s МБ"
+
+msgid "Used by logical partitions: %s MB"
+msgstr "Использовано логическими разделами: %s МБ"
+
+msgid "Available for new logical: %s MB"
+msgstr "Доступно для нового логического: %s МБ"
+
+msgid "Required minimum: 10 MB"
+msgstr "Требуемый минимум: 10 МБ"
+
+msgid "Not enough free space in extended partition /dev/%s"
+msgstr "Недостаточно свободного места в расширенном разделе /dev/%s"
+
+msgid "Extended partition already exists. You can create primary partitions or select the extended partition to create logical partitions inside."
+msgstr "Расширенный раздел уже существует. Вы можете создать первичные разделы или выбрать расширенный раздел для создания логических разделов внутри."
+
+msgid "Creating partition inside extended partition. Only logical partitions can be created here."
+msgstr "Создание раздела внутри расширенного раздела. Здесь можно создавать только логические разделы."
+
+msgid "No partition table detected. A primary partition will be created and a partition table will be initialized."
+msgstr "Таблица разделов не обнаружена. Будет создан первичный раздел и инициализирована таблица разделов."
+
+msgid "No partition table - select to create"
+msgstr "Нет таблицы разделов - выберите для создания"
+
+msgid "No partitions - select to create"
+msgstr "Нет разделов - выберите для создания"
+
+msgid "Select to enable partition creation"
+msgstr "Выберите для включения создания раздела"
+
+msgid "Select unallocated space"
+msgstr "Выберите нераспределённое место"
+
+msgid "Unallocated space"
+msgstr "Нераспределённое место"
+
+msgid "Expand Ext2/Ext3/Ext4"
+msgstr "Расширить Ext2/Ext3/Ext4"
+
+msgid "Wipe"
+msgstr "Очистить"
+
+msgid "Select all partitions for wiping"
+msgstr "Выбрать все разделы для очистки"
+
+msgid "Please enable wipe mode first"
+msgstr "Сначала включите режим стирания"
+
+msgid "Cannot wipe disk with mounted partitions. Please unmount all partitions first."
+msgstr "Невозможно стереть диск с подключёнными разделами. Сначала отключите все разделы."
+
+msgid "Wipe Disk"
+msgstr "Стереть диск"
+
+msgid "WARNING"
+msgstr "ПРЕДУПРЕЖДЕНИЕ"
+
+msgid "This will completely erase the partition table and all data on /dev/%s!"
+msgstr "Это полностью удалит таблицу разделов и все данные на /dev/%s!"
+
+msgid "All partitions will be deleted and the disk will be unallocated."
+msgstr "Все разделы будут удалены, и диск станет нераспределённым."
+
+msgid "THIS OPERATION CANNOT BE UNDONE!"
+msgstr "ЭТУ ОПЕРАЦИЮ НЕВОЗМОЖНО ОТМЕНИТЬ!"
+
+msgid "Number of partitions to be deleted: %d"
+msgstr "Количество разделов для удаления: %d"
+
+msgid "Are you absolutely sure you want to continue?"
+msgstr "Вы абсолютно уверены, что хотите продолжить?"
+
+msgid "Wiping disk partition table..."
+msgstr "Очистка таблицы разделов диска..."
+
+msgid "Disk partition table has been successfully erased"
+msgstr "Таблица разделов диска успешно удалена"
+
+msgid "Failed to wipe disk"
+msgstr "Не удалось стереть диск"
+
+msgid "Failed to start disk wipe"
+msgstr "Не удалось начать стирание диска"
+
+msgid "Failed to wipe disk: "
+msgstr "Не удалось стереть диск: "
+
+msgid "Disk Wipe Support"
+msgstr "Поддержка стирания диска"
+
+msgid "Packages required to support disk wiping functionality (clearing partition table)."
+msgstr "Пакеты, необходимые для поддержки функции очистки диска (очистка таблицы разделов)."
+
+msgid "Check Disk Wipe packages"
+msgstr "Проверить пакеты очистки диска"
+
+msgid "Disk Wipe"
+msgstr "Стирание диска"
+
+msgid "dd from BusyBox"
+msgstr "dd из BusyBox"
+
+msgid "Disk Wipe (dd command)"
+msgstr "Стирание диска (команда dd)"
+
+msgid "alternative"
+msgstr "альтернатива"
+
+# SMART
+
+msgid "Attribute"
+msgstr "Атрибут"
+
+msgid "Id"
+msgstr "Id"
+
+msgid "Raw"
+msgstr "Сырой"
+
+msgid "Value"
+msgstr "Значение"
+
+msgid "Worst"
+msgstr "Худшее"
+
+msgid "Thresh"
+msgstr "Порог"
+
+msgid "Value"
+msgstr "Значение"
+
+msgid "NVMe S.M.A.R.T. Health Status"
+msgstr "Состояние здоровья NVMe S.M.A.R.T."
+
+msgid "OK"
+msgstr "ОК"
+
+msgid "WARNING"
+msgstr "ПРЕДУПРЕЖДЕНИЕ"
+
+msgid "Power On Time"
+msgstr "Время работы"
+
+msgid "Power On Hours"
+msgstr "Часы работы"
+
+msgid "Disk Usage"
+msgstr "Использование диска"
+
+msgid "Disk Wear Level"
+msgstr "Уровень износа диска"
+
+msgid "Available Spare"
+msgstr "Доступный резерв"
+
+msgid "Available Spare Threshold"
+msgstr "Порог доступного резерва"
+
+msgid "hour"
+msgstr "час"
+
+msgid "hours"
+msgstr "часов"
+
+msgid "h"
+msgstr "ч"
+
+msgid "year"
+msgstr "год"
+
+msgid "years"
+msgstr "лет"
+
+msgid "month"
+msgstr "месяц"
+
+msgid "months"
+msgstr "месяцев"
+
+msgid "day"
+msgstr "день"
+
+msgid "days"
+msgstr "дней"
+
+msgid "worn"
+msgstr "изношено"
+
+msgid "remaining"
+msgstr "осталось"
+
+msgid "S.M.A.R.T. Health Status"
+msgstr "Общее состояние здоровья диска S.M.A.R.T."
+
+msgid "No S.M.A.R.T. attributes found."
+msgstr "Атрибуты S.M.A.R.T. не найдены."
+
+msgid "Loading S.M.A.R.T. data..."
+msgstr "Загрузка данных S.M.A.R.T..."
+
+msgid "Unable to read S.M.A.R.T. data."
+msgstr "Невозможно прочитать данные S.M.A.R.T."
+
+msgid "Error reading S.M.A.R.T. data."
+msgstr "Ошибка чтения данных S.M.A.R.T."
+
+# SMART & Disk Info
+
+msgid "Raw Read Error Rate"
+msgstr "Частота ошибок чтения"
+
+msgid "Throughput Performance"
+msgstr "Производительность пропускной способности"
+
+msgid "Spin Up Time"
+msgstr "Время раскрутки"
+
+msgid "Start Stop Count"
+msgstr "Количество запусков/остановок"
+
+msgid "Reallocated Sector Count"
+msgstr "Количество переназначенных секторов"
+
+msgid "Seek Error Rate"
+msgstr "Частота ошибок позиционирования"
+
+msgid "Seek Time Performance"
+msgstr "Производительность позиционирования"
+
+msgid "Power On Hours"
+msgstr "Время работы"
+
+msgid "Spin Retry Count"
+msgstr "Количество повторов раскрутки"
+
+msgid "Calibration Retry Count"
+msgstr "Количество повторов калибровки"
+
+msgid "Power Cycle Count"
+msgstr "Количество циклов питания"
+
+msgid "Read Soft Error Rate"
+msgstr "Частота мягких ошибок чтения"
+
+msgid "Airflow Temperature"
+msgstr "Температура воздушного потока"
+
+msgid "Temperature Celsius"
+msgstr "Температура"
+
+msgid "Hardware ECC Recovered"
+msgstr "Ошибки ECC исправлены аппаратно"
+
+msgid "Current Pending Sector"
+msgstr "Нестабильные сектора"
+
+msgid "Offline Uncorrectable"
+msgstr "Неисправимые сектора offline"
+
+msgid "UDMA CRC Error Count"
+msgstr "Количество ошибок CRC UDMA"
+
+msgid "Multi Zone Error Rate"
+msgstr "Частота многозонных ошибок"
+
+msgid "Wear Leveling Count"
+msgstr "Счетчик износа"
+
+msgid "Used Reserved Block Count Total"
+msgstr "Использованные резервные блоки (всего)"
+
+msgid "Used Reserved Block Count Chip"
+msgstr "Использованные резервные блоки (чип)"
+
+msgid "Unused Reserved Block Count Total"
+msgstr "Неиспользованные резервные блоки"
+
+msgid "Program Fail Count Total"
+msgstr "Количество ошибок записи"
+
+msgid "Erase Fail Count Total"
+msgstr "Количество ошибок стирания"
+
+msgid "Runtime Bad Block"
+msgstr "Поврежденные блоки"
+
+msgid "Uncorrectable Error Count"
+msgstr "Количество неисправимых ошибок"
+
+msgid "Temperature Exceed Count"
+msgstr "Количество превышений температуры"
+
+msgid "Erase Fail Count"
+msgstr "Количество ошибок стирания"
+
+msgid "Reported Uncorrectable Errors"
+msgstr "Зарегистрированные неисправимые ошибки"
+
+msgid "High Fly Writes"
+msgstr "Записи на большой высоте"
+
+msgid "G-Sense Error Rate"
+msgstr "Частота ошибок G-сенсора"
+
+msgid "Power-Off Retract Count"
+msgstr "Количество отводов головок при отключении"
+
+msgid "Load Cycle Count"
+msgstr "Количество циклов парковки головок"
+
+msgid "Temperature Case"
+msgstr "Температура корпуса"
+
+msgid "Reallocated Event Count"
+msgstr "Количество событий переназначения"
+
+msgid "Transfer Error Rate"
+msgstr "Частота ошибок передачи"
+
+msgid "Free Fall Sensor"
+msgstr "Датчик свободного падения"
+
+msgid "Total LBAs Written"
+msgstr "Всего записано LBA"
+
+msgid "Total LBAs Read"
+msgstr "Всего считано LBA"
+
+msgid "Read Error Retry Rate"
+msgstr "Частота повторов чтения"
+
+msgid "Minimum W/E Cycle"
+msgstr "Минимальный цикл записи/стирания"
+
+msgid "Maximum W/E Cycle"
+msgstr "Максимальный цикл записи/стирания"
+
+msgid "Average W/E Cycle"
+msgstr "Средний цикл записи/стирания"
+
+msgid "Media Wearout Indicator"
+msgstr "Индикатор износа носителя"
+
+msgid "Available Reserved Space"
+msgstr "Доступное резервное пространство"
+
+msgid "SSD Life Left"
+msgstr "Остаточный ресурс SSD"
+
+msgid "Remaining Lifetime Percentage"
+msgstr "Остаточный ресурс (процент)"
+
+msgid "Percentage Lifetime Remaining"
+msgstr "Процент остаточного ресурса"
+
+msgid "Remaining Life"
+msgstr "Остаточный ресурс"
+
+msgid "Lifetime Writes GiB"
+msgstr "Записано данных (ГиБ)"
+
+msgid "Lifetime Reads GiB"
+msgstr "Считано данных (ГиБ)"
+
+msgid "Program Fail Count"
+msgstr "Количество ошибок программирования"
+
+msgid "Unexpected Power Loss Count"
+msgstr "Количество неожиданных отключений питания"
+
+msgid "Thermal Throttle Status"
+msgstr "Состояние тепловой защиты"
+
+msgid "End-to-End Error"
+msgstr "Сквозная ошибка"
+
+msgid "Workload Host Reads Percentage"
+msgstr "Процент чтений хоста"
+
+msgid "Workload Media Wear Indicator"
+msgstr "Индикатор износа носителя (нагрузка)"
+
+msgid "Timed Workload Media Wear"
+msgstr "Износ носителя (временная нагрузка)"
+
+msgid "Workload Timer"
+msgstr "Таймер нагрузки"
+
+msgid "Percentage Rated Life Used"
+msgstr "Процент использованного ресурса"
+
+msgid "Head Flying Hours"
+msgstr "Часы полета головок"
+
+msgid "Read Channel Margin"
+msgstr "Запас канала чтения"
+
+msgid "Loaded Hours"
+msgstr "Часы работы с распаркованными головками"
+
+msgid "Load/Unload Retry Count"
+msgstr "Количество повторов парковки/распарковки"
+
+msgid "GMR Head Amplitude"
+msgstr "Амплитуда головки GMR"
+
+msgid "Drive Temperature"
+msgstr "Температура диска"
+
+msgid "Endurance Remaining"
+msgstr "Остаточная выносливость"
+
+msgid "Power On Hours and Milliseconds"
+msgstr "Время работы (часы и миллисекунды)"
+
+msgid "Head Health"
+msgstr "Состояние головок"
+
+msgid "POR Recovery Count"
+msgstr "Количество восстановлений POR"
+
+msgid "Unused Reserve NAND Blocks"
+msgstr "Неиспользованные резервные блоки NAND"
+
+msgid "SSD Protect Mode"
+msgstr "Режим защиты SSD"
+
+msgid "Host Writes 32MiB"
+msgstr "Записи хоста (32 МиБ)"
+
+msgid "NAND Writes 32MiB"
+msgstr "Записи NAND (32 МиБ)"
+
+msgid "Remaining Life Left"
+msgstr "Остаточный ресурс"
+
+msgid "Grown Bad Block Count"
+msgstr "Количество новых поврежденных блоков"
+
+msgid "Soft Read Error Rate"
+msgstr "Частота мягких ошибок чтения"
+
+msgid "Data Address Mark Errors"
+msgstr "Ошибки маркера адреса данных"
+
+msgid "Run Out Cancel"
+msgstr "Отмена переполнения"
+
+msgid "Soft ECC Correction"
+msgstr "Мягкая коррекция ECC"
+
+msgid "TA Increase Count"
+msgstr "Количество увеличений TA"
+
+msgid "Shock Count Write Operation"
+msgstr "Количество ударов при записи"
+
+msgid "Shock Rate Write Operation"
+msgstr "Частота ударов при записи"
+
+msgid "Flying Height"
+msgstr "Высота полета головок"
+
+msgid "Spin High Current"
+msgstr "Высокий ток запуска"
+
+msgid "Spin Buzz"
+msgstr "Жужжание при запуске"
+
+msgid "Offline Seek Performance"
+msgstr "Производительность позиционирования offline"
+
+msgid "Vibration During Write"
+msgstr "Вибрации при записи"
+
+msgid "Shock During Write"
+msgstr "Удары при записи"
+
+msgid "Disk Shift"
+msgstr "Смещение диска"
+
+msgid "Load Retry Count"
+msgstr "Количество повторов загрузки"
+
+msgid "Load Friction"
+msgstr "Трение при загрузке"
+
+msgid "Load-in Time"
+msgstr "Время загрузки"
+
+msgid "Torque Amplification Count"
+msgstr "Количество усилений крутящего момента"
+
+msgid "Write Error Rate"
+msgstr "Частота ошибок записи"
+
+msgid "Serial Number"
+msgstr "Серийный номер"
+
+msgid "LU WWN Device Id"
+msgstr "Идентификатор устройства LU WWN"
+
+msgid "Firmware Version"
+msgstr "Версия прошивки"
+
+msgid "User Capacity"
+msgstr "Полезная емкость"
+
+msgid "Capacity"
+msgstr "Емкость"
+
+msgid "Sector Size"
+msgstr "Размер сектора"
+
+msgid "Sector Sizes"
+msgstr "Размеры секторов"
+
+msgid "Rotation Rate"
+msgstr "Скорость вращения"
+
+msgid "Form Factor"
+msgstr "Форм-фактор"
+
+msgid "Device is"
+msgstr "Устройство"
+
+msgid "ATA Version is"
+msgstr "Версия ATA"
+
+msgid "SATA Version is"
+msgstr "Версия SATA"
+
+msgid "Local Time is"
+msgstr "Местное время"
+
+msgid "SMART support is"
+msgstr "Поддержка SMART"
+
+msgid "SMART Status"
+msgstr "Состояние SMART"
+
+msgid "Device"
+msgstr "Устройство"
+
+msgid "Model Number"
+msgstr "Модель"
+
+msgid "Firmware Revision"
+msgstr "Ревизия прошивки"
+
+msgid "PCI Vendor/Subsystem ID"
+msgstr "ID производителя/подсистемы PCI"
+
+msgid "IEEE OUI Identifier"
+msgstr "Идентификатор IEEE OUI"
+
+msgid "Total NVM Capacity"
+msgstr "Общая емкость NVM"
+
+msgid "Unallocated NVM Capacity"
+msgstr "Нераспределенная емкость NVM"
+
+msgid "Controller ID"
+msgstr "ID контроллера"
+
+msgid "Number of Namespaces"
+msgstr "Количество адресных пространств"
+
+msgid "Namespace 1 Size/Capacity"
+msgstr "Размер/емкость адресного пространства 1"
+
+msgid "Namespace 1 Formatted LBA Size"
+msgstr "Размер LBA адресного пространства 1"
+
+msgid "Namespace 1 IEEE EUI-64"
+msgstr "IEEE EUI-64 адресного пространства 1"
+
+msgid "logical/physical"
+msgstr "логический/физический"
+
+msgid "bytes"
+msgstr "байт"
+
+msgid "blocks"
+msgstr "блоков"
+
+msgid "Solid State Device"
+msgstr "Твердотельный накопитель"
+
+# Reserved space
+
+msgid "Reserved space"
+msgstr "Зарезервированное пространство"
+
+msgid "Space reserved for root (default: 5%)"
+msgstr "Пространство, зарезервированное для root (по умолчанию: 5%)"
+
+msgid "Used Reserved Block Count Total"
+msgstr "Общее количество использованных зарезервированных блоков"
+
+msgid "Used Reserved Block Count Chip"
+msgstr "Количество использованных зарезервированных блоков на микросхеме"
+
+msgid "Unused Reserved Block Count Total"
+msgstr "Общее количество неиспользованных зарезервированных блоков"
+
+msgid "Available Reserved Space"
+msgstr "Доступное зарезервированное пространство"
+
+# NVMe
+
+msgid "Critical Warning"
+msgstr "Критическое предупреждение"
+
+msgid "Percentage Used"
+msgstr "Процент использования"
+
+msgid "Data Units Read"
+msgstr "Прочитанные блоки данных"
+
+msgid "Data Units Written"
+msgstr "Записанные блоки данных"
+
+msgid "Host Read Commands"
+msgstr "Команды чтения хоста"
+
+msgid "Host Write Commands"
+msgstr "Команды записи хоста"
+
+msgid "Controller Busy Time"
+msgstr "Время занятости контроллера"
+
+msgid "Power Cycles"
+msgstr "Циклы питания"
+
+msgid "Unsafe Shutdowns"
+msgstr "Небезопасные отключения"
+
+msgid "Media Errors"
+msgstr "Ошибки носителя"
+
+msgid "Error Log Entries"
+msgstr "Записи журнала ошибок"
diff --git a/package/luci-app-mini-diskmanager/po/vi/mini-diskmanager.po b/package/luci-app-mini-diskmanager/po/vi/mini-diskmanager.po
new file mode 100644
index 0000000000..0b8ca55f2d
--- /dev/null
+++ b/package/luci-app-mini-diskmanager/po/vi/mini-diskmanager.po
@@ -0,0 +1,1251 @@
+msgid ""
+msgstr ""
+"Project-Id-Version: luci-app-sms-manager\n"
+"Language-Team: Rafał Wabik (IceG)\n"
+"Language: vi\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+msgid "Disk Manager"
+msgstr "Trình quản lý đĩa"
+
+msgid "-- Select a disk --"
+msgstr "-- Chọn đĩa --"
+
+msgid "Disk"
+msgstr "Đĩa"
+
+msgid "Refresh"
+msgstr "Làm mới"
+
+msgid "Mounting actions"
+msgstr "Thao tác gắn kết"
+
+msgid "Actions on partitions"
+msgstr "Thao tác trên phân vùng"
+
+msgid "Mount"
+msgstr "Gắn kết"
+
+msgid "Unmount"
+msgstr "Tháo gắn"
+
+msgid "Create"
+msgstr "Tạo"
+
+msgid "Delete"
+msgstr "Xóa"
+
+msgid "Format"
+msgstr "Định dạng"
+
+msgid "Please select a disk to view its partitions"
+msgstr "Vui lòng chọn đĩa để xem các phân vùng của nó"
+
+msgid "Please select a disk first"
+msgstr "Vui lòng chọn đĩa trước"
+
+msgid "Please select a partition first"
+msgstr "Vui lòng chọn phân vùng trước"
+
+msgid "Loading disk information..."
+msgstr "Đang tải thông tin đĩa..."
+
+msgid "Error loading disk information: "
+msgstr "Lỗi khi tải thông tin đĩa: "
+
+msgid "Disk Information"
+msgstr "Thông tin đĩa"
+
+msgid "Temperature"
+msgstr "Nhiệt độ"
+
+msgid "S.M.A.R.T."
+msgstr "S.M.A.R.T."
+
+msgid "S.M.A.R.T. Status"
+msgstr "Trạng thái S.M.A.R.T."
+
+msgid "Partitions"
+msgstr "Phân vùng"
+
+msgid "Mount Status"
+msgstr "Trạng thái gắn kết"
+
+msgid "Mounted"
+msgstr "Đã gắn kết"
+
+msgid "Not mounted"
+msgstr "Chưa gắn kết"
+
+msgid "Partition Layout"
+msgstr "Bố cục phân vùng"
+
+msgid "Partition"
+msgstr "Phân vùng"
+
+msgid "Type / Filesystem"
+msgstr "Loại / Hệ thống tệp"
+
+msgid "Filesystem"
+msgstr "Hệ thống tệp"
+
+msgid "Mount Point"
+msgstr "Điểm gắn kết"
+
+msgid "Label"
+msgstr "Nhãn"
+
+msgid "Size"
+msgstr "Kích thước"
+
+msgid "Used"
+msgstr "Đã dùng"
+
+msgid "Unused"
+msgstr "Còn trống"
+
+msgid "Flags"
+msgstr "Cờ"
+
+msgid "No partitions found"
+msgstr "Không tìm thấy phân vùng"
+
+msgid "Unallocated"
+msgstr "Chưa phân bổ"
+
+msgid "Area without partition table"
+msgstr "Vùng không có bảng phân vùng"
+
+msgid "Free Space"
+msgstr "Dung lượng trống"
+
+msgid "Primary"
+msgstr "Chính"
+
+msgid "Extended"
+msgstr "Mở rộng"
+
+msgid "Logical"
+msgstr "Lôgic"
+
+msgid "Create partition"
+msgstr "Tạo phân vùng"
+
+msgid "Cancel"
+msgstr "Hủy"
+
+msgid "File system"
+msgstr "Hệ thống tệp"
+
+msgid "Volume label"
+msgstr "Nhãn ổ đĩa"
+
+msgid "Partition size"
+msgstr "Kích thước phân vùng"
+
+msgid "Enter size"
+msgstr "Nhập kích thước"
+
+msgid "Use all available space"
+msgstr "Sử dụng toàn bộ dung lượng có sẵn"
+
+msgid "Available: %s MB / %s GB / %s TB"
+msgstr "Có sẵn: %s MB / %s GB / %s TB"
+
+msgid "Please enter a valid size"
+msgstr "Vui lòng nhập kích thước hợp lệ"
+
+msgid "Size is too small"
+msgstr "Kích thước quá nhỏ"
+
+msgid "Creating partition..."
+msgstr "Đang tạo phân vùng..."
+
+msgid "Partition created successfully"
+msgstr "Tạo phân vùng thành công"
+
+msgid "Failed to create partition"
+msgstr "Không thể tạo phân vùng"
+
+msgid "Format Partition"
+msgstr "Định dạng phân vùng"
+
+msgid "Warning"
+msgstr "Cảnh báo"
+
+msgid "This will erase all data on /dev/%s"
+msgstr "Thao tác này sẽ xóa tất cả dữ liệu trên /dev/%s"
+
+msgid "Formatting partition..."
+msgstr "Đang định dạng phân vùng..."
+
+msgid "Partition formatted successfully"
+msgstr "Định dạng phân vùng thành công"
+
+msgid "Failed to format partition"
+msgstr "Không thể định dạng phân vùng"
+
+msgid "Delete Partition"
+msgstr "Xóa phân vùng"
+
+msgid "Are you sure you want to continue?"
+msgstr "Bạn có chắc chắn muốn tiếp tục?"
+
+msgid "Deleting partition..."
+msgstr "Đang xóa phân vùng..."
+
+msgid "Partition deleted successfully"
+msgstr "Xóa phân vùng thành công"
+
+msgid "Failed to delete partition"
+msgstr "Không thể xóa phân vùng"
+
+msgid "No partitions to mount"
+msgstr "Không có phân vùng để gắn kết"
+
+msgid "No mounted partitions found"
+msgstr "Không tìm thấy phân vùng đã gắn kết"
+
+msgid "No partitions to unmount"
+msgstr "Không có phân vùng để tháo gắn"
+
+msgid "Mounted to %s"
+msgstr "Đã gắn kết vào %s"
+
+msgid "Unmounted %s"
+msgstr "Đã tháo gắn %s"
+
+msgid "Failed to mount: "
+msgstr "Không thể gắn kết: "
+
+msgid "Failed to unmount: "
+msgstr "Không thể tháo gắn: "
+
+msgid "Failed to check operation status: "
+msgstr "Không thể kiểm tra trạng thái thao tác: "
+
+msgid "Partition created but device node did not appear in time"
+msgstr "Đã tạo phân vùng nhưng nút thiết bị không xuất hiện kịp thời"
+
+msgid "Partition created but device node did not appear; please refresh manually"
+msgstr "Đã tạo phân vùng nhưng nút thiết bị không xuất hiện; vui lòng làm mới thủ công"
+
+msgid "PASSED"
+msgstr "ĐẠT"
+
+msgid "FAILED"
+msgstr "KHÔNG ĐẠT"
+
+msgid "Cannot create partition on mounted disk. Please unmount first."
+msgstr "Không thể tạo phân vùng trên đĩa đã gắn kết. Vui lòng tháo gắn trước."
+
+msgid "No unallocated space available on this disk"
+msgstr "Không có dung lượng chưa phân bổ trên đĩa này"
+
+msgid "Cannot format mounted partition. Please unmount first."
+msgstr "Không thể định dạng phân vùng đã gắn kết. Vui lòng tháo gắn trước."
+
+msgid "Failed to refresh partition data: "
+msgstr "Không thể làm mới dữ liệu phân vùng: "
+
+msgid "Cannot delete partition on mounted disk. Please unmount first."
+msgstr "Không thể xóa phân vùng trên đĩa đã gắn kết. Vui lòng tháo gắn trước."
+
+msgid "This will delete partition /dev/%s and all its data!"
+msgstr "Thao tác này sẽ xóa phân vùng /dev/%s và tất cả dữ liệu của nó!"
+
+msgid "Failed to load disk information: "
+msgstr "Không thể tải thông tin đĩa: "
+
+msgid "Click to select"
+msgstr "Nhấp để chọn"
+
+msgid "System partition cannot be selected"
+msgstr "Không thể chọn phân vùng hệ thống"
+
+msgid "Free"
+msgstr "Trống"
+
+msgid "Select a disk"
+msgstr "Chọn đĩa"
+
+msgid "Create a new partition on the selected disk"
+msgstr "Tạo phân vùng mới trên đĩa đã chọn"
+
+msgid "Partition layout"
+msgstr "Bố cục phân vùng"
+
+msgid "Partition type"
+msgstr "Loại phân vùng"
+
+msgid "Refresh partition data"
+msgstr "Làm mới dữ liệu phân vùng"
+
+msgid "MBR (Master Boot Record)"
+msgstr "MBR (Bản ghi khởi động chính)"
+
+msgid "GPT (GUID Partition Table)"
+msgstr "GPT (Bảng phân vùng GUID)"
+
+msgid "The Mini Disk Manager package allows users to easily manage disks and partitions."
+msgstr "Gói Mini Disk Manager cho phép người dùng dễ dàng quản lý đĩa và phân vùng."
+
+msgid "Configuration"
+msgstr "Cấu hình"
+
+msgid "Package and Driver Verification"
+msgstr "Xác minh gói và trình điều khiển"
+
+msgid "Check and install required drivers for storage devices."
+msgstr "Kiểm tra và cài đặt trình điều khiển cần thiết cho thiết bị lưu trữ."
+
+msgid "Filesystem Support"
+msgstr "Hỗ trợ hệ thống tệp"
+
+msgid "Check USB drivers"
+msgstr "Kiểm tra trình điều khiển USB"
+
+msgid "USB drivers"
+msgstr "Trình điều khiển USB"
+
+msgid "Check NVMe drivers"
+msgstr "Kiểm tra trình điều khiển NVMe"
+
+msgid "NVMe drivers"
+msgstr "Trình điều khiển NVMe"
+
+msgid "Check ATA/SATA drivers"
+msgstr "Kiểm tra trình điều khiển ATA/SATA"
+
+msgid "ATA/SATA drivers"
+msgstr "Trình điều khiển ATA/SATA"
+
+msgid "Check Linux filesystem packages"
+msgstr "Kiểm tra gói hệ thống tệp Linux"
+
+msgid "Linux filesystems"
+msgstr "Hệ thống tệp Linux"
+
+msgid "Check Windows filesystem packages"
+msgstr "Kiểm tra gói hệ thống tệp Windows"
+
+msgid "Windows filesystems"
+msgstr "Hệ thống tệp Windows"
+
+msgid "Linux Filesystem Packages"
+msgstr "Gói hệ thống tệp Linux"
+
+msgid "Windows Filesystem Packages"
+msgstr "Gói hệ thống tệp Windows"
+
+msgid "Disk Manager Log"
+msgstr "Nhật ký trình quản lý đĩa"
+
+msgid "Loading package data…"
+msgstr "Đang tải dữ liệu gói…"
+
+msgid "Loading log file…"
+msgstr "Đang tải tệp nhật ký…"
+
+msgid "Log file content"
+msgstr "Nội dung tệp nhật ký"
+
+msgid "Log file is empty"
+msgstr "Tệp nhật ký trống"
+
+msgid "Unable to read log file"
+msgstr "Không thể đọc tệp nhật ký"
+
+msgid "Log file cleared successfully"
+msgstr "Xóa file nhật ký thành công"
+
+msgid "Unable to clear the file"
+msgstr "Không thể xóa file"
+
+msgid "Installed"
+msgstr "Đã cài đặt"
+
+msgid "Install…"
+msgstr "Cài đặt…"
+
+msgid "Clear"
+msgstr "Xóa"
+
+msgid "Download"
+msgstr "Tải xuống"
+
+msgid "Close"
+msgstr "Đóng"
+
+msgid "Failed to load package data"
+msgstr "Không thể tải dữ liệu gói"
+
+msgid "more info in log"
+msgstr "thêm thông tin trong nhật ký"
+
+msgid "The tab allows users to support the package."
+msgstr "Tab này cho phép người dùng hỗ trợ gói."
+
+msgid "Package support"
+msgstr "Hỗ trợ gói"
+
+msgid "Mini Disk Manager Info"
+msgstr "Thông tin Mini Disk Manager"
+
+msgid "Luci-app-mdmanager"
+msgstr "Luci-app-mdmanager"
+
+msgid "Buy a coffee"
+msgstr "Mua cà phê"
+
+msgid "Buy a coffee if you want to support the development of the project and the author"
+msgstr "Mua cà phê nếu bạn muốn hỗ trợ phát triển dự án và tác giả"
+
+msgid "Become a sponsor"
+msgstr "Trở thành nhà tài trợ"
+
+msgid "Become a sponsor if you want to support the development of the project and the author"
+msgstr "Trở thành nhà tài trợ nếu bạn muốn hỗ trợ phát triển dự án và tác giả"
+
+msgid "Write on forum"
+msgstr "Viết trên diễn đàn"
+
+msgid "Write in the topic of the package on the forum eko.one.pl"
+msgstr "Viết trong chủ đề của gói trên diễn đàn eko.one.pl"
+
+msgid "Open discussion"
+msgstr "Mở thảo luận"
+
+msgid "Open a package discussion on Github"
+msgstr "Mở thảo luận về gói trên Github"
+
+msgid "Report a bug"
+msgstr "Báo cáo lỗi"
+
+msgid "Report a bug on the package Github page"
+msgstr "Báo cáo lỗi trên trang Github của gói"
+
+msgid "Package name"
+msgstr "Tên gói"
+
+msgid "Author (package maintainer)"
+msgstr "Tác giả (người bảo trì gói)"
+
+msgid "Information about package author and available support options."
+msgstr "Thông tin về tác giả gói và các tùy chọn hỗ trợ có sẵn."
+
+# --
+
+msgid "All available space"
+msgstr "Toàn bộ dung lượng có sẵn"
+
+msgid "Cannot delete mounted partition. Please unmount first."
+msgstr "Không thể xóa phân vùng đã gắn kết. Vui lòng tháo gắn trước."
+
+msgid "Failed to create partition: "
+msgstr "Không thể tạo phân vùng: "
+
+msgid "Failed to detect supported filesystems"
+msgstr "Không thể phát hiện hệ thống tệp được hỗ trợ"
+
+msgid "Failed to format partition: "
+msgstr "Không thể định dạng phân vùng: "
+
+msgid "Failed to parse JSON response: "
+msgstr "Không thể phân tích phản hồi JSON: "
+
+msgid "Failed to start formatting"
+msgstr "Không thể bắt đầu định dạng"
+
+msgid "Failed to start partition creation"
+msgstr "Không thể bắt đầu tạo phân vùng"
+
+msgid "Failed to start partition deletion"
+msgstr "Không thể bắt đầu xóa phân vùng"
+
+msgid "Fill in size"
+msgstr "Điền kích thước"
+
+msgid "Linux Swap"
+msgstr "Linux Swap"
+
+msgid "Loading..."
+msgstr "Đang tải..."
+
+msgid "No filesystem packages detected — user cannot choose unsupported filesystem formats."
+msgstr "Không phát hiện gói hệ thống tệp — người dùng không thể chọn định dạng hệ thống tệp không được hỗ trợ."
+
+msgid "No partition types available. Maximum partitions reached."
+msgstr "Không có loại phân vùng nào khả dụng. Đã đạt số lượng phân vùng tối đa."
+
+msgid "No supported filesystems detected on this system"
+msgstr "Không phát hiện hệ thống tệp được hỗ trợ trên hệ thống này"
+
+msgid "Optional"
+msgstr "Tùy chọn"
+
+msgid "Partition created but selected filesystem is not available for formatting on this system"
+msgstr "Đã tạo phân vùng nhưng hệ thống tệp đã chọn không khả dụng để định dạng trên hệ thống này"
+
+msgid "Partition data refreshed"
+msgstr "Dữ liệu phân vùng đã được làm mới"
+
+msgid "Please select a filesystem"
+msgstr "Vui lòng chọn hệ thống tệp"
+
+msgid "RPC call failed: "
+msgstr "Cuộc gọi RPC thất bại: "
+
+msgid "Refreshing..."
+msgstr "Đang làm mới..."
+
+msgid "Selected filesystem is not supported on this system"
+msgstr "Hệ thống tệp đã chọn không được hỗ trợ trên hệ thống này"
+
+msgid "Selected partition is not mounted"
+msgstr "Phân vùng đã chọn chưa được gắn kết"
+
+msgid "unknown error"
+msgstr "lỗi không xác định"
+
+msgid "Packages & Drivers"
+msgstr "Gói và trình điều khiển"
+
+msgid "Mini Disk Manager log"
+msgstr "Nhật ký Mini Disk Manager"
+
+msgid "Mini Disk Manager Log"
+msgstr "Nhật ký Mini Disk Manager"
+
+msgid "Packages required to support various file systems."
+msgstr "Các gói cần thiết để hỗ trợ các hệ thống tệp khác nhau."
+
+msgid "Expand"
+msgstr "Mở rộng"
+
+msgid "Resize"
+msgstr "Thay đổi kích thước"
+
+msgid "Resize Partition"
+msgstr "Thay đổi kích thước phân vùng"
+
+msgid "Resize partition /dev/%s"
+msgstr "Thay đổi kích thước phân vùng /dev/%s"
+
+msgid "Resizing partition..."
+msgstr "Đang thay đổi kích thước phân vùng..."
+
+msgid "Resizing a partition can cause data loss if not done correctly."
+msgstr "Thay đổi kích thước phân vùng có thể gây mất dữ liệu nếu không được thực hiện đúng cách."
+
+msgid "Please ensure you have a backup of important data before proceeding."
+msgstr "Vui lòng đảm bảo bạn có bản sao lưu dữ liệu quan trọng trước khi tiếp tục."
+
+msgid "Current size: %s MB / %s GB / %s TB"
+msgstr "Kích thước hiện tại: %s MB / %s GB / %s TB"
+
+msgid "Available space: %s MB / %s GB / %s TB"
+msgstr "Dung lượng có sẵn: %s MB / %s GB / %s TB"
+
+msgid "Maximum size to be obtained: %s MB / %s GB / %s TB"
+msgstr "Kích thước tối đa có thể đạt được: %s MB / %s GB / %s TB"
+
+msgid "Maximum new size"
+msgstr "Kích thước mới tối đa"
+
+msgid "New size"
+msgstr "Kích thước mới"
+
+msgid "Enter new size"
+msgstr "Nhập kích thước mới"
+
+msgid "New size must be larger than current size"
+msgstr "Kích thước mới phải lớn hơn kích thước hiện tại"
+
+msgid "New size exceeds available space"
+msgstr "Kích thước mới vượt quá dung lượng có sẵn"
+
+msgid "Partition resized successfully"
+msgstr "Thay đổi kích thước phân vùng thành công"
+
+msgid "Failed to resize partition"
+msgstr "Không thể thay đổi kích thước phân vùng"
+
+msgid "Failed to resize partition: "
+msgstr "Không thể thay đổi kích thước phân vùng: "
+
+msgid "Failed to start partition resize"
+msgstr "Không thể bắt đầu thay đổi kích thước phân vùng"
+
+msgid "Selected partition cannot be resized. Only unmounted Ext2/3/4 partitions with available space can be resized."
+msgstr "Không thể thay đổi kích thước phân vùng đã chọn. Chỉ có thể thay đổi kích thước các phân vùng Ext2/3/4 chưa gắn kết có dung lượng khả dụng."
+
+msgid "MB"
+msgstr "MB"
+
+msgid "GB"
+msgstr "GB"
+
+msgid "TB"
+msgstr "TB"
+
+msgid "Cannot Create Partition"
+msgstr "Không thể tạo phân vùng"
+
+msgid "Insufficient Space"
+msgstr "Không đủ dung lượng"
+
+msgid "Cannot read partition information"
+msgstr "Không thể đọc thông tin phân vùng"
+
+msgid "Invalid extended partition"
+msgstr "Phân vùng mở rộng không hợp lệ"
+
+msgid "Extended partition not found or has invalid size"
+msgstr "Không tìm thấy phân vùng mở rộng hoặc có kích thước không hợp lệ"
+
+msgid "Extended partition size: %s MB"
+msgstr "Kích thước phân vùng mở rộng: %s MB"
+
+msgid "Used by logical partitions: %s MB"
+msgstr "Được sử dụng bởi phân vùng lôgic: %s MB"
+
+msgid "Available for new logical: %s MB"
+msgstr "Có sẵn cho phân vùng lôgic mới: %s MB"
+
+msgid "Required minimum: 10 MB"
+msgstr "Tối thiểu yêu cầu: 10 MB"
+
+msgid "Not enough free space in extended partition /dev/%s"
+msgstr "Không đủ dung lượng trống trong phân vùng mở rộng /dev/%s"
+
+msgid "Extended partition already exists. You can create primary partitions or select the extended partition to create logical partitions inside."
+msgstr "Phân vùng mở rộng đã tồn tại. Bạn có thể tạo phân vùng chính hoặc chọn phân vùng mở rộng để tạo phân vùng lôgic bên trong."
+
+msgid "Creating partition inside extended partition. Only logical partitions can be created here."
+msgstr "Đang tạo phân vùng bên trong phân vùng mở rộng. Chỉ có thể tạo phân vùng lôgic tại đây."
+
+msgid "No partition table detected. A primary partition will be created and a partition table will be initialized."
+msgstr "Không phát hiện bảng phân vùng. Phân vùng chính sẽ được tạo và bảng phân vùng sẽ được khởi tạo."
+
+msgid "No partition table - select to create"
+msgstr "Không có bảng phân vùng - chọn để tạo"
+
+msgid "No partitions - select to create"
+msgstr "Không có phân vùng - chọn để tạo"
+
+msgid "Select to enable partition creation"
+msgstr "Chọn để bật tạo phân vùng"
+
+msgid "Select unallocated space"
+msgstr "Chọn dung lượng chưa phân bổ"
+
+msgid "Unallocated space"
+msgstr "Dung lượng chưa phân bổ"
+
+msgid "Expand Ext2/Ext3/Ext4"
+msgstr "Mở rộng Ext2/Ext3/Ext4"
+
+msgid "Wipe"
+msgstr "Xóa sạch"
+
+msgid "Select all partitions for wiping"
+msgstr "Chọn tất cả các phân vùng để xóa"
+
+msgid "Please enable wipe mode first"
+msgstr "Vui lòng bật chế độ xóa sạch trước"
+
+msgid "Cannot wipe disk with mounted partitions. Please unmount all partitions first."
+msgstr "Không thể xóa sạch ổ đĩa khi các phân vùng đang được gắn. Vui lòng tháo gắn tất cả phân vùng trước."
+
+msgid "Wipe Disk"
+msgstr "Xóa sạch ổ đĩa"
+
+msgid "WARNING"
+msgstr "CẢNH BÁO"
+
+msgid "This will completely erase the partition table and all data on /dev/%s!"
+msgstr "Điều này sẽ xóa hoàn toàn bảng phân vùng và tất cả dữ liệu trên /dev/%s!"
+
+msgid "All partitions will be deleted and the disk will be unallocated."
+msgstr "Tất cả các phân vùng sẽ bị xóa và đĩa sẽ không được phân bổ."
+
+msgid "THIS OPERATION CANNOT BE UNDONE!"
+msgstr "THAO TÁC NÀY KHÔNG THỂ HOÀN TÁC!"
+
+msgid "Number of partitions to be deleted: %d"
+msgstr "Số lượng phân vùng sẽ bị xóa: %d"
+
+msgid "Are you absolutely sure you want to continue?"
+msgstr "Bạn có hoàn toàn chắc chắn muốn tiếp tục không?"
+
+msgid "Wiping disk partition table..."
+msgstr "Đang xóa bảng phân vùng đĩa..."
+
+msgid "Disk partition table has been successfully erased"
+msgstr "Bảng phân vùng đĩa đã được xóa thành công"
+
+msgid "Failed to wipe disk"
+msgstr "Xóa sạch ổ đĩa thất bại"
+
+msgid "Failed to wipe disk: "
+msgstr "Xóa sạch ổ đĩa thất bại: "
+
+msgid "Disk Wipe Support"
+msgstr "Hỗ trợ xóa đĩa"
+
+msgid "Packages required to support disk wiping functionality (clearing partition table)."
+msgstr "Các gói cần thiết để hỗ trợ chức năng xóa đĩa (xóa bảng phân vùng)."
+
+msgid "Check Disk Wipe packages"
+msgstr "Kiểm tra gói xóa đĩa"
+
+msgid "Disk Wipe"
+msgstr "Xóa sạch ổ đĩa"
+
+msgid "dd from BusyBox"
+msgstr "dd từ BusyBox"
+
+msgid "Disk Wipe (dd command)"
+msgstr "Xóa sạch ổ đĩa (lệnh dd)"
+
+msgid "alternative"
+msgstr "thay thế"
+
+# SMART
+
+msgid "Attribute"
+msgstr "Thuộc tính"
+
+msgid "Id"
+msgstr "ID"
+
+msgid "Raw"
+msgstr "Thôngtin"
+
+msgid "Value"
+msgstr "Giátrị"
+
+msgid "Worst"
+msgstr "Tệnhất"
+
+msgid "Thresh"
+msgstr "Ngưỡng"
+
+msgid "Value"
+msgstr "Giá trị"
+
+msgid "NVMe S.M.A.R.T. Health Status"
+msgstr "Tình trạng sức khỏe NVMe S.M.A.R.T."
+
+msgid "OK"
+msgstr "OK"
+
+msgid "WARNING"
+msgstr "CẢNHBÁO"
+
+msgid "Power On Time"
+msgstr "Thời gian hoạt động"
+
+msgid "Power On Hours"
+msgstr "Giờ hoạt động"
+
+msgid "Disk Usage"
+msgstr "Sử dụng ổ đĩa"
+
+msgid "Disk Wear Level"
+msgstr "Mức độ hao mòn ổ đĩa"
+
+msgid "Available Spare"
+msgstr "Dự trữ khả dụng"
+
+msgid "Available Spare Threshold"
+msgstr "Ngưỡng dự trữ khả dụng"
+
+msgid "hour"
+msgstr "giờ"
+
+msgid "hours"
+msgstr "giờ"
+
+msgid "h"
+msgstr "g"
+
+msgid "year"
+msgstr "năm"
+
+msgid "years"
+msgstr "năm"
+
+msgid "month"
+msgstr "tháng"
+
+msgid "months"
+msgstr "tháng"
+
+msgid "day"
+msgstr "ngày"
+
+msgid "days"
+msgstr "ngày"
+
+msgid "worn"
+msgstr "đã hao mòn"
+
+msgid "remaining"
+msgstr "còn lại"
+
+msgid "S.M.A.R.T. Health Status"
+msgstr "Tình trạng sức khỏe tổng thể của ổ đĩa S.M.A.R.T."
+
+msgid "No S.M.A.R.T. attributes found."
+msgstr "Không tìm thấy thuộc tính S.M.A.R.T."
+
+msgid "Loading S.M.A.R.T. data..."
+msgstr "Đang tải dữ liệu S.M.A.R.T..."
+
+msgid "Unable to read S.M.A.R.T. data."
+msgstr "Không thể đọc dữ liệu S.M.A.R.T."
+
+msgid "Error reading S.M.A.R.T. data."
+msgstr "Lỗi khi đọc dữ liệu S.M.A.R.T."
+
+# SMART & Disk Info
+
+msgid "Raw Read Error Rate"
+msgstr "Tỷ lệ lỗi đọc thô"
+
+msgid "Throughput Performance"
+msgstr "Hiệu suất thông lượng"
+
+msgid "Spin Up Time"
+msgstr "Thời gian khởi động"
+
+msgid "Start Stop Count"
+msgstr "Số lần khởi động/dừng"
+
+msgid "Reallocated Sector Count"
+msgstr "Số sector tái phân bổ"
+
+msgid "Seek Error Rate"
+msgstr "Tỷ lệ lỗi định vị"
+
+msgid "Seek Time Performance"
+msgstr "Hiệu suất thời gian định vị"
+
+msgid "Power On Hours"
+msgstr "Giờ hoạt động"
+
+msgid "Spin Retry Count"
+msgstr "Số lần thử lại khởi động"
+
+msgid "Calibration Retry Count"
+msgstr "Số lần thử lại hiệu chuẩn"
+
+msgid "Power Cycle Count"
+msgstr "Số chu kỳ nguồn"
+
+msgid "Read Soft Error Rate"
+msgstr "Tỷ lệ lỗi đọc mềm"
+
+msgid "Airflow Temperature"
+msgstr "Nhiệt độ luồng khí"
+
+msgid "Temperature Celsius"
+msgstr "Nhiệt độ"
+
+msgid "Hardware ECC Recovered"
+msgstr "Lỗi ECC khôi phục bằng phần cứng"
+
+msgid "Current Pending Sector"
+msgstr "Sector không ổn định"
+
+msgid "Offline Uncorrectable"
+msgstr "Sector không sửa được offline"
+
+msgid "UDMA CRC Error Count"
+msgstr "Số lỗi CRC UDMA"
+
+msgid "Multi Zone Error Rate"
+msgstr "Tỷ lệ lỗi đa vùng"
+
+msgid "Wear Leveling Count"
+msgstr "Bộ đếm mài mòn"
+
+msgid "Used Reserved Block Count Total"
+msgstr "Khối dự trữ đã sử dụng (tổng)"
+
+msgid "Used Reserved Block Count Chip"
+msgstr "Khối dự trữ đã sử dụng (chip)"
+
+msgid "Unused Reserved Block Count Total"
+msgstr "Khối dự trữ chưa sử dụng"
+
+msgid "Program Fail Count Total"
+msgstr "Số lỗi ghi"
+
+msgid "Erase Fail Count Total"
+msgstr "Số lỗi xóa"
+
+msgid "Runtime Bad Block"
+msgstr "Khối hỏng"
+
+msgid "Uncorrectable Error Count"
+msgstr "Số lỗi không sửa được"
+
+msgid "Temperature Exceed Count"
+msgstr "Số lần vượt nhiệt độ"
+
+msgid "Erase Fail Count"
+msgstr "Số lỗi xóa"
+
+msgid "Reported Uncorrectable Errors"
+msgstr "Lỗi không sửa được đã báo cáo"
+
+msgid "High Fly Writes"
+msgstr "Ghi ở độ cao lớn"
+
+msgid "G-Sense Error Rate"
+msgstr "Tỷ lệ lỗi cảm biến G"
+
+msgid "Power-Off Retract Count"
+msgstr "Số lần rút đầu đọc khi tắt nguồn"
+
+msgid "Load Cycle Count"
+msgstr "Số chu kỳ đỗ đầu đọc"
+
+msgid "Temperature Case"
+msgstr "Nhiệt độ vỏ"
+
+msgid "Reallocated Event Count"
+msgstr "Số sự kiện tái phân bổ"
+
+msgid "Transfer Error Rate"
+msgstr "Tỷ lệ lỗi truyền"
+
+msgid "Free Fall Sensor"
+msgstr "Cảm biến rơi tự do"
+
+msgid "Total LBAs Written"
+msgstr "Tổng LBA đã ghi"
+
+msgid "Total LBAs Read"
+msgstr "Tổng LBA đã đọc"
+
+msgid "Read Error Retry Rate"
+msgstr "Tỷ lệ thử lại đọc"
+
+msgid "Minimum W/E Cycle"
+msgstr "Chu kỳ ghi/xóa tối thiểu"
+
+msgid "Maximum W/E Cycle"
+msgstr "Chu kỳ ghi/xóa tối đa"
+
+msgid "Average W/E Cycle"
+msgstr "Chu kỳ ghi/xóa trung bình"
+
+msgid "Media Wearout Indicator"
+msgstr "Chỉ báo mài mòn phương tiện"
+
+msgid "Available Reserved Space"
+msgstr "Không gian dự trữ khả dụng"
+
+msgid "SSD Life Left"
+msgstr "Tuổi thọ SSD còn lại"
+
+msgid "Remaining Lifetime Percentage"
+msgstr "Phần trăm tuổi thọ còn lại"
+
+msgid "Percentage Lifetime Remaining"
+msgstr "Phần trăm tuổi thọ còn lại"
+
+msgid "Remaining Life"
+msgstr "Tuổi thọ còn lại"
+
+msgid "Lifetime Writes GiB"
+msgstr "Dữ liệu đã ghi (GiB)"
+
+msgid "Lifetime Reads GiB"
+msgstr "Dữ liệu đã đọc (GiB)"
+
+msgid "Program Fail Count"
+msgstr "Số lỗi lập trình"
+
+msgid "Unexpected Power Loss Count"
+msgstr "Số lần mất nguồn bất ngờ"
+
+msgid "Thermal Throttle Status"
+msgstr "Trạng thái giới hạn nhiệt"
+
+msgid "End-to-End Error"
+msgstr "Lỗi đầu cuối"
+
+msgid "Workload Host Reads Percentage"
+msgstr "Phần trăm đọc của host"
+
+msgid "Workload Media Wear Indicator"
+msgstr "Chỉ báo mài mòn phương tiện (tải)"
+
+msgid "Timed Workload Media Wear"
+msgstr "Mài mòn phương tiện (tải theo thời gian)"
+
+msgid "Workload Timer"
+msgstr "Bộ đếm thời gian tải"
+
+msgid "Percentage Rated Life Used"
+msgstr "Phần trăm tuổi thọ đã sử dụng"
+
+msgid "Head Flying Hours"
+msgstr "Giờ bay của đầu đọc"
+
+msgid "Read Channel Margin"
+msgstr "Biên độ kênh đọc"
+
+msgid "Loaded Hours"
+msgstr "Giờ hoạt động không đỗ"
+
+msgid "Load/Unload Retry Count"
+msgstr "Số lần thử lại đỗ/bỏ đỗ"
+
+msgid "GMR Head Amplitude"
+msgstr "Biên độ đầu đọc GMR"
+
+msgid "Drive Temperature"
+msgstr "Nhiệt độ ổ đĩa"
+
+msgid "Endurance Remaining"
+msgstr "Độ bền còn lại"
+
+msgid "Power On Hours and Milliseconds"
+msgstr "Giờ hoạt động (giờ và mili giây)"
+
+msgid "Head Health"
+msgstr "Tình trạng đầu đọc"
+
+msgid "POR Recovery Count"
+msgstr "Số lần khôi phục POR"
+
+msgid "Unused Reserve NAND Blocks"
+msgstr "Khối NAND dự trữ chưa sử dụng"
+
+msgid "SSD Protect Mode"
+msgstr "Chế độ bảo vệ SSD"
+
+msgid "Host Writes 32MiB"
+msgstr "Ghi của host (32MiB)"
+
+msgid "NAND Writes 32MiB"
+msgstr "Ghi NAND (32MiB)"
+
+msgid "Remaining Life Left"
+msgstr "Tuổi thọ còn lại"
+
+msgid "Grown Bad Block Count"
+msgstr "Số khối hỏng mới"
+
+msgid "Soft Read Error Rate"
+msgstr "Tỷ lệ lỗi đọc mềm"
+
+msgid "Data Address Mark Errors"
+msgstr "Lỗi dấu địa chỉ dữ liệu"
+
+msgid "Run Out Cancel"
+msgstr "Hủy tràn"
+
+msgid "Soft ECC Correction"
+msgstr "Sửa lỗi ECC mềm"
+
+msgid "TA Increase Count"
+msgstr "Số lần tăng TA"
+
+msgid "Shock Count Write Operation"
+msgstr "Số lần va đập khi ghi"
+
+msgid "Shock Rate Write Operation"
+msgstr "Tỷ lệ va đập khi ghi"
+
+msgid "Flying Height"
+msgstr "Độ cao bay của đầu đọc"
+
+msgid "Spin High Current"
+msgstr "Dòng cao khi khởi động"
+
+msgid "Spin Buzz"
+msgstr "Tiếng kêu khi khởi động"
+
+msgid "Offline Seek Performance"
+msgstr "Hiệu suất định vị offline"
+
+msgid "Vibration During Write"
+msgstr "Rung động khi ghi"
+
+msgid "Shock During Write"
+msgstr "Va đập khi ghi"
+
+msgid "Disk Shift"
+msgstr "Dịch chuyển đĩa"
+
+msgid "Load Retry Count"
+msgstr "Số lần thử lại tải"
+
+msgid "Load Friction"
+msgstr "Ma sát khi tải"
+
+msgid "Load-in Time"
+msgstr "Thời gian tải"
+
+msgid "Torque Amplification Count"
+msgstr "Số lần khuếch đại mô-men xoắn"
+
+msgid "Write Error Rate"
+msgstr "Tỷ lệ lỗi ghi"
+
+msgid "Serial Number"
+msgstr "Số seri"
+
+msgid "LU WWN Device Id"
+msgstr "ID thiết bị LU WWN"
+
+msgid "Firmware Version"
+msgstr "Phiên bản firmware"
+
+msgid "User Capacity"
+msgstr "Dung lượng khả dụng"
+
+msgid "Capacity"
+msgstr "Dung lượng"
+
+msgid "Sector Size"
+msgstr "Kích thước sector"
+
+msgid "Sector Sizes"
+msgstr "Kích thước các sector"
+
+msgid "Rotation Rate"
+msgstr "Tốc độ quay"
+
+msgid "Form Factor"
+msgstr "Kích thước"
+
+msgid "Device is"
+msgstr "Thiết bị"
+
+msgid "ATA Version is"
+msgstr "Phiên bản ATA"
+
+msgid "SATA Version is"
+msgstr "Phiên bản SATA"
+
+msgid "Local Time is"
+msgstr "Giờ địa phương"
+
+msgid "SMART support is"
+msgstr "Hỗ trợ SMART"
+
+msgid "SMART Status"
+msgstr "Trạng thái SMART"
+
+msgid "Device"
+msgstr "Thiết bị"
+
+msgid "Model Number"
+msgstr "Mẫu"
+
+msgid "Firmware Revision"
+msgstr "Bản sửa đổi firmware"
+
+msgid "PCI Vendor/Subsystem ID"
+msgstr "ID nhà cung cấp/hệ thống con PCI"
+
+msgid "IEEE OUI Identifier"
+msgstr "Mã định danh IEEE OUI"
+
+msgid "Total NVM Capacity"
+msgstr "Tổng dung lượng NVM"
+
+msgid "Unallocated NVM Capacity"
+msgstr "Dung lượng NVM chưa phân bổ"
+
+msgid "Controller ID"
+msgstr "ID bộ điều khiển"
+
+msgid "Number of Namespaces"
+msgstr "Số không gian địa chỉ"
+
+msgid "Namespace 1 Size/Capacity"
+msgstr "Kích thước/dung lượng không gian địa chỉ 1"
+
+msgid "Namespace 1 Formatted LBA Size"
+msgstr "Kích thước LBA không gian địa chỉ 1"
+
+msgid "Namespace 1 IEEE EUI-64"
+msgstr "IEEE EUI-64 không gian địa chỉ 1"
+
+msgid "logical/physical"
+msgstr "logic/vật lý"
+
+msgid "bytes"
+msgstr "byte"
+
+msgid "blocks"
+msgstr "khối"
+
+msgid "Solid State Device"
+msgstr "Ổ SSD"
+
+# Reserved space
+
+msgid "Reserved space"
+msgstr "Không gian dành riêng"
+
+msgid "Space reserved for root (default: 5%)"
+msgstr "Không gian dành riêng cho root (mặc định: 5%)"
+
+msgid "Used Reserved Block Count Total"
+msgstr "Tổng số khối dành riêng đã sử dụng"
+
+msgid "Used Reserved Block Count Chip"
+msgstr "Số khối dành riêng đã sử dụng trên chip"
+
+msgid "Unused Reserved Block Count Total"
+msgstr "Tổng số khối dành riêng chưa sử dụng"
+
+msgid "Available Reserved Space"
+msgstr "Không gian dành riêng khả dụng"
+
+# NVMe
+
+msgid "Critical Warning"
+msgstr "Cảnh báo nghiêm trọng"
+
+msgid "Percentage Used"
+msgstr "Phần trăm đã sử dụng"
+
+msgid "Data Units Read"
+msgstr "Đơn vị dữ liệu đã đọc"
+
+msgid "Data Units Written"
+msgstr "Đơn vị dữ liệu đã ghi"
+
+msgid "Host Read Commands"
+msgstr "Lệnh đọc từ máy chủ"
+
+msgid "Host Write Commands"
+msgstr "Lệnh ghi từ máy chủ"
+
+msgid "Controller Busy Time"
+msgstr "Thời gian bộ điều khiển bận"
+
+msgid "Power Cycles"
+msgstr "Chu kỳ nguồn"
+
+msgid "Unsafe Shutdowns"
+msgstr "Tắt máy không an toàn"
+
+msgid "Media Errors"
+msgstr "Lỗi phương tiện"
+
+msgid "Error Log Entries"
+msgstr "Mục nhập nhật ký lỗi"
diff --git a/package/luci-app-mini-diskmanager/po/zh_Hans/mini-diskmanager.po b/package/luci-app-mini-diskmanager/po/zh_Hans/mini-diskmanager.po
new file mode 100644
index 0000000000..6411a4d15a
--- /dev/null
+++ b/package/luci-app-mini-diskmanager/po/zh_Hans/mini-diskmanager.po
@@ -0,0 +1,1251 @@
+msgid ""
+msgstr ""
+"Project-Id-Version: luci-app-mini-diskmanager\n"
+"Language-Team: Rafał Wabik (IceG)\n"
+"Language: zh_CN\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+msgid "Disk Manager"
+msgstr "磁盘管理器"
+
+msgid "-- Select a disk --"
+msgstr "-- 选择磁盘 --"
+
+msgid "Disk"
+msgstr "磁盘"
+
+msgid "Refresh"
+msgstr "刷新"
+
+msgid "Mounting actions"
+msgstr "挂载操作"
+
+msgid "Actions on partitions"
+msgstr "分区操作"
+
+msgid "Mount"
+msgstr "挂载"
+
+msgid "Unmount"
+msgstr "卸载"
+
+msgid "Create"
+msgstr "创建"
+
+msgid "Delete"
+msgstr "删除"
+
+msgid "Format"
+msgstr "格式化"
+
+msgid "Please select a disk to view its partitions"
+msgstr "请选择磁盘以查看其分区"
+
+msgid "Please select a disk first"
+msgstr "请先选择磁盘"
+
+msgid "Please select a partition first"
+msgstr "请先选择分区"
+
+msgid "Loading disk information..."
+msgstr "正在加载磁盘信息..."
+
+msgid "Error loading disk information: "
+msgstr "加载磁盘信息时出错："
+
+msgid "Disk Information"
+msgstr "磁盘信息"
+
+msgid "Temperature"
+msgstr "温度"
+
+msgid "S.M.A.R.T."
+msgstr "S.M.A.R.T."
+
+msgid "S.M.A.R.T. Status"
+msgstr "S.M.A.R.T. 状态"
+
+msgid "Partitions"
+msgstr "分区"
+
+msgid "Mount Status"
+msgstr "挂载状态"
+
+msgid "Mounted"
+msgstr "已挂载"
+
+msgid "Not mounted"
+msgstr "未挂载"
+
+msgid "Partition Layout"
+msgstr "分区布局"
+
+msgid "Partition"
+msgstr "分区"
+
+msgid "Type / Filesystem"
+msgstr "类型 / 文件系统"
+
+msgid "Filesystem"
+msgstr "文件系统"
+
+msgid "Mount Point"
+msgstr "挂载点"
+
+msgid "Label"
+msgstr "标签"
+
+msgid "Size"
+msgstr "大小"
+
+msgid "Used"
+msgstr "已用"
+
+msgid "Unused"
+msgstr "可用"
+
+msgid "Flags"
+msgstr "标志"
+
+msgid "No partitions found"
+msgstr "未找到分区"
+
+msgid "Unallocated"
+msgstr "未分配"
+
+msgid "Area without partition table"
+msgstr "无分区表的区域"
+
+msgid "Free Space"
+msgstr "可用空间"
+
+msgid "Primary"
+msgstr "主分区"
+
+msgid "Extended"
+msgstr "扩展分区"
+
+msgid "Logical"
+msgstr "逻辑分区"
+
+msgid "Create partition"
+msgstr "创建分区"
+
+msgid "Cancel"
+msgstr "取消"
+
+msgid "File system"
+msgstr "文件系统"
+
+msgid "Volume label"
+msgstr "卷标签"
+
+msgid "Partition size"
+msgstr "分区大小"
+
+msgid "Enter size"
+msgstr "输入大小"
+
+msgid "Use all available space"
+msgstr "使用所有可用空间"
+
+msgid "Available: %s MB / %s GB / %s TB"
+msgstr "可用：%s MB / %s GB / %s TB"
+
+msgid "Please enter a valid size"
+msgstr "请输入有效的大小"
+
+msgid "Size is too small"
+msgstr "大小太小"
+
+msgid "Creating partition..."
+msgstr "正在创建分区..."
+
+msgid "Partition created successfully"
+msgstr "分区创建成功"
+
+msgid "Failed to create partition"
+msgstr "创建分区失败"
+
+msgid "Format Partition"
+msgstr "格式化分区"
+
+msgid "Warning"
+msgstr "警告"
+
+msgid "This will erase all data on /dev/%s"
+msgstr "这将擦除 /dev/%s 上的所有数据"
+
+msgid "Formatting partition..."
+msgstr "正在格式化分区..."
+
+msgid "Partition formatted successfully"
+msgstr "分区格式化成功"
+
+msgid "Failed to format partition"
+msgstr "格式化分区失败"
+
+msgid "Delete Partition"
+msgstr "删除分区"
+
+msgid "Are you sure you want to continue?"
+msgstr "您确定要继续吗？"
+
+msgid "Deleting partition..."
+msgstr "正在删除分区..."
+
+msgid "Partition deleted successfully"
+msgstr "分区删除成功"
+
+msgid "Failed to delete partition"
+msgstr "删除分区失败"
+
+msgid "No partitions to mount"
+msgstr "没有可挂载的分区"
+
+msgid "No mounted partitions found"
+msgstr "未找到已挂载的分区"
+
+msgid "No partitions to unmount"
+msgstr "没有可卸载的分区"
+
+msgid "Mounted to %s"
+msgstr "已挂载到 %s"
+
+msgid "Unmounted %s"
+msgstr "已卸载 %s"
+
+msgid "Failed to mount: "
+msgstr "挂载失败："
+
+msgid "Failed to unmount: "
+msgstr "卸载失败："
+
+msgid "Failed to check operation status: "
+msgstr "检查操作状态失败："
+
+msgid "Partition created but device node did not appear in time"
+msgstr "分区已创建但设备节点未及时出现"
+
+msgid "Partition created but device node did not appear; please refresh manually"
+msgstr "分区已创建但设备节点未出现；请手动刷新"
+
+msgid "PASSED"
+msgstr "通过"
+
+msgid "FAILED"
+msgstr "失败"
+
+msgid "Cannot create partition on mounted disk. Please unmount first."
+msgstr "无法在已挂载的磁盘上创建分区。请先卸载。"
+
+msgid "No unallocated space available on this disk"
+msgstr "此磁盘上没有可用的未分配空间"
+
+msgid "Cannot format mounted partition. Please unmount first."
+msgstr "无法格式化已挂载的分区。请先卸载。"
+
+msgid "Failed to refresh partition data: "
+msgstr "刷新分区数据失败："
+
+msgid "Cannot delete partition on mounted disk. Please unmount first."
+msgstr "无法删除已挂载磁盘上的分区。请先卸载。"
+
+msgid "This will delete partition /dev/%s and all its data!"
+msgstr "这将删除分区 /dev/%s 及其所有数据！"
+
+msgid "Failed to load disk information: "
+msgstr "加载磁盘信息失败："
+
+msgid "Click to select"
+msgstr "点击以选择"
+
+msgid "System partition cannot be selected"
+msgstr "无法选择系统分区"
+
+msgid "Free"
+msgstr "可用"
+
+msgid "Select a disk"
+msgstr "选择磁盘"
+
+msgid "Create a new partition on the selected disk"
+msgstr "在选定的磁盘上创建新分区"
+
+msgid "Partition layout"
+msgstr "分区布局"
+
+msgid "Partition type"
+msgstr "分区类型"
+
+msgid "Refresh partition data"
+msgstr "刷新分区数据"
+
+msgid "MBR (Master Boot Record)"
+msgstr "MBR（主引导记录）"
+
+msgid "GPT (GUID Partition Table)"
+msgstr "GPT（GUID 分区表）"
+
+msgid "The Mini Disk Manager package allows users to easily manage disks and partitions."
+msgstr "Mini 磁盘管理器软件包允许用户轻松管理磁盘和分区。"
+
+msgid "Configuration"
+msgstr "配置"
+
+msgid "Package and Driver Verification"
+msgstr "软件包和驱动程序验证"
+
+msgid "Check and install required drivers for storage devices."
+msgstr "检查并安装存储设备所需的驱动程序。"
+
+msgid "Filesystem Support"
+msgstr "文件系统支持"
+
+msgid "Check USB drivers"
+msgstr "检查 USB 驱动程序"
+
+msgid "USB drivers"
+msgstr "USB 驱动程序"
+
+msgid "Check NVMe drivers"
+msgstr "检查 NVMe 驱动程序"
+
+msgid "NVMe drivers"
+msgstr "NVMe 驱动程序"
+
+msgid "Check ATA/SATA drivers"
+msgstr "检查 ATA/SATA 驱动程序"
+
+msgid "ATA/SATA drivers"
+msgstr "ATA/SATA 驱动程序"
+
+msgid "Check Linux filesystem packages"
+msgstr "检查 Linux 文件系统软件包"
+
+msgid "Linux filesystems"
+msgstr "Linux 文件系统"
+
+msgid "Check Windows filesystem packages"
+msgstr "检查 Windows 文件系统软件包"
+
+msgid "Windows filesystems"
+msgstr "Windows 文件系统"
+
+msgid "Linux Filesystem Packages"
+msgstr "Linux 文件系统软件包"
+
+msgid "Windows Filesystem Packages"
+msgstr "Windows 文件系统软件包"
+
+msgid "Disk Manager Log"
+msgstr "磁盘管理器日志"
+
+msgid "Loading package data…"
+msgstr "正在加载软件包数据…"
+
+msgid "Loading log file…"
+msgstr "正在加载日志文件…"
+
+msgid "Log file content"
+msgstr "日志文件内容"
+
+msgid "Log file is empty"
+msgstr "日志文件为空"
+
+msgid "Unable to read log file"
+msgstr "无法读取日志文件"
+
+msgid "Log file cleared successfully"
+msgstr "日志文件清除成功"
+
+msgid "Unable to clear the file"
+msgstr "无法清除文件"
+
+msgid "Installed"
+msgstr "已安装"
+
+msgid "Install…"
+msgstr "安装…"
+
+msgid "Clear"
+msgstr "清除"
+
+msgid "Download"
+msgstr "下载"
+
+msgid "Close"
+msgstr "关闭"
+
+msgid "Failed to load package data"
+msgstr "加载软件包数据失败"
+
+msgid "more info in log"
+msgstr "日志中有更多信息"
+
+msgid "The tab allows users to support the package."
+msgstr "该选项卡允许用户支持该软件包。"
+
+msgid "Package support"
+msgstr "软件包支持"
+
+msgid "Mini Disk Manager Info"
+msgstr "Mini 磁盘管理器信息"
+
+msgid "Luci-app-mdmanager"
+msgstr "Luci-app-mdmanager"
+
+msgid "Buy a coffee"
+msgstr "请喝咖啡"
+
+msgid "Buy a coffee if you want to support the development of the project and the author"
+msgstr "如果您想支持项目和作者的开发，请请喝咖啡"
+
+msgid "Become a sponsor"
+msgstr "成为赞助商"
+
+msgid "Become a sponsor if you want to support the development of the project and the author"
+msgstr "如果您想支持项目和作者的开发，请成为赞助商"
+
+msgid "Write on forum"
+msgstr "在论坛上发帖"
+
+msgid "Write in the topic of the package on the forum eko.one.pl"
+msgstr "在 eko.one.pl 论坛的软件包主题中发帖"
+
+msgid "Open discussion"
+msgstr "打开讨论"
+
+msgid "Open a package discussion on Github"
+msgstr "在 Github 上打开软件包讨论"
+
+msgid "Report a bug"
+msgstr "报告错误"
+
+msgid "Report a bug on the package Github page"
+msgstr "在软件包的 Github 页面上报告错误"
+
+msgid "Package name"
+msgstr "软件包名称"
+
+msgid "Author (package maintainer)"
+msgstr "作者（软件包维护者）"
+
+msgid "Information about package author and available support options."
+msgstr "关于软件包作者和可用支持选项的信息。"
+
+# --
+
+msgid "All available space"
+msgstr "所有可用空间"
+
+msgid "Cannot delete mounted partition. Please unmount first."
+msgstr "无法删除已挂载的分区。请先卸载。"
+
+msgid "Failed to create partition: "
+msgstr "创建分区失败："
+
+msgid "Failed to detect supported filesystems"
+msgstr "检测支持的文件系统失败"
+
+msgid "Failed to format partition: "
+msgstr "格式化分区失败："
+
+msgid "Failed to parse JSON response: "
+msgstr "解析 JSON 响应失败："
+
+msgid "Failed to start formatting"
+msgstr "启动格式化失败"
+
+msgid "Failed to start partition creation"
+msgstr "启动分区创建失败"
+
+msgid "Failed to start partition deletion"
+msgstr "启动分区删除失败"
+
+msgid "Fill in size"
+msgstr "填写大小"
+
+msgid "Linux Swap"
+msgstr "Linux 交换分区"
+
+msgid "Loading..."
+msgstr "正在加载..."
+
+msgid "No filesystem packages detected — user cannot choose unsupported filesystem formats."
+msgstr "未检测到文件系统软件包 — 用户无法选择不支持的文件系统格式。"
+
+msgid "No partition types available. Maximum partitions reached."
+msgstr "没有可用的分区类型。已达到最大分区数。"
+
+msgid "No supported filesystems detected on this system"
+msgstr "此系统上未检测到支持的文件系统"
+
+msgid "Optional"
+msgstr "可选"
+
+msgid "Partition created but selected filesystem is not available for formatting on this system"
+msgstr "分区已创建，但选定的文件系统不可用于在此系统上格式化"
+
+msgid "Partition data refreshed"
+msgstr "分区数据已刷新"
+
+msgid "Please select a filesystem"
+msgstr "请选择文件系统"
+
+msgid "RPC call failed: "
+msgstr "RPC 调用失败："
+
+msgid "Refreshing..."
+msgstr "正在刷新..."
+
+msgid "Selected filesystem is not supported on this system"
+msgstr "此系统不支持所选文件系统"
+
+msgid "Selected partition is not mounted"
+msgstr "所选分区未挂载"
+
+msgid "unknown error"
+msgstr "未知错误"
+
+msgid "Packages & Drivers"
+msgstr "软件包和驱动程序"
+
+msgid "Mini Disk Manager log"
+msgstr "Mini 磁盘管理器日志"
+
+msgid "Mini Disk Manager Log"
+msgstr "Mini 磁盘管理器日志"
+
+msgid "Packages required to support various file systems."
+msgstr "支持各种文件系统所需的软件包。"
+
+msgid "Expand"
+msgstr "扩展"
+
+msgid "Resize"
+msgstr "调整大小"
+
+msgid "Resize Partition"
+msgstr "调整分区大小"
+
+msgid "Resize partition /dev/%s"
+msgstr "调整分区 /dev/%s 的大小"
+
+msgid "Resizing partition..."
+msgstr "正在调整分区大小..."
+
+msgid "Resizing a partition can cause data loss if not done correctly."
+msgstr "如果操作不当，调整分区大小可能会导致数据丢失。"
+
+msgid "Please ensure you have a backup of important data before proceeding."
+msgstr "在继续之前，请确保您已备份重要数据。"
+
+msgid "Current size: %s MB / %s GB / %s TB"
+msgstr "当前大小：%s MB / %s GB / %s TB"
+
+msgid "Available space: %s MB / %s GB / %s TB"
+msgstr "可用空间：%s MB / %s GB / %s TB"
+
+msgid "Maximum size to be obtained: %s MB / %s GB / %s TB"
+msgstr "可获得的最大大小：%s MB / %s GB / %s TB"
+
+msgid "Maximum new size"
+msgstr "最大新大小"
+
+msgid "New size"
+msgstr "新大小"
+
+msgid "Enter new size"
+msgstr "输入新大小"
+
+msgid "New size must be larger than current size"
+msgstr "新大小必须大于当前大小"
+
+msgid "New size exceeds available space"
+msgstr "新大小超出可用空间"
+
+msgid "Partition resized successfully"
+msgstr "分区大小调整成功"
+
+msgid "Failed to resize partition"
+msgstr "调整分区大小失败"
+
+msgid "Failed to resize partition: "
+msgstr "调整分区大小失败："
+
+msgid "Failed to start partition resize"
+msgstr "启动分区大小调整失败"
+
+msgid "Selected partition cannot be resized. Only unmounted Ext2/3/4 partitions with available space can be resized."
+msgstr "无法调整所选分区的大小。只能调整具有可用空间的未挂载 Ext2/3/4 分区的大小。"
+
+msgid "MB"
+msgstr "MB"
+
+msgid "GB"
+msgstr "GB"
+
+msgid "TB"
+msgstr "TB"
+
+msgid "Cannot Create Partition"
+msgstr "无法创建分区"
+
+msgid "Insufficient Space"
+msgstr "空间不足"
+
+msgid "Cannot read partition information"
+msgstr "无法读取分区信息"
+
+msgid "Invalid extended partition"
+msgstr "无效的扩展分区"
+
+msgid "Extended partition not found or has invalid size"
+msgstr "未找到扩展分区或大小无效"
+
+msgid "Extended partition size: %s MB"
+msgstr "扩展分区大小：%s MB"
+
+msgid "Used by logical partitions: %s MB"
+msgstr "逻辑分区使用：%s MB"
+
+msgid "Available for new logical: %s MB"
+msgstr "可用于新逻辑分区：%s MB"
+
+msgid "Required minimum: 10 MB"
+msgstr "所需最小值：10 MB"
+
+msgid "Not enough free space in extended partition /dev/%s"
+msgstr "扩展分区 /dev/%s 中没有足够的可用空间"
+
+msgid "Extended partition already exists. You can create primary partitions or select the extended partition to create logical partitions inside."
+msgstr "扩展分区已存在。您可以创建主分区或选择扩展分区以在其中创建逻辑分区。"
+
+msgid "Creating partition inside extended partition. Only logical partitions can be created here."
+msgstr "在扩展分区内创建分区。这里只能创建逻辑分区。"
+
+msgid "No partition table detected. A primary partition will be created and a partition table will be initialized."
+msgstr "未检测到分区表。将创建主分区并初始化分区表。"
+
+msgid "No partition table - select to create"
+msgstr "无分区表 - 选择以创建"
+
+msgid "No partitions - select to create"
+msgstr "无分区 - 选择以创建"
+
+msgid "Select to enable partition creation"
+msgstr "选择以启用分区创建"
+
+msgid "Select unallocated space"
+msgstr "选择未分配空间"
+
+msgid "Unallocated space"
+msgstr "未分配空间"
+
+msgid "Expand Ext2/Ext3/Ext4"
+msgstr "扩展 Ext2/Ext3/Ext4"
+
+msgid "Wipe"
+msgstr "擦除"
+
+msgid "Select all partitions for wiping"
+msgstr "选择所有分区进行擦除"
+
+msgid "Please enable wipe mode first"
+msgstr "请先启用擦除模式"
+
+msgid "Cannot wipe disk with mounted partitions. Please unmount all partitions first."
+msgstr "无法擦除已挂载分区的磁盘。请先卸载所有分区。"
+
+msgid "Wipe Disk"
+msgstr "擦除磁盘"
+
+msgid "WARNING"
+msgstr "警告"
+
+msgid "This will completely erase the partition table and all data on /dev/%s!"
+msgstr "这将完全删除/dev/%s上的分区表和所有数据！"
+
+msgid "All partitions will be deleted and the disk will be unallocated."
+msgstr "所有分区将被删除，磁盘将变为未分配状态。"
+
+msgid "THIS OPERATION CANNOT BE UNDONE!"
+msgstr "此操作无法撤销！"
+
+msgid "Number of partitions to be deleted: %d"
+msgstr "将要删除的分区数量：%d"
+
+msgid "Are you absolutely sure you want to continue?"
+msgstr "您确定要继续吗？"
+
+msgid "Wiping disk partition table..."
+msgstr "正在擦除磁盘分区表..."
+
+msgid "Disk partition table has been successfully erased"
+msgstr "磁盘分区表已成功擦除"
+
+msgid "Failed to wipe disk"
+msgstr "擦除磁盘失败"
+
+msgid "Failed to wipe disk: "
+msgstr "擦除磁盘失败："
+
+msgid "Disk Wipe Support"
+msgstr "磁盘擦除支持"
+
+msgid "Packages required to support disk wiping functionality (clearing partition table)."
+msgstr "支持磁盘擦除功能所需的软件包（清除分区表）。"
+
+msgid "Check Disk Wipe packages"
+msgstr "检查磁盘擦除软件包"
+
+msgid "Disk Wipe"
+msgstr "磁盘擦除"
+
+msgid "dd from BusyBox"
+msgstr "BusyBox 的 dd"
+
+msgid "Disk Wipe (dd command)"
+msgstr "磁盘擦除（dd 命令）"
+
+msgid "alternative"
+msgstr "替代"
+
+# SMART
+
+msgid "Attribute"
+msgstr "属性"
+
+msgid "Id"
+msgstr "Id"
+
+msgid "Raw"
+msgstr "原始值"
+
+msgid "Value"
+msgstr "当前值"
+
+msgid "Worst"
+msgstr "最差值"
+
+msgid "Thresh"
+msgstr "阈值"
+
+msgid "Value"
+msgstr "值"
+
+msgid "NVMe S.M.A.R.T. Health Status"
+msgstr "NVMe S.M.A.R.T. 健康状态"
+
+msgid "OK"
+msgstr "正常"
+
+msgid "WARNING"
+msgstr "警告"
+
+msgid "Power On Time"
+msgstr "通电时间"
+
+msgid "Power On Hours"
+msgstr "通电小时数"
+
+msgid "Disk Usage"
+msgstr "磁盘使用率"
+
+msgid "Disk Wear Level"
+msgstr "磁盘损耗等级"
+
+msgid "Available Spare"
+msgstr "可用备用"
+
+msgid "Available Spare Threshold"
+msgstr "可用备用阈值"
+
+msgid "hour"
+msgstr "小时"
+
+msgid "hours"
+msgstr "小时"
+
+msgid "h"
+msgstr "时"
+
+msgid "year"
+msgstr "年"
+
+msgid "years"
+msgstr "年"
+
+msgid "month"
+msgstr "月"
+
+msgid "months"
+msgstr "月"
+
+msgid "day"
+msgstr "天"
+
+msgid "days"
+msgstr "天"
+
+msgid "worn"
+msgstr "已损耗"
+
+msgid "remaining"
+msgstr "剩余"
+
+msgid "S.M.A.R.T. Health Status"
+msgstr "S.M.A.R.T. 磁盘整体健康状态"
+
+msgid "No S.M.A.R.T. attributes found."
+msgstr "未找到 S.M.A.R.T. 属性。"
+
+msgid "Loading S.M.A.R.T. data..."
+msgstr "正在加载 S.M.A.R.T. 数据..."
+
+msgid "Unable to read S.M.A.R.T. data."
+msgstr "无法读取 S.M.A.R.T. 数据。"
+
+msgid "Error reading S.M.A.R.T. data."
+msgstr "读取 S.M.A.R.T. 数据时出错。"
+
+# SMART & Disk Info
+
+msgid "Raw Read Error Rate"
+msgstr "原始读取错误率"
+
+msgid "Throughput Performance"
+msgstr "吞吐量性能"
+
+msgid "Spin Up Time"
+msgstr "启动时间"
+
+msgid "Start Stop Count"
+msgstr "启动/停止次数"
+
+msgid "Reallocated Sector Count"
+msgstr "重新分配扇区计数"
+
+msgid "Seek Error Rate"
+msgstr "寻道错误率"
+
+msgid "Seek Time Performance"
+msgstr "寻道时间性能"
+
+msgid "Power On Hours"
+msgstr "通电时间"
+
+msgid "Spin Retry Count"
+msgstr "启动重试次数"
+
+msgid "Calibration Retry Count"
+msgstr "校准重试次数"
+
+msgid "Power Cycle Count"
+msgstr "电源循环次数"
+
+msgid "Read Soft Error Rate"
+msgstr "软读取错误率"
+
+msgid "Airflow Temperature"
+msgstr "气流温度"
+
+msgid "Temperature Celsius"
+msgstr "温度"
+
+msgid "Hardware ECC Recovered"
+msgstr "硬件ECC已恢复"
+
+msgid "Current Pending Sector"
+msgstr "不稳定扇区"
+
+msgid "Offline Uncorrectable"
+msgstr "离线不可纠正扇区"
+
+msgid "UDMA CRC Error Count"
+msgstr "UDMA CRC错误计数"
+
+msgid "Multi Zone Error Rate"
+msgstr "多区错误率"
+
+msgid "Wear Leveling Count"
+msgstr "磨损平衡计数"
+
+msgid "Used Reserved Block Count Total"
+msgstr "已用保留块计数(总计)"
+
+msgid "Used Reserved Block Count Chip"
+msgstr "已用保留块计数(芯片)"
+
+msgid "Unused Reserved Block Count Total"
+msgstr "未用保留块"
+
+msgid "Program Fail Count Total"
+msgstr "写入失败计数"
+
+msgid "Erase Fail Count Total"
+msgstr "擦除失败计数"
+
+msgid "Runtime Bad Block"
+msgstr "坏块"
+
+msgid "Uncorrectable Error Count"
+msgstr "不可纠正错误计数"
+
+msgid "Temperature Exceed Count"
+msgstr "温度超标次数"
+
+msgid "Erase Fail Count"
+msgstr "擦除失败计数"
+
+msgid "Reported Uncorrectable Errors"
+msgstr "报告的不可纠正错误"
+
+msgid "High Fly Writes"
+msgstr "高飞写入"
+
+msgid "G-Sense Error Rate"
+msgstr "G感应错误率"
+
+msgid "Power-Off Retract Count"
+msgstr "断电时磁头收回次数"
+
+msgid "Load Cycle Count"
+msgstr "磁头停靠循环次数"
+
+msgid "Temperature Case"
+msgstr "外壳温度"
+
+msgid "Reallocated Event Count"
+msgstr "重新分配事件计数"
+
+msgid "Transfer Error Rate"
+msgstr "传输错误率"
+
+msgid "Free Fall Sensor"
+msgstr "自由落体传感器"
+
+msgid "Total LBAs Written"
+msgstr "写入LBA总数"
+
+msgid "Total LBAs Read"
+msgstr "读取LBA总数"
+
+msgid "Read Error Retry Rate"
+msgstr "读取重试率"
+
+msgid "Minimum W/E Cycle"
+msgstr "最小写入/擦除循环"
+
+msgid "Maximum W/E Cycle"
+msgstr "最大写入/擦除循环"
+
+msgid "Average W/E Cycle"
+msgstr "平均写入/擦除循环"
+
+msgid "Media Wearout Indicator"
+msgstr "介质磨损指示器"
+
+msgid "Available Reserved Space"
+msgstr "可用保留空间"
+
+msgid "SSD Life Left"
+msgstr "SSD剩余寿命"
+
+msgid "Remaining Lifetime Percentage"
+msgstr "剩余寿命百分比"
+
+msgid "Percentage Lifetime Remaining"
+msgstr "剩余寿命百分比"
+
+msgid "Remaining Life"
+msgstr "剩余寿命"
+
+msgid "Lifetime Writes GiB"
+msgstr "写入数据(GiB)"
+
+msgid "Lifetime Reads GiB"
+msgstr "读取数据(GiB)"
+
+msgid "Program Fail Count"
+msgstr "编程失败计数"
+
+msgid "Unexpected Power Loss Count"
+msgstr "意外断电次数"
+
+msgid "Thermal Throttle Status"
+msgstr "温控降速状态"
+
+msgid "End-to-End Error"
+msgstr "端到端错误"
+
+msgid "Workload Host Reads Percentage"
+msgstr "主机读取百分比"
+
+msgid "Workload Media Wear Indicator"
+msgstr "介质磨损指示器(工作负载)"
+
+msgid "Timed Workload Media Wear"
+msgstr "介质磨损(定时工作负载)"
+
+msgid "Workload Timer"
+msgstr "工作负载计时器"
+
+msgid "Percentage Rated Life Used"
+msgstr "已用额定寿命百分比"
+
+msgid "Head Flying Hours"
+msgstr "磁头飞行小时数"
+
+msgid "Read Channel Margin"
+msgstr "读取通道裕量"
+
+msgid "Loaded Hours"
+msgstr "非停靠运行时间"
+
+msgid "Load/Unload Retry Count"
+msgstr "停靠/解除停靠重试次数"
+
+msgid "GMR Head Amplitude"
+msgstr "GMR磁头振幅"
+
+msgid "Drive Temperature"
+msgstr "驱动器温度"
+
+msgid "Endurance Remaining"
+msgstr "剩余耐久性"
+
+msgid "Power On Hours and Milliseconds"
+msgstr "通电时间(小时和毫秒)"
+
+msgid "Head Health"
+msgstr "磁头状态"
+
+msgid "POR Recovery Count"
+msgstr "POR恢复次数"
+
+msgid "Unused Reserve NAND Blocks"
+msgstr "未用NAND保留块"
+
+msgid "SSD Protect Mode"
+msgstr "SSD保护模式"
+
+msgid "Host Writes 32MiB"
+msgstr "主机写入(32MiB)"
+
+msgid "NAND Writes 32MiB"
+msgstr "NAND写入(32MiB)"
+
+msgid "Remaining Life Left"
+msgstr "剩余寿命"
+
+msgid "Grown Bad Block Count"
+msgstr "新增坏块数"
+
+msgid "Soft Read Error Rate"
+msgstr "软读取错误率"
+
+msgid "Data Address Mark Errors"
+msgstr "数据地址标记错误"
+
+msgid "Run Out Cancel"
+msgstr "溢出取消"
+
+msgid "Soft ECC Correction"
+msgstr "软ECC纠正"
+
+msgid "TA Increase Count"
+msgstr "TA增加计数"
+
+msgid "Shock Count Write Operation"
+msgstr "写入时冲击次数"
+
+msgid "Shock Rate Write Operation"
+msgstr "写入时冲击率"
+
+msgid "Flying Height"
+msgstr "磁头飞行高度"
+
+msgid "Spin High Current"
+msgstr "启动高电流"
+
+msgid "Spin Buzz"
+msgstr "启动噪音"
+
+msgid "Offline Seek Performance"
+msgstr "离线寻道性能"
+
+msgid "Vibration During Write"
+msgstr "写入时振动"
+
+msgid "Shock During Write"
+msgstr "写入时冲击"
+
+msgid "Disk Shift"
+msgstr "磁盘偏移"
+
+msgid "Load Retry Count"
+msgstr "加载重试次数"
+
+msgid "Load Friction"
+msgstr "加载摩擦"
+
+msgid "Load-in Time"
+msgstr "加载时间"
+
+msgid "Torque Amplification Count"
+msgstr "扭矩放大次数"
+
+msgid "Write Error Rate"
+msgstr "写入错误率"
+
+msgid "Serial Number"
+msgstr "序列号"
+
+msgid "LU WWN Device Id"
+msgstr "LU WWN设备ID"
+
+msgid "Firmware Version"
+msgstr "固件版本"
+
+msgid "User Capacity"
+msgstr "可用容量"
+
+msgid "Capacity"
+msgstr "容量"
+
+msgid "Sector Size"
+msgstr "扇区大小"
+
+msgid "Sector Sizes"
+msgstr "扇区大小"
+
+msgid "Rotation Rate"
+msgstr "转速"
+
+msgid "Form Factor"
+msgstr "外形规格"
+
+msgid "Device is"
+msgstr "设备"
+
+msgid "ATA Version is"
+msgstr "ATA版本"
+
+msgid "SATA Version is"
+msgstr "SATA版本"
+
+msgid "Local Time is"
+msgstr "本地时间"
+
+msgid "SMART support is"
+msgstr "SMART支持"
+
+msgid "SMART Status"
+msgstr "SMART状态"
+
+msgid "Device"
+msgstr "设备"
+
+msgid "Model Number"
+msgstr "型号"
+
+msgid "Firmware Revision"
+msgstr "固件修订版"
+
+msgid "PCI Vendor/Subsystem ID"
+msgstr "PCI供应商/子系统ID"
+
+msgid "IEEE OUI Identifier"
+msgstr "IEEE OUI标识符"
+
+msgid "Total NVM Capacity"
+msgstr "NVM总容量"
+
+msgid "Unallocated NVM Capacity"
+msgstr "未分配NVM容量"
+
+msgid "Controller ID"
+msgstr "控制器ID"
+
+msgid "Number of Namespaces"
+msgstr "命名空间数量"
+
+msgid "Namespace 1 Size/Capacity"
+msgstr "命名空间1大小/容量"
+
+msgid "Namespace 1 Formatted LBA Size"
+msgstr "命名空间1 LBA大小"
+
+msgid "Namespace 1 IEEE EUI-64"
+msgstr "命名空间1 IEEE EUI-64"
+
+msgid "logical/physical"
+msgstr "逻辑/物理"
+
+msgid "bytes"
+msgstr "字节"
+
+msgid "blocks"
+msgstr "块"
+
+msgid "Solid State Device"
+msgstr "固态硬盘"
+
+# Reserved space
+
+msgid "Reserved space"
+msgstr "预留空间"
+
+msgid "Space reserved for root (default: 5%)"
+msgstr "为 root 预留的空间（默认：5%）"
+
+msgid "Used Reserved Block Count Total"
+msgstr "已用预留块总数"
+
+msgid "Used Reserved Block Count Chip"
+msgstr "芯片已用预留块数"
+
+msgid "Unused Reserved Block Count Total"
+msgstr "未用预留块总数"
+
+msgid "Available Reserved Space"
+msgstr "可用预留空间"
+
+# NVMe
+
+msgid "Critical Warning"
+msgstr "严重警告"
+
+msgid "Percentage Used"
+msgstr "使用百分比"
+
+msgid "Data Units Read"
+msgstr "读取数据单元"
+
+msgid "Data Units Written"
+msgstr "写入数据单元"
+
+msgid "Host Read Commands"
+msgstr "主机读取命令"
+
+msgid "Host Write Commands"
+msgstr "主机写入命令"
+
+msgid "Controller Busy Time"
+msgstr "控制器忙碌时间"
+
+msgid "Power Cycles"
+msgstr "电源循环"
+
+msgid "Unsafe Shutdowns"
+msgstr "非安全关机"
+
+msgid "Media Errors"
+msgstr "介质错误"
+
+msgid "Error Log Entries"
+msgstr "错误日志条目"
diff --git a/package/luci-app-mini-diskmanager/po/zh_Hant/mini-diskmanager.po b/package/luci-app-mini-diskmanager/po/zh_Hant/mini-diskmanager.po
new file mode 100644
index 0000000000..199b10da30
--- /dev/null
+++ b/package/luci-app-mini-diskmanager/po/zh_Hant/mini-diskmanager.po
@@ -0,0 +1,1815 @@
+msgid ""
+msgstr ""
+"Project-Id-Version: luci-app-mini-diskmanager\n"
+"POT-Creation-Date: 2026-01-18 12:20+0800\n"
+"PO-Revision-Date: \n"
+"Last-Translator: \n"
+"Language-Team: Victor Tseng\n"
+"Language: zh_TW\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"X-Generator: Poedit 3.7\n"
+"X-Poedit-Basepath: ../..\n"
+"X-Poedit-SearchPath-0: .\n"
+
+#: htdocs/luci-static/resources/view/mdmconfig.js:81
+msgid "Configuration"
+msgstr "設定"
+
+#: htdocs/luci-static/resources/view/mdmconfig.js:83
+msgid "Filesystem"
+msgstr "檔案系統"
+
+#: htdocs/luci-static/resources/view/mdmconfig.js:87
+msgid "Packages & Drivers"
+msgstr "套件 & 驅動程式"
+
+#: htdocs/luci-static/resources/view/mdmconfig.js:88
+msgid "Mini Disk Manager log"
+msgstr "迷你磁碟機管理員日誌"
+
+#: htdocs/luci-static/resources/view/mdmconfig.js:94
+msgid "Package and Driver Verification"
+msgstr "套件與驅動程式驗證"
+
+#: htdocs/luci-static/resources/view/mdmconfig.js:95
+msgid "Check and install required drivers for storage devices."
+msgstr "檢查並安裝儲存設備需要的驅動程式。"
+
+#: htdocs/luci-static/resources/view/mdmconfig.js:99
+msgid "Check USB drivers"
+msgstr "檢查 USB 驅動程式"
+
+#: htdocs/luci-static/resources/view/mdmconfig.js:100
+msgid "USB drivers"
+msgstr "USB 驅動程式"
+
+#: htdocs/luci-static/resources/view/mdmconfig.js:115
+msgid "Check NVMe drivers"
+msgstr "檢查 NVMe 驅動程式"
+
+#: htdocs/luci-static/resources/view/mdmconfig.js:116
+msgid "NVMe drivers"
+msgstr "NVMe 驅動程式"
+
+#: htdocs/luci-static/resources/view/mdmconfig.js:127
+msgid "Check ATA/SATA drivers"
+msgstr "檢查 ATA/SATA 驅動程式"
+
+#: htdocs/luci-static/resources/view/mdmconfig.js:128
+msgid "ATA/SATA drivers"
+msgstr "ATA/SATA 驅動程式"
+
+#: htdocs/luci-static/resources/view/mdmconfig.js:144
+msgid "Filesystem Support"
+msgstr "檔案系統支援"
+
+#: htdocs/luci-static/resources/view/mdmconfig.js:145
+msgid "Packages required to support various file systems."
+msgstr "支援各種檔案系統所需的套件。"
+
+#: htdocs/luci-static/resources/view/mdmconfig.js:149
+msgid "Check Linux filesystem packages"
+msgstr "檢查 Linux 檔案系統套件"
+
+#: htdocs/luci-static/resources/view/mdmconfig.js:150
+msgid "Linux filesystems"
+msgstr "Linux 檔案系統"
+
+#: htdocs/luci-static/resources/view/mdmconfig.js:171
+msgid "Check Windows filesystem packages"
+msgstr "檢查 Windows 檔案系統套件"
+
+#: htdocs/luci-static/resources/view/mdmconfig.js:172
+msgid "Windows filesystems"
+msgstr "Windows 檔案系統"
+
+#: htdocs/luci-static/resources/view/mdmconfig.js:200
+msgid "Disk Wipe Support"
+msgstr "磁碟機抹除支援"
+
+#: htdocs/luci-static/resources/view/mdmconfig.js:201
+msgid ""
+"Packages required to support disk wiping functionality (clearing partition "
+"table)."
+msgstr "磁碟機抹除功能所需的套件（抹除分割區表）。"
+
+#: htdocs/luci-static/resources/view/mdmconfig.js:205
+msgid "Check Disk Wipe packages"
+msgstr "檢查磁碟機抹除套件"
+
+#: htdocs/luci-static/resources/view/mdmconfig.js:206
+msgid "Disk Wipe"
+msgstr "磁碟機抹除"
+
+#: htdocs/luci-static/resources/view/mdmconfig.js:211
+#: htdocs/luci-static/resources/view/mdmconfig.js:212
+msgid "alternative"
+msgstr "替代選項"
+
+#: htdocs/luci-static/resources/view/mdmconfig.js:219
+msgid "Loading package data…"
+msgstr "正在載入軟體套件資料…"
+
+#: htdocs/luci-static/resources/view/mdmconfig.js:252
+msgid "dd from BusyBox"
+msgstr "BusyBox 的 dd"
+
+#: htdocs/luci-static/resources/view/mdmconfig.js:254
+msgid "Installed"
+msgstr "已安裝"
+
+#: htdocs/luci-static/resources/view/mdmconfig.js:259
+msgid "Install…"
+msgstr "安裝…"
+
+#: htdocs/luci-static/resources/view/mdmconfig.js:287
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3473
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3701
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3916
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3931
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4019
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4606
+msgid "Close"
+msgstr "關閉"
+
+#: htdocs/luci-static/resources/view/mdmconfig.js:296
+msgid "Mini Disk Manager Log"
+msgstr "迷你磁碟機管理員日誌"
+
+#: htdocs/luci-static/resources/view/mdmconfig.js:309
+msgid "Loading log file…"
+msgstr "正在載入日誌檔案…"
+
+#: htdocs/luci-static/resources/view/mdmconfig.js:311
+msgid "Log file is empty"
+msgstr "日誌檔案沒有內容"
+
+#: htdocs/luci-static/resources/view/mdmconfig.js:313
+msgid "Unable to read log file"
+msgstr "無法讀取日誌檔案"
+
+#: htdocs/luci-static/resources/view/mdmconfig.js:328
+msgid "Log file cleared successfully"
+msgstr "成空清除日誌檔案"
+
+#: htdocs/luci-static/resources/view/mdmconfig.js:332
+msgid "Unable to clear the file"
+msgstr "無法清除日誌檔案"
+
+#: htdocs/luci-static/resources/view/mdmconfig.js:335
+msgid "Clear"
+msgstr "清除"
+
+#: htdocs/luci-static/resources/view/mdmconfig.js:347
+msgid "Download"
+msgstr "下載"
+
+#: htdocs/luci-static/resources/view/mdmconfig.js:352
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2078
+msgid "Refresh"
+msgstr "更新"
+
+#: htdocs/luci-static/resources/view/mdmsupport.js:34
+msgid "The tab allows users to support the package."
+msgstr "這頁允許使用者支持這個套件開發。"
+
+#: htdocs/luci-static/resources/view/mdmsupport.js:36
+msgid "Package support"
+msgstr "套件支持"
+
+#: htdocs/luci-static/resources/view/mdmsupport.js:41
+msgid "Mini Disk Manager Info"
+msgstr "迷你磁碟機管理員資訊"
+
+#: htdocs/luci-static/resources/view/mdmsupport.js:45
+msgid "Luci-app-mini-diskmanager"
+msgstr "luci-app-mini-diskmanager"
+
+#: htdocs/luci-static/resources/view/mdmsupport.js:51
+msgid "Buy a coffee"
+msgstr "喝杯咖啡"
+
+#: htdocs/luci-static/resources/view/mdmsupport.js:52
+msgid ""
+"Buy a coffee if you want to support the development of the project and the "
+"author"
+msgstr "想支持專案的開發？請作者喝杯咖啡"
+
+#: htdocs/luci-static/resources/view/mdmsupport.js:58
+msgid "Become a sponsor"
+msgstr "成為贊助商"
+
+#: htdocs/luci-static/resources/view/mdmsupport.js:59
+msgid ""
+"Become a sponsor if you want to support the development of the project and "
+"the author"
+msgstr "想支持作者與專案的開發，請成為贊助商"
+
+#: htdocs/luci-static/resources/view/mdmsupport.js:65
+msgid "Write on forum"
+msgstr "在論壇上留言"
+
+#: htdocs/luci-static/resources/view/mdmsupport.js:66
+msgid "Write in the topic of the package on the forum eko.one.pl"
+msgstr "在 eko.one.pl 論壇的套件討論主題下留言"
+
+#: htdocs/luci-static/resources/view/mdmsupport.js:72
+msgid "Open discussion"
+msgstr "打開討論"
+
+#: htdocs/luci-static/resources/view/mdmsupport.js:73
+msgid "Open a package discussion on Github"
+msgstr "在 GitHub 上打開套件討論區"
+
+#: htdocs/luci-static/resources/view/mdmsupport.js:79
+msgid "Report a bug"
+msgstr "回報錯誤"
+
+#: htdocs/luci-static/resources/view/mdmsupport.js:80
+msgid "Report a bug on the package Github page"
+msgstr "在套件的 Github 專案中回報錯誤"
+
+#: htdocs/luci-static/resources/view/mdmsupport.js:94
+msgid "Package name"
+msgstr "套件名稱"
+
+#: htdocs/luci-static/resources/view/mdmsupport.js:95
+msgid "Author (package maintainer)"
+msgstr "作者（套件維護者）"
+
+#: htdocs/luci-static/resources/view/mdmsupport.js:136
+msgid "Information about package author and available support options."
+msgstr "關於套件作者與支持選項的資訊。"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:743
+msgid "Unknown RPC method: "
+msgstr "未知的 RPC 方法："
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:749
+msgid "RPC call failed: no response"
+msgstr "RPC 呼叫失敗：沒有回應"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:770
+msgid "more info in log"
+msgstr "更多訊息請至日誌查詢"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:780
+msgid "Failed to check operation status: "
+msgstr "檢查操作狀態失敗："
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1179
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1202
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3722
+msgid "PASSED"
+msgstr "通過"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1181
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3585
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4668
+msgid "WARNING"
+msgstr "警告"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1185
+msgid "ERRORS"
+msgstr "錯誤"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1187
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3584
+msgid "OK"
+msgstr "正常"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1204
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3723
+msgid "FAILED"
+msgstr "失敗"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1225
+msgid "year"
+msgstr "年"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1225
+msgid "years"
+msgstr "年"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1226
+msgid "month"
+msgstr "月"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1226
+msgid "months"
+msgstr "月"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1227
+msgid "day"
+msgstr "天"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1227
+msgid "days"
+msgstr "天"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1228
+msgid "hour"
+msgstr "小時"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1228
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1230
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3789
+msgid "hours"
+msgstr "小時"
+
+# SMART & Disk Info
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1235
+msgid "Raw Read Error Rate"
+msgstr "原始讀取錯誤率"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1236
+msgid "Throughput Performance"
+msgstr "吞吐量性能"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1237
+msgid "Spin Up Time"
+msgstr "旋轉啟動時間"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1238
+msgid "Start Stop Count"
+msgstr "啟動、停止次數"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1239
+msgid "Reallocated Sector Count"
+msgstr "重新分配的扇區計數"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1240
+msgid "Seek Error Rate"
+msgstr "搜尋錯誤率"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1241
+msgid "Seek Time Performance"
+msgstr "搜尋時間性能"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1242
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1474
+msgid "Power On Hours"
+msgstr "通電時間（小時）"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1243
+msgid "Spin Retry Count"
+msgstr "啟動重試次數"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1244
+msgid "Calibration Retry Count"
+msgstr "校準重試次數"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1245
+msgid "Power Cycle Count"
+msgstr "電源循環次數"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1246
+msgid "Read Soft Error Rate"
+msgstr "軟體讀取錯誤率"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1247
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1266
+msgid "Airflow Temperature"
+msgstr "氣流溫度"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1248
+msgid "Temperature Celsius"
+msgstr "溫度（攝氏）"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1249
+msgid "Hardware ECC Recovered"
+msgstr "硬體 ECC 校正次數"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1250
+msgid "Current Pending Sector"
+msgstr "目前待重新分配的扇區"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1251
+msgid "Offline Uncorrectable"
+msgstr "離線不可糾正"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1252
+msgid "UDMA CRC Error Count"
+msgstr "UDMA CRC 錯誤計數"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1253
+msgid "Multi Zone Error Rate"
+msgstr "多區域錯誤率"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1254
+msgid "Wear Leveling Count"
+msgstr "磨損均衡次數"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1255
+msgid "Used Reserved Block Count Total"
+msgstr "已用保留區塊（總數）"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1256
+msgid "Used Reserved Block Count Chip"
+msgstr "已用保留區塊（晶片）"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1257
+msgid "Unused Reserved Block Count Total"
+msgstr "未使用的保留區塊（總數）"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1258
+msgid "Program Fail Count Total"
+msgstr "程式失敗計數（總數）"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1259
+msgid "Erase Fail Count Total"
+msgstr "抹除失敗記數（總數）"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1260
+msgid "Runtime Bad Block"
+msgstr "運作期損毀區塊"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1261
+msgid "Uncorrectable Error Count"
+msgstr "無法糾正的錯誤記數"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1262
+msgid "Temperature Exceed Count"
+msgstr "溫度過高記數"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1263
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1292
+msgid "Erase Fail Count"
+msgstr "抹除失敗記數"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1264
+msgid "Reported Uncorrectable Errors"
+msgstr "回報的不可糾正錯誤"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1265
+msgid "High Fly Writes"
+msgstr "高飛行寫入"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1267
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1268
+msgid "G-Sense Error Rate"
+msgstr "重力感測器錯誤率"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1269
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1270
+msgid "Power-Off Retract Count"
+msgstr "斷電磁頭回收計數"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1271
+msgid "Load Cycle Count"
+msgstr "負載循環次數"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1272
+msgid "Temperature Case"
+msgstr "外殼溫度"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1273
+msgid "Reallocated Event Count"
+msgstr "重新分配事件計數"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1274
+msgid "Transfer Error Rate"
+msgstr "傳輸錯誤率"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1275
+msgid "Free Fall Sensor"
+msgstr "自由落体传感器"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1276
+msgid "Total LBAs Written"
+msgstr "寫入 LBAs（總數）"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1277
+msgid "Total LBAs Read"
+msgstr "讀取 LBAs（總數）"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1278
+msgid "Read Error Retry Rate"
+msgstr "讀取重試率"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1279
+msgid "Minimum W/E Cycle"
+msgstr "最小寫入/抹除循環"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1280
+msgid "Maximum W/E Cycle"
+msgstr "最大寫入/抹除循環"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1281
+msgid "Average W/E Cycle"
+msgstr "平均寫入/抹除循環"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1282
+msgid "Media Wearout Indicator"
+msgstr "介質磨損指示器"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1283
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1290
+msgid "Available Reserved Space"
+msgstr "可用保留空間"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1284
+msgid "SSD Life Left"
+msgstr "SSD剩余寿命"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1285
+msgid "Remaining Lifetime Percentage"
+msgstr "剩餘壽命百分比"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1286
+msgid "Percentage Lifetime Remaining"
+msgstr "剩餘壽命百分比"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1287
+msgid "Remaining Life"
+msgstr "剩餘壽命"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1288
+msgid "Lifetime Writes GiB"
+msgstr "生命週期寫入量（GiB）"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1289
+msgid "Lifetime Reads GiB"
+msgstr "生命週期讀取量（GiB）"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1291
+msgid "Program Fail Count"
+msgstr "程式失敗計數"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1293
+msgid "Unexpected Power Loss Count"
+msgstr "意外斷電次數"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1294
+msgid "Thermal Throttle Status"
+msgstr "溫控降速狀態"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1295
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1296
+msgid "End-to-End Error"
+msgstr "端到端錯誤"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1297
+msgid "Workload Host Reads Percentage"
+msgstr "主機讀取百分比（工作負載）"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1298
+msgid "Workload Media Wear Indicator"
+msgstr "介質磨損指示器（工作負載）"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1299
+msgid "Timed Workload Media Wear"
+msgstr "介質磨損（定時工作負載）"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1300
+msgid "Workload Timer"
+msgstr "工作負載計時器"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1301
+msgid "Percentage Rated Life Used"
+msgstr "已用壽命百分比"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1302
+msgid "Head Flying Hours"
+msgstr "磁頭飛行時數（小時）"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1303
+msgid "Read Channel Margin"
+msgstr "讀取通道邊界"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1304
+msgid "Loaded Hours"
+msgstr "負載時間（小時）"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1305
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1306
+msgid "Load/Unload Retry Count"
+msgstr "負載/無負載重試次數"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1307
+msgid "GMR Head Amplitude"
+msgstr "GMR 磁頭振幅"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1308
+msgid "Drive Temperature"
+msgstr "驅動器溫度"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1309
+msgid "Endurance Remaining"
+msgstr "剩餘耐久度"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1310
+msgid "Power On Hours and Milliseconds"
+msgstr "通電時間（小時及毫秒）"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1311
+msgid "Head Health"
+msgstr "磁頭健康度"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1312
+msgid "POR Recovery Count"
+msgstr "POR 恢復次數"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1313
+msgid "Unused Reserve NAND Blocks"
+msgstr "未使用的保留 NAND 區塊"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1314
+msgid "SSD Protect Mode"
+msgstr "SSD 防護模式"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1315
+msgid "Host Writes 32MiB"
+msgstr "主機寫入（32MiB）"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1316
+msgid "NAND Writes 32MiB"
+msgstr "NAND 寫入（32MiB）"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1317
+msgid "Remaining Life Left"
+msgstr "剩餘壽命"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1318
+msgid "Grown Bad Block Count"
+msgstr "成長壞軌計數"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1319
+msgid "Soft Read Error Rate"
+msgstr "軟體讀取錯誤率"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1320
+msgid "Data Address Mark Errors"
+msgstr "資料位置標記錯誤"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1321
+msgid "Run Out Cancel"
+msgstr "溢出取消"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1322
+msgid "Soft ECC Correction"
+msgstr "軟體 ECC 校正"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1323
+msgid "TA Increase Count"
+msgstr "TA 增加次數"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1324
+msgid "Shock Count Write Operation"
+msgstr "寫入時衝擊次數"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1325
+msgid "Shock Rate Write Operation"
+msgstr "寫入時衝擊率"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1326
+msgid "Flying Height"
+msgstr "磁頭飛行高度"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1327
+msgid "Spin High Current"
+msgstr "旋轉高電流"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1328
+msgid "Spin Buzz"
+msgstr "旋轉噪音"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1329
+msgid "Offline Seek Performance"
+msgstr "離線搜尋性能"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1330
+msgid "Vibration During Write"
+msgstr "寫入時振動"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1331
+msgid "Shock During Write"
+msgstr "寫入時衝擊"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1332
+msgid "Disk Shift"
+msgstr "磁碟偏移"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1333
+msgid "Load Retry Count"
+msgstr "負載重試次數"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1334
+msgid "Load Friction"
+msgstr "負載摩擦"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1335
+msgid "Load-in Time"
+msgstr "負載時間"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1336
+msgid "Torque Amplification Count"
+msgstr "扭矩放大次數"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1337
+msgid "Write Error Rate"
+msgstr "寫入錯誤率"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1348
+msgid "Model Family"
+msgstr "型號家族"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1349
+msgid "Device Model"
+msgstr "設備型號"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1350
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1351
+msgid "Serial Number"
+msgstr "序列號"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1352
+msgid "LU WWN Device Id"
+msgstr "LU WWN 設備 Id"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1353
+msgid "Firmware Version"
+msgstr "韌體版本"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1354
+msgid "User Capacity"
+msgstr "可用容量"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1355
+msgid "Capacity"
+msgstr "容量"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1356
+msgid "Sector Size"
+msgstr "扇區大小"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1357
+msgid "Sector Sizes"
+msgstr "扇區大小"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1358
+msgid "Rotation Rate"
+msgstr "轉速"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1359
+msgid "Form Factor"
+msgstr "外型規格"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1360
+msgid "Device is"
+msgstr "設備"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1361
+msgid "ATA Version is"
+msgstr "ATA 版本"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1362
+msgid "SATA Version is"
+msgstr "SATA 版本"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1363
+msgid "Local Time is"
+msgstr "本地時間"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1364
+msgid "SMART support is"
+msgstr "SMART 支援"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1365
+msgid "SMART Status"
+msgstr "SMART 狀態"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1366
+msgid "Device"
+msgstr "設備"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1368
+msgid "Model Number"
+msgstr "型號編碼"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1369
+msgid "Firmware Revision"
+msgstr "韌體修訂版"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1370
+msgid "PCI Vendor/Subsystem ID"
+msgstr "PCI 供應商 / 子系統 ID"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1371
+msgid "IEEE OUI Identifier"
+msgstr "IEEE OUI 識別符"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1372
+msgid "Total NVM Capacity"
+msgstr "總 NVM 容量"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1373
+msgid "Unallocated NVM Capacity"
+msgstr "未分配的 NVM 容量"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1374
+msgid "Controller ID"
+msgstr "控制器 ID"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1375
+msgid "Number of Namespaces"
+msgstr "命名空間數量"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1376
+msgid "Namespace 1 Size/Capacity"
+msgstr "命名空間 1 - 大小/容量"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1377
+msgid "Namespace 1 Formatted LBA Size"
+msgstr "命名空間 1 - LBA 大小"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1378
+msgid "Namespace 1 IEEE EUI-64"
+msgstr "命名空間 1 - IEEE EUI-64"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1380
+msgid "logical/physical"
+msgstr "邏輯/物理"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1381
+msgid "bytes"
+msgstr "位元組"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1382
+msgid "blocks"
+msgstr "區塊"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1383
+msgid "Solid State Device"
+msgstr "固態磁碟機"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1419
+msgid "Critical Warning"
+msgstr "嚴重警告"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1424
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3621
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3794
+msgid "Temperature"
+msgstr "溫度"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1429
+msgid "Available Spare"
+msgstr "可用備用空間"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1434
+msgid "Available Spare Threshold"
+msgstr "可用備用空間門檻"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1439
+msgid "Percentage Used"
+msgstr "已用百分比"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1444
+msgid "Data Units Read"
+msgstr "讀取過的資料單位"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1449
+msgid "Data Units Written"
+msgstr "寫入過的資料單位"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1454
+msgid "Host Read Commands"
+msgstr "主機讀取指令"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1459
+msgid "Host Write Commands"
+msgstr "主機寫入指令"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1464
+msgid "Controller Busy Time"
+msgstr "控制器忙碌時間"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1469
+msgid "Power Cycles"
+msgstr "電源循環次數"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1479
+msgid "Unsafe Shutdowns"
+msgstr "不安全關機"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1484
+msgid "Media Errors"
+msgstr "介質錯誤"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:1489
+msgid "Error Log Entries"
+msgstr "錯誤日誌項目"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2062
+msgid "Select a disk"
+msgstr "選擇磁碟機"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2062
+msgid "-- "
+msgstr "--"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2072
+msgid "Disk"
+msgstr "磁碟機"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2082
+msgid "Mounting actions"
+msgstr "掛載操作"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2089
+msgid "Mount"
+msgstr "掛載"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2095
+msgid "Unmount"
+msgstr "卸載"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2099
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3448
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3464
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3692
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3913
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3922
+msgid "S.M.A.R.T. Status"
+msgstr "S.M.A.R.T. 狀態"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2106
+msgid "Show"
+msgstr "顯示"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2110
+msgid "Actions on partitions"
+msgstr "分割區操作"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2117
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4321
+msgid "Create"
+msgstr "建立"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2123
+msgid "Expand"
+msgstr "展開"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2129
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4986
+msgid "Delete"
+msgstr "刪除"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2135
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4598
+msgid "Format"
+msgstr "格式化"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2141
+msgid "Wipe"
+msgstr "擦除"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2147
+#: htdocs/luci-static/resources/view/minidiskmanager.js:5071
+msgid "Please select a disk to view its partitions"
+msgstr "請選擇磁碟來查看他的分割區"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2151
+msgid "Disk Manager"
+msgstr "磁碟機管理員"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2154
+msgid ""
+"The Mini Disk Manager package allows users to easily manage disks and "
+"partitions."
+msgstr "迷你磁碟機管理器套件，讓使用者輕鬆管理磁碟機與分割區。"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2208
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2329
+msgid "Area without partition table"
+msgstr "沒有分割表的區域"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2238
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2359
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2704
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2705
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2706
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2910
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3213
+msgid "Unallocated"
+msgstr "未分配"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2477
+msgid "Free Space"
+msgstr "可用空間"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2627
+msgid "Free"
+msgstr "可用"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2693
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2954
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4099
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4104
+msgid "Primary"
+msgstr "主要分割區"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2694
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2955
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4106
+msgid "Extended"
+msgstr "擴展分割區"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2695
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2956
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4094
+msgid "Logical"
+msgstr "邏輯分割區"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2703
+msgid "Linux Swap"
+msgstr "Linux 置換分割區"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2786
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4550
+msgid "Partition"
+msgstr "分割區"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2787
+msgid "Type / Filesystem"
+msgstr "類型 / 檔案系統"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2788
+msgid "Mount Point"
+msgstr "掛載點"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2789
+msgid "Label"
+msgstr "標籤"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2790
+msgid "Size"
+msgstr "大小"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2791
+msgid "Used"
+msgstr "已用"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2792
+msgid "Unused"
+msgstr "可用"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2793
+msgid "Flags"
+msgstr "旗標"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2818
+msgid "Select all partitions for wiping"
+msgstr "選擇要抹除的所有分割區"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2878
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3179
+msgid "Select unallocated space"
+msgstr "選擇未分配的空間"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2897
+msgid "No partitions - select to create"
+msgstr "無分割區 - 選擇以建立"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2898
+msgid "No partition table - select to create"
+msgstr "沒有分割區列表，請選擇建立"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:2901
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3204
+msgid "Select to enable partition creation"
+msgstr "選擇以啟用建立分割區"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3024
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3109
+msgid "System partition cannot be selected"
+msgstr "無法選擇系統分割區"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3024
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3109
+msgid "Click to select"
+msgstr "點擊以選擇"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3208
+msgid "Unallocated space"
+msgstr "未分配的空間"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3441
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3939
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4453
+msgid "Please select a disk first"
+msgstr "請先選擇磁碟機"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3451
+msgid "Loading S.M.A.R.T. data..."
+msgstr "正在加载 S.M.A.R.T. 数据..."
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3467
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3695
+msgid "Information"
+msgstr "資訊"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3469
+msgid "Unable to read S.M.A.R.T. data."
+msgstr "无法读取 S.M.A.R.T. 数据。"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3590
+msgid "NVMe S.M.A.R.T. Health Status"
+msgstr "NVMe S.M.A.R.T. 健康狀態"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3611
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3784
+msgid "Power On Time"
+msgstr "通電時間"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3616
+msgid "h"
+msgstr "時"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3633
+msgid "Disk Usage"
+msgstr "磁碟機使用率"
+
+# SMART
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3659
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3838
+msgid "Attribute"
+msgstr "屬性"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3660
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3839
+msgid "Value"
+msgstr "值"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3676
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3890
+msgid "Unknown"
+msgstr "未知"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3697
+msgid "No S.M.A.R.T. attributes found."
+msgstr "沒有找到 S.M.A.R.T. 屬性。"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3728
+msgid "S.M.A.R.T. Health Status"
+msgstr "S.M.A.R.T. 磁盘整体健康状态"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3806
+msgid "Disk Wear Level"
+msgstr "磁碟機耗損等級"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3811
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3820
+msgid "worn"
+msgstr "已耗損"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3811
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3820
+msgid "remaining"
+msgstr "剩餘"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3837
+msgid "Id"
+msgstr "Id"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3840
+msgid "Worst"
+msgstr "最糟"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3841
+msgid "Thresh"
+msgstr "門檻值"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3842
+msgid "Raw"
+msgstr "原始值"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3925
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4545
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4827
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4971
+msgid "Warning"
+msgstr "警告"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3927
+msgid "Error reading S.M.A.R.T. data."
+msgstr "讀取 S.M.A.R.T. 資訊時發生錯誤。"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3951
+msgid "No unallocated space available on this disk"
+msgstr "這個磁碟機上沒有可用的未分配空間"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3965
+msgid "Cannot read partition information"
+msgstr "無法讀取分割區資訊"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3972
+msgid "Invalid extended partition"
+msgstr "無效的擴展分割區"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3982
+msgid "Extended partition not found or has invalid size"
+msgstr "沒有找到擴展分割區，或大小無效"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:3999
+msgid "Cannot Create Partition"
+msgstr "無法建立分割區"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4002
+msgid "Insufficient Space"
+msgstr "空間不足"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4005
+#, javascript-format
+msgid "Not enough free space in extended partition /dev/%s"
+msgstr "擴展分割區 /dev/%s 中的可用空間不足"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4008
+#, javascript-format
+msgid "Extended partition size: %s MB"
+msgstr "擴展分割區大小：%s MB"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4010
+#, javascript-format
+msgid "Used by logical partitions: %s MB"
+msgstr "邏輯分割區用量：%s MB"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4012
+#, javascript-format
+msgid "Available for new logical: %s MB"
+msgstr "可用於新邏輯分割區：%s MB"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4015
+msgid "Required minimum: 10 MB"
+msgstr "所需最小值：10 MB"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4097
+msgid ""
+"Creating partition inside extended partition. Only logical partitions can be "
+"created here."
+msgstr "在擴展區中建立分割區，此處只能建立邏輯分割區。"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4102
+msgid ""
+"No partition table detected. A primary partition will be created and a "
+"partition table will be initialized."
+msgstr "沒有檢測到分割區列表。將建立主分割區，並初始化分割區列表。"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4112
+msgid ""
+"Extended partition already exists. You can create primary partitions or "
+"select the extended partition to create logical partitions inside."
+msgstr ""
+"擴展分割區已經存在，您可以建立主要分區或選擇要建立邏輯分割區的擴展分割區。"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4129
+msgid "Refreshing..."
+msgstr "正在更新…"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4168
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4279
+#, javascript-format
+msgid "Available: %s MB / %s GB / %s TB"
+msgstr "可用：%s MB / %s GB / %s TB"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4179
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4187
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4316
+msgid "Refresh partition data"
+msgstr "更新分割區資料"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4182
+msgid "Partition data refreshed"
+msgstr "分割區資料已更新"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4184
+msgid "Failed to refresh partition data: "
+msgstr "更新分割區資料失敗："
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4195
+msgid "Create partition"
+msgstr "建立分割區"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4197
+msgid "Create a new partition on the selected disk"
+msgstr "在選定的磁碟機上建立新的分割區"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4200
+msgid "Partition layout"
+msgstr "分割區佈局"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4208
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4211
+msgid "GPT (GUID Partition Table)"
+msgstr "GPT（GUID 分割區列表）"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4208
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4210
+msgid "MBR (Master Boot Record)"
+msgstr "MBR（主要開機紀錄）"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4217
+msgid "Partition type"
+msgstr "分割區類型"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4239
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4561
+msgid "File system"
+msgstr "檔案系統"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4242
+msgid "Loading..."
+msgstr "正在載入…"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4247
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4567
+msgid "Volume label"
+msgstr "容量標籤"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4250
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4570
+msgid "Optional"
+msgstr "可選"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4254
+msgid "Partition size"
+msgstr "分割區大小"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4261
+msgid "Enter size"
+msgstr "輸入大小"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4269
+msgid "MB"
+msgstr "MB"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4270
+msgid "GB"
+msgstr "GB"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4271
+msgid "TB"
+msgstr "TB"
+
+# --
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4290
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4864
+msgid "All available space"
+msgstr "所有可用空間"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4304
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4879
+msgid "Fill in size"
+msgstr "填寫大小"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4309
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4575
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4679
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4885
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4978
+msgid "Cancel"
+msgstr "取消"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4342
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4539
+msgid "No supported filesystems detected on this system"
+msgstr "未檢測到此系統上支援的檔案系統"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4343
+msgid ""
+"No filesystem packages detected — user cannot choose unsupported filesystem "
+"formats."
+msgstr "未檢測到檔案系統套件 - 使用者無法選擇不支援的檔案系統格式。"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4353
+msgid "No partition types available. Maximum partitions reached."
+msgstr "沒有可用的分割區列表，已達最大分割區數量。"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4361
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4896
+msgid "Please enter a valid size"
+msgstr "請輸入有效的大小"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4372
+msgid "Size is too small"
+msgstr "大小不足"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4444
+msgid "Failed to load disk information: "
+msgstr "載入磁碟機資訊失敗："
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4474
+msgid "Creating partition..."
+msgstr "正在建立分割區…"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4475
+msgid "Partition created successfully"
+msgstr "成功建立分割區"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4476
+msgid "Failed to create partition"
+msgstr "建立分割區失敗"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4479
+msgid "Failed to start partition creation"
+msgstr "開始分割區建立失敗"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4497
+msgid ""
+"Partition created but selected filesystem is not available for formatting on "
+"this system"
+msgstr "分割區已經建立，但此系統不支援選擇的檔案系統"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4501
+msgid "Partition created but device node did not appear in time"
+msgstr "分區已經建立，但設備節點未在時限內出現"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4519
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4730
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4957
+#: htdocs/luci-static/resources/view/minidiskmanager.js:5018
+#: htdocs/luci-static/resources/view/minidiskmanager.js:5040
+msgid "Please select a partition first"
+msgstr "請先選擇分割區"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4524
+msgid "Cannot format mounted partition. Please unmount first."
+msgstr "無法格式化已經掛載的分割區，請先將其卸載。"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4542
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4602
+msgid "Format Partition"
+msgstr "格式化分割區"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4547
+#, javascript-format
+msgid "This will erase all data on /dev/%s"
+msgstr "這會刪除 /dev/%s 上的所有資料"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4585
+msgid "Please select a filesystem"
+msgstr "請選擇檔案系統"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4591
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4619
+msgid "Selected filesystem is not supported on this system"
+msgstr "此系統不支援選中檔案系統"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4603
+msgid "Failed to detect supported filesystems"
+msgstr "檢測支援檔案系統失敗"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4634
+msgid "Formatting partition..."
+msgstr "正在格式化分割區…"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4635
+msgid "Partition formatted successfully"
+msgstr "成功格式化分割區"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4636
+msgid "Failed to format partition"
+msgstr "格式化分割區失敗"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4639
+msgid "Failed to start formatting"
+msgstr "開始格式化失敗"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4653
+msgid "Please enable wipe mode first"
+msgstr "請先啟用模除模式"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4661
+msgid ""
+"Cannot wipe disk with mounted partitions. Please unmount all partitions "
+"first."
+msgstr "無法抹除有掛載中分割區的磁碟機，請先卸載所有分割區。"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4665
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4687
+msgid "Wipe Disk"
+msgstr "擦除磁盘"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4670
+#, javascript-format
+msgid "This will completely erase the partition table and all data on /dev/%s!"
+msgstr "這會完全抹除 /dev/%s 上的分割區列表與其中資料！"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4673
+msgid "THIS OPERATION CANNOT BE UNDONE!"
+msgstr "這 個 操 作 無 法 撤 銷 ！"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4675
+#, javascript-format
+msgid "Number of partitions to be deleted: %d"
+msgstr "將會刪除的分割區數量：%d"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4676
+msgid "Are you absolutely sure you want to continue?"
+msgstr "您真的非常確定要繼續嗎？"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4704
+msgid "Wiping disk partition table..."
+msgstr "正在抹除磁碟機分割區列表…"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4705
+msgid "Disk partition table has been successfully erased"
+msgstr "磁碟機分割區表已被成功抹除"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4706
+msgid "Failed to wipe disk"
+msgstr "抹除磁碟機失敗"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4709
+msgid "Failed to start disk wipe"
+msgstr "開始磁碟機抹除失敗"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4735
+msgid ""
+"Selected partition cannot be resized. Only unmounted Ext2/3/4 partitions "
+"with available space can be resized."
+msgstr ""
+"無法調整選中的分割區，只能調整未掛載且尚有剩餘可用空間的 ext2/3/4 檔案系統分"
+"割區。"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4797
+msgid "Enter new size"
+msgstr "输入新大小"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4824
+msgid "Resize Partition"
+msgstr "調整分割區大小"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4829
+msgid "Resizing a partition can cause data loss if not done correctly."
+msgstr "如果操作不當，調整分割區大小可能導致資料丟失。"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4831
+msgid "Please ensure you have a backup of important data before proceeding."
+msgstr "在繼續之前，請確保您已經備份了重要資料。"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4833
+#, javascript-format
+msgid "Resize partition /dev/%s"
+msgstr "調整分割區 /dev/%s 的大小"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4836
+msgid "New size"
+msgstr "新大小"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4841
+#, javascript-format
+msgid "Current size: %s MB / %s GB / %s TB"
+msgstr "目前大小：%s MB / %s GB / %s TB"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4847
+#, javascript-format
+msgid "Available space: %s MB / %s GB / %s TB"
+msgstr "可用空間：%s MB / %s GB / %s TB"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4853
+#, javascript-format
+msgid "Maximum size to be obtained: %s MB / %s GB / %s TB"
+msgstr "獲取的最大空間：%s MB / %s GB / %s TB"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4906
+msgid "New size must be larger than current size"
+msgstr "新大小必須超出目前大小"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4911
+msgid "New size exceeds available space"
+msgstr "新大小超出可用空間"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4918
+msgid "Resize"
+msgstr "調整大小"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4938
+msgid "Resizing partition..."
+msgstr "正在調整分割區大小…"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4939
+msgid "Partition resized successfully"
+msgstr "調整分割區大小成功"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4940
+msgid "Failed to resize partition"
+msgstr "調整分割區大小失敗"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4943
+msgid "Failed to start partition resize"
+msgstr "開始分割區調整大小失敗"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4962
+msgid "Cannot delete mounted partition. Please unmount first."
+msgstr "無法刪除已經掛載的分割區，請先將其卸載。"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4968
+msgid "Delete Partition"
+msgstr "刪除分割區"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4973
+#, javascript-format
+msgid "This will delete partition /dev/%s and all its data!"
+msgstr "這會刪除分割區 /dev/%s 以及其中的所有資料！"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:4975
+msgid "Are you sure you want to continue?"
+msgstr "您確定要繼續嗎？"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:5000
+msgid "Deleting partition..."
+msgstr "正在刪除分割區…"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:5001
+msgid "Partition deleted successfully"
+msgstr "成功刪除分割區"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:5002
+msgid "Failed to delete partition"
+msgstr "刪除分割區失敗"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:5005
+msgid "Failed to start partition deletion"
+msgstr "開始分割區刪除失敗"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:5029
+#, javascript-format
+msgid "Mounted to %s"
+msgstr "已掛載 %s"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:5032
+msgid "Failed to mount: "
+msgstr "掛載失敗："
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:5047
+msgid "Selected partition is not mounted"
+msgstr "選中的分割區未掛載"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:5053
+#, javascript-format
+msgid "Unmounted %s"
+msgstr "已卸載 %s"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:5056
+msgid "Failed to unmount: "
+msgstr "卸載失敗："
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:5082
+msgid "Loading disk information..."
+msgstr "正在載入磁碟機資訊…"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:5099
+msgid "Mount Status"
+msgstr "掛載狀態"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:5102
+msgid "Mounted"
+msgstr "已掛載"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:5102
+msgid "Not mounted"
+msgstr "未掛載"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:5123
+msgid "Partition Layout"
+msgstr "分割區佈局"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:5133
+msgid "Partitions"
+msgstr "分割區"
+
+#: htdocs/luci-static/resources/view/minidiskmanager.js:5143
+msgid "Error loading disk information: "
+msgstr "載入磁碟機資訊時發生錯誤："
+
+#~ msgid "-- Select a disk --"
+#~ msgstr "-- 選擇磁碟機 --"
+
+#~ msgid "S.M.A.R.T."
+#~ msgstr "S.M.A.R.T."
+
+#~ msgid "No partitions found"
+#~ msgstr "沒有找到分割區"
+
+#~ msgid "Use all available space"
+#~ msgstr "使用所有可用空間"
+
+#~ msgid "No partitions to mount"
+#~ msgstr "沒有可供掛載的分割區"
+
+#~ msgid "No mounted partitions found"
+#~ msgstr "未找到已掛載的分割區"
+
+#~ msgid "No partitions to unmount"
+#~ msgstr "沒有可卸載的分割區"
+
+#~ msgid ""
+#~ "Partition created but device node did not appear; please refresh manually"
+#~ msgstr "分割區已經建立，但設備節點未在時限內出現，請手動更新"
+
+#~ msgid "Cannot create partition on mounted disk. Please unmount first."
+#~ msgstr "無法在已經掛載的磁碟機上建立分割區，請先將其卸載。"
+
+#~ msgid "Cannot delete partition on mounted disk. Please unmount first."
+#~ msgstr "無法刪除已經掛載磁碟上的分割區，請先將其卸載。"
+
+#~ msgid "Linux Filesystem Packages"
+#~ msgstr "Linux 檔案系統套件"
+
+#~ msgid "Windows Filesystem Packages"
+#~ msgstr "Windows 檔案系統套件"
+
+#~ msgid "Disk Manager Log"
+#~ msgstr "檔案管理器日誌"
+
+#~ msgid "Log file content"
+#~ msgstr "日誌檔案內容"
+
+#~ msgid "Failed to load package data"
+#~ msgstr "載入套件資料失敗"
+
+#~ msgid "Failed to create partition: "
+#~ msgstr "创建分区失败："
+
+#~ msgid "Failed to format partition: "
+#~ msgstr "格式化分区失败："
+
+#~ msgid "Failed to parse JSON response: "
+#~ msgstr "解析 JSON 响应失败："
+
+#~ msgid "Maximum new size"
+#~ msgstr "最大新大小"
+
+#~ msgid "Failed to resize partition: "
+#~ msgstr "调整分区大小失败："
+
+#~ msgid "Expand Ext2/Ext3/Ext4"
+#~ msgstr "扩展 Ext2/Ext3/Ext4"
+
+#~ msgid "All partitions will be deleted and the disk will be unallocated."
+#~ msgstr "所有分区将被删除，磁盘将变为未分配状态。"
+
+#~ msgid "Failed to wipe disk: "
+#~ msgstr "擦除磁盘失败："
+
+#~ msgid "Disk Wipe (dd command)"
+#~ msgstr "磁盘擦除（dd 命令）"
+
+# Reserved space
+
+msgid "Reserved space"
+msgstr "預留空間"
+
+msgid "Space reserved for root (default: 5%)"
+msgstr "為 root 預留的空間（預設：5%）"
+
+msgid "Used Reserved Block Count Total"
+msgstr "已用預留區塊總數"
+
+msgid "Used Reserved Block Count Chip"
+msgstr "晶片已用預留區塊數"
+
+msgid "Unused Reserved Block Count Total"
+msgstr "未用預留區塊總數"
+
+msgid "Available Reserved Space"
+msgstr "可用預留空間"
+
+# NVMe
+
+msgid "Critical Warning"
+msgstr "嚴重警告"
+
+msgid "Percentage Used"
+msgstr "使用百分比"
+
+msgid "Data Units Read"
+msgstr "讀取資料單元"
+
+msgid "Data Units Written"
+msgstr "寫入資料單元"
+
+msgid "Host Read Commands"
+msgstr "主機讀取命令"
+
+msgid "Host Write Commands"
+msgstr "主機寫入命令"
+
+msgid "Controller Busy Time"
+msgstr "控制器忙碌時間"
+
+msgid "Power Cycles"
+msgstr "電源循環"
+
+msgid "Unsafe Shutdowns"
+msgstr "非安全關機"
+
+msgid "Media Errors"
+msgstr "媒體錯誤"
+
+msgid "Error Log Entries"
+msgstr "錯誤日誌條目"
diff --git a/package/luci-app-mini-diskmanager/root/etc/config/mdmconfig b/package/luci-app-mini-diskmanager/root/etc/config/mdmconfig
new file mode 100644
index 0000000000..4836d72c42
--- /dev/null
+++ b/package/luci-app-mini-diskmanager/root/etc/config/mdmconfig
@@ -0,0 +1,2 @@
+config filesystem 'config'
+	option enabled '1'
\ No newline at end of file
diff --git a/package/luci-app-mini-diskmanager/root/etc/uci-defaults/setup_prm.sh b/package/luci-app-mini-diskmanager/root/etc/uci-defaults/setup_prm.sh
new file mode 100644
index 0000000000..23c0bd5824
--- /dev/null
+++ b/package/luci-app-mini-diskmanager/root/etc/uci-defaults/setup_prm.sh
@@ -0,0 +1,11 @@
+#!/bin/sh
+# Copyright 2025-2026 Rafał Wabik (IceG) - From eko.one.pl forum
+# Licensed MIT
+
+chmod +x /usr/libexec/rpcd/minidiskmanager >/dev/null 2>&1 &
+
+rm -rf /tmp/luci-indexcache >/dev/null 2>&1 &
+rm -rf /tmp/luci-* >/dev/null 2>&1 &
+rm -rf /tmp/luci-modulecache/ >/dev/null 2>&1 &
+
+exit 0
diff --git a/package/luci-app-mini-diskmanager/root/usr/libexec/rpcd/minidiskmanager b/package/luci-app-mini-diskmanager/root/usr/libexec/rpcd/minidiskmanager
new file mode 100644
index 0000000000..651705f6bc
--- /dev/null
+++ b/package/luci-app-mini-diskmanager/root/usr/libexec/rpcd/minidiskmanager
@@ -0,0 +1,1313 @@
+#!/bin/sh
+
+. /usr/share/libubox/jshn.sh
+
+##################################################################################################################
+#
+#  Copyright 2025-2026 Rafał Wabik - IceG - From eko.one.pl forum
+#  
+#  MIT License
+#  
+##################################################################################################################
+
+LOG_FILE="/tmp/mini-diskmanager.log"
+PID_FILE="/tmp/mini-diskmanager.pid"
+RESULT_FILE="/tmp/mini-diskmanager.result"
+
+##################################################################################################################
+# LOG
+##################################################################################################################
+log_msg() {
+    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
+}
+
+##################################################################################################################
+# MOUNT DETECTION / WYKRYWANIE MONTOWANIA
+##################################################################################################################
+is_device_mounted() {
+    device="$1"
+    grep -q "^${device} " /proc/mounts 2>/dev/null
+    return $?
+}
+
+##################################################################################################################
+# PARTITION SUFFIX DETECTOR / DETEKTOR SUFIKSU PARTYCJI
+##################################################################################################################
+part_suffix() {
+    dev="$1"
+    case "$(basename "$dev")" in
+        *[0-9]) echo "p" ;;
+        *) echo "" ;;
+    esac
+}
+
+##################################################################################################################
+# PARSE PARTITION NAME / PARSOWANIE NAZWY PARTYCJI
+# Extracts device and partition number / Wyodrębnia urządzenie i numer partycji
+# Examples / Przykłady:
+#   /dev/sda1 -> DEVICE=/dev/sda NUM=1
+#   /dev/sataa3 -> DEVICE=/dev/sataa NUM=3
+#   /dev/md1p2 -> DEVICE=/dev/md1 NUM=2
+#   /dev/mmcblk0p3 -> DEVICE=/dev/mmcblk0 NUM=3
+#   /dev/nvme0n1p1 -> DEVICE=/dev/nvme0n1 NUM=1
+#   /dev/sda -> DEVICE=/dev/sda NUM=1 (disk without partition table)
+##################################################################################################################
+parse_partition_name() {
+    partition="$1"
+    NUM=""
+    BNAME=$(basename "$partition")
+    
+    log_msg "DEBUG: Parsing partition name: $partition (basename: $BNAME)"
+    
+    if [ "$BNAME" != "${BNAME#sd?}" ]; then
+        if [ -z "${BNAME#sd?}" ]; then
+            DEVICE="/dev/$BNAME"
+            NUM="1"
+            log_msg "DEBUG: Detected sd* disk without partition: DEVICE=$DEVICE NUM=$NUM"
+        else
+            DEVICE="/dev/${BNAME:0:3}"
+            NUM="${BNAME#sd?}"
+            log_msg "DEBUG: Detected sd* partition: DEVICE=$DEVICE NUM=$NUM"
+        fi
+    elif [ "$BNAME" != "${BNAME#sata?}" ]; then
+        if [ -z "${BNAME#sata?}" ]; then
+            DEVICE="/dev/$BNAME"
+            NUM="1"
+            log_msg "DEBUG: Detected sata* disk without partition: DEVICE=$DEVICE NUM=$NUM"
+        else
+            DEVICE="/dev/${BNAME:0:5}"
+            NUM="${BNAME#sata?}"
+            log_msg "DEBUG: Detected sata* partition: DEVICE=$DEVICE NUM=$NUM"
+        fi
+    elif [ "$BNAME" != "${BNAME#md?}" ]; then
+        if echo "$BNAME" | grep -q 'p[0-9]*$'; then
+            DEVICE="/dev/${BNAME%%p*}"
+            NUM="${BNAME##*p}"
+            log_msg "DEBUG: Detected md* with p separator: DEVICE=$DEVICE NUM=$NUM"
+        elif [ -z "${BNAME#md?}" ]; then
+            DEVICE="/dev/$BNAME"
+            NUM="1"
+            log_msg "DEBUG: Detected md* disk without partition: DEVICE=$DEVICE NUM=$NUM"
+        else
+            DEVICE="/dev/${BNAME:0:3}"
+            NUM="${BNAME#md?}"
+            log_msg "DEBUG: Detected md* partition: DEVICE=$DEVICE NUM=$NUM"
+        fi
+    elif [ "$BNAME" != "${BNAME#mmcblk?}" ]; then
+        if echo "$BNAME" | grep -q 'p[0-9]*$'; then
+            DEVICE="/dev/${BNAME%%p*}"
+            NUM="${BNAME##*p}"
+            log_msg "DEBUG: Detected mmcblk* partition: DEVICE=$DEVICE NUM=$NUM"
+        else
+            DEVICE="/dev/$BNAME"
+            NUM="1"
+            log_msg "DEBUG: Detected mmcblk* disk without partition: DEVICE=$DEVICE NUM=$NUM"
+        fi
+    elif [ "$BNAME" != "${BNAME#nvme?n?}" ]; then
+        if echo "$BNAME" | grep -q 'p[0-9]*$'; then
+            DEVICE="/dev/${BNAME%%p*}"
+            NUM="${BNAME##*p}"
+            log_msg "DEBUG: Detected nvme* partition: DEVICE=$DEVICE NUM=$NUM"
+        else
+            DEVICE="/dev/$BNAME"
+            NUM="1"
+            log_msg "DEBUG: Detected nvme* disk without partition: DEVICE=$DEVICE NUM=$NUM"
+        fi
+    else
+        log_msg "ERROR: $partition is invalid - unsupported device type (BŁĄD: $partition jest niepoprawny - nieobsługiwany typ urządzenia)"
+        return 1
+    fi
+    
+    export DEVICE NUM
+    log_msg "DEBUG: Final parse result - DEVICE=$DEVICE NUM=$NUM"
+    return 0
+}
+
+##################################################################################################################
+# CHECK TARGET PATH / SPRAWDZANIE ŚCIEŻKI DOCELOWEJ
+##################################################################################################################
+check_target_path() {
+    target="$1"
+    
+    if [ ! -b "$target" ]; then
+        log_msg "ERROR: $target does not exist (BŁĄD: $target nie istnieje)"
+        echo "1" > "$RESULT_FILE"
+        return 1
+    fi
+    log_msg "DEBUG: $target exists ($target istnieje)"
+    
+    BNAME=$(basename "$target")
+    
+    if [ "$BNAME" != "${BNAME#sd?}" ]; then
+        log_msg "DEBUG: $target is valid (sd* device) ($target jest poprawny - urządzenie sd*)"
+    elif [ "$BNAME" != "${BNAME#sata?}" ]; then
+        log_msg "DEBUG: $target is valid (sata* device) ($target jest poprawny - urządzenie sata*)"
+    elif [ "$BNAME" != "${BNAME#md?}" ]; then
+        log_msg "DEBUG: $target is valid (md* device) ($target jest poprawny - urządzenie md*)"
+    elif [ "$BNAME" != "${BNAME#mmcblk?}" ]; then
+        if [ "$BNAME" != "${BNAME#mmcblk0*}" ]; then
+            log_msg "ERROR: $target is invalid (mmcblk0 protected) (BŁĄD: $target jest niepoprawny - mmcblk0 jest chroniony)"
+            echo "1" > "$RESULT_FILE"
+            return 1
+        fi
+        log_msg "DEBUG: $target is valid (mmcblk* device) ($target jest poprawny - urządzenie mmcblk*)"
+    elif [ "$BNAME" != "${BNAME#nvme?n?}" ]; then
+        log_msg "DEBUG: $target is valid (nvme* device) ($target jest poprawny - urządzenie nvme*)"
+    else
+        log_msg "ERROR: $target is invalid (unsupported device type) (BŁĄD: $target jest niepoprawny - nieobsługiwany typ urządzenia)"
+        echo "1" > "$RESULT_FILE"
+        return 1
+    fi
+    
+    log_msg "DEBUG: $target validation passed ($target przeszedł walidację)"
+    return 0
+}
+
+##################################################################################################################
+# UNMOUNTING PARTITIONS / ODMONTOWYWANIE PARTYCJI
+##################################################################################################################
+unmount_device() {
+    device="$1"
+    log_msg "Unmounting partitions for $device (Odmontowywanie partycji dla $device)"
+
+    suffix=$(part_suffix "$device")
+
+    if [ -n "$suffix" ]; then
+        pattern="${device}${suffix}[0-9]*"
+    else
+        pattern="${device}[0-9]*"
+    fi
+
+    for part in $pattern; do
+        if [ -b "$part" ] && [ "$part" != "$device" ]; then
+            if is_device_mounted "$part"; then
+                log_msg "Unmounting $part (Odmontowywanie $part)"
+                umount -l "$part" >> "$LOG_FILE" 2>&1 || umount -f "$part" >> "$LOG_FILE" 2>&1
+                sleep 1
+            fi
+        fi
+    done
+
+    grep "^$device" /proc/mounts | while read dev mp rest; do
+        log_msg "Force unmounting $dev from $mp (Wymuszanie odmontowania $dev z $mp)"
+        umount -l "$dev" >> "$LOG_FILE" 2>&1 || umount -f "$dev" >> "$LOG_FILE" 2>&1
+        sleep 1
+    done
+}
+
+##################################################################################################################
+# KERNEL PARTITION TABLE REFRESH / ODŚWIEŻANIE TABLICY PARTYCJI
+##################################################################################################################
+refresh_partitions() {
+    device="$1"
+    log_msg "Refreshing partition table for $device (Odświeżanie tablicy partycji dla $device)"
+
+    if command -v blockdev >/dev/null 2>&1; then
+        blockdev --rereadpt "$device" >> "$LOG_FILE" 2>&1 || true
+    fi
+
+    if command -v partprobe >/dev/null 2>&1; then
+        partprobe "$device" >> "$LOG_FILE" 2>&1 || true
+    fi
+
+    base_name=$(basename "$device")
+    if [ -w "/sys/block/$base_name/device/rescan" ]; then
+        echo 1 > "/sys/block/$base_name/device/rescan" 2>/dev/null || true
+    fi
+
+    sleep 1
+}
+
+##################################################################################################################
+# WAIT FOR BLOCK DEVICE / OCZEKIWANIE NA URZĄDZENIE
+##################################################################################################################
+wait_for_partition() {
+    partition="$1"
+    max_wait=${2:-10}
+    count=0
+
+    log_msg "Waiting for $partition to appear... (Oczekiwanie na pojawienie się $partition...)"
+
+    while [ $count -lt $max_wait ]; do
+        if [ -b "$partition" ]; then
+            log_msg "Partition $partition appeared (Partycja $partition pojawiła się)"
+            return 0
+        fi
+        sleep 1
+        count=$((count + 1))
+    done
+
+    log_msg "Timeout waiting for $partition (Przekroczono czas oczekiwania na $partition)"
+    return 1
+}
+
+##################################################################################################################
+# GET LAST PARTITION NUMBER / POBIERZ NUMER OSTATNIEJ PARTYCJI
+##################################################################################################################
+get_last_partition_number() {
+    device="$1"
+    /sbin/parted -s -m "$device" print 2>/dev/null | awk -F: '/^[0-9]+:/ {x=$1} END{print x}'
+}
+
+##################################################################################################################
+# CHECK IF DISK HAS PARTITIONS / SPRAWDŹ CZY DYSK MA PARTYCJE
+##################################################################################################################
+disk_has_partitions() {
+    device="$1"
+    count=$(/sbin/parted -s -m "$device" print 2>/dev/null | awk -F: '/^[0-9]+:/ {count++} END{print count+0}')
+    [ "$count" -gt 0 ]
+    return $?
+}
+
+##################################################################################################################
+# FIND FREE SPACE REGION ON DISK / ZNAJDŹ WOLNĄ PRZESTRZEŃ NA DYSKU
+##################################################################################################################
+find_free_space() {
+    device="$1"
+    
+    log_msg "DEBUG: Searching for free space on $device (Szukanie wolnej przestrzeni na $device)"
+ 
+    free=$(/sbin/parted -s -m "$device" unit s print free 2>/dev/null | grep "free;")
+    
+    log_msg "DEBUG: Free regions found (Znalezione wolne regiony: $free)"
+    
+    result=$(echo "$free" | awk -F: '
+        BEGIN {
+            max = 0
+            best_start = ""
+            best_end = ""
+        }
+        /free/ {
+            start=$2; end=$3; size=$4
+            gsub("s","",start); gsub("s","",end); gsub("s","",size)
+            
+            start = start + 0
+            end = end + 0
+            size = size + 0
+            
+            if (size < 2048) {
+                next
+            }
+            
+            if (size > max) { 
+                max = size
+                best_start = start
+                best_end = end
+            }
+        }
+        END { 
+            if (max > 0) {
+                printf "%s:%s:%s", best_start, best_end, max
+            }
+        }
+    ')
+    
+    log_msg "DEBUG: find_free_space result (Wynik find_free_space: '$result')"
+    echo "$result"
+}
+
+##################################################################################################################
+# PARTED ALWAYS NON-INTERACTIVE / PARTED ZAWSZE NIE-INTERAKTYWNY
+##################################################################################################################
+parted_cmd() {
+    /sbin/parted -s -- "$@"
+}
+
+##################################################################################################################
+# MAP FILESYSTEM TYPE FOR PARTED / MAPOWANIE TYPU SYSTEMU PLIKÓW DLA PARTED
+# Parted uses different names than mkfs
+# Parted używa innych nazw niż mkfs
+##################################################################################################################
+map_fstype_for_parted() {
+    fstype="$1"
+    case "$fstype" in
+        vfat|fat32) echo "fat32" ;;
+        fat16) echo "fat16" ;;
+        exfat) echo "fat32" ;;  # exfat not supported by parted
+        swap) echo "linux-swap" ;;
+        ext2|ext3|ext4|ntfs|hfs|hfs+|hfsx) echo "$fstype" ;;
+        *) echo "ext2" ;;
+    esac
+}
+
+##################################################################################################################
+# ZERO OUT PARTITION OR DISK START / WYZERUJ POCZĄTEK PARTYCJI LUB DYSKU
+##################################################################################################################
+zero_device_start() {
+    target="$1"
+    size_kb="${2:-10240}"  # default 10MB / domyślnie 10MB
+    
+    log_msg "Zeroing first ${size_kb}KB of $target (Zerowanie pierwszych ${size_kb}KB z $target)"
+    
+    if [ ! -b "$target" ]; then
+        log_msg "Device $target not found, skipping zero (Urządzenie $target nie znalezione, pomijanie zerowania)"
+        return 0
+    fi
+    
+    actual_size=$(grep "$(basename "$target")$" /proc/partitions 2>/dev/null | awk '{print $3}')
+    
+    if [ -n "$actual_size" ] && [ "$actual_size" -gt 0 ]; then
+        if [ "$actual_size" -lt "$size_kb" ]; then
+            dd if=/dev/zero of="$target" bs=1K count="$actual_size" >> "$LOG_FILE" 2>&1 || true
+        else
+            dd if=/dev/zero of="$target" bs=1M count=10 >> "$LOG_FILE" 2>&1 || true
+        fi
+    else
+        dd if=/dev/zero of="$target" bs=1M count=10 >> "$LOG_FILE" 2>&1 || true
+    fi
+    
+    sync
+    sleep 1
+}
+
+##################################################################################################################
+# CREATE PARTITION / TWORZENIE PARTYCJI
+##################################################################################################################
+# Arguments / Argumenty:
+#   $1 - disk: base disk device / urządzenie bazowe dysku (np. /dev/sda, /dev/nvme0n1)
+#   $2 - type: partition type / typ partycji (primary | extended | logical)
+#   $3 - fstype: placeholder for filesystem type / placeholder dla typu systemu plików (np. ext2, ext4)
+#   $4 - size_param: size / rozmiar ('123MB' / '1GB' / '100%' / '1114656768s')
+#   $5 - layout: partitioning scheme / schemat partycjonowania ('gpt' lub 'msdos')
+#   $6 - label: optional label / opcjonalna etykieta
+#   $7 - reserved_space: optional reserved space value / opcjonalna wartość zarezerwowanego miejsca
+#   $8 - reserved_unit: optional reserved space unit / opcjonalna jednostka zarezerwowanego miejsca (%, MB, GB, TB)
+##################################################################################################################
+create_partition_impl() {
+    disk="$1"       # Base device / Urządzenie bazowe: /dev/sda lub /dev/nvme0n1
+    type="$2"       # primary | extended | logical
+    fstype="$3"     # placeholder FS type / typ systemu plików (np. ext2)
+    size_param="$4" # number in MB or / liczba MB lub '123MB' / '1GB' / '100%' / '1114656768s'
+    layout="$5"     # 'gpt' or 'msdos' (msdos = mbr)
+    label="$6"      # optional label / opcjonalna etykieta
+    reserved_space="$7"  # optional reserved space value / opcjonalna wartość zarezerwowanego miejsca
+    reserved_unit="$8"   # optional reserved space unit / opcjonalna jednostka (%, MB, GB, TB)
+
+    log_msg "=== Creating partition on $disk (Tworzenie partycji na $disk) ==="
+    log_msg "CREATE PARTITION PARAMETERS (PARAMETRY TWORZENIA PARTYCJI):"
+    log_msg "  - Disk (Dysk): $disk"
+    log_msg "  - Partition type (Typ partycji): $type"
+    log_msg "  - Filesystem type (Typ systemu plików): $fstype"
+    log_msg "  - Partition size (Rozmiar partycji): $size_param"
+    log_msg "  - Partition layout (Układ partycji): $layout"
+    log_msg "  - Label (Etykieta): ${label:-<none/brak>}"
+    log_msg "  - Reserved space value (Wartość zarezerwowanego miejsca): ${reserved_space:-<not set/nie ustawiono>}"
+    log_msg "  - Reserved space unit (Jednostka zarezerwowanego miejsca): ${reserved_unit:-<not set/nie ustawiono>}"
+
+    if [ ! -b "$disk" ]; then
+        log_msg "Device $disk not found! (Urządzenie $disk nie znalezione!)"
+        echo 1 > "$RESULT_FILE"
+        return 1
+    fi
+
+    parted_out=$(/sbin/parted -s "$disk" print 2>&1 || true)
+    if echo "$parted_out" | grep -qi "unrecognised disk label\|unrecognized disk label"; then
+        log_msg "Disk has no partition table, creating $layout (Dysk nie ma tablicy partycji, tworzenie $layout)"
+        label_type="msdos"
+        [ "$layout" = "gpt" ] && label_type="gpt"
+        parted_cmd "$disk" mklabel "$label_type" >> "$LOG_FILE" 2>&1
+        rc=$?
+        if [ $rc -ne 0 ]; then
+            log_msg "Failed to create partition table (rc=$rc) (Nie udało się utworzyć tablicy partycji (rc=$rc))"
+            echo $rc > "$RESULT_FILE"
+            return $rc
+        fi
+        log_msg "Partition table $label_type created successfully (Tablica partycji $label_type utworzona pomyślnie)"
+        refresh_partitions "$disk"
+        parted_out=$(/sbin/parted -s "$disk" print 2>&1 || true)
+    elif ! echo "$parted_out" | grep -q "Partition Table:"; then
+        log_msg "No partition table found, creating $layout (Nie znaleziono tablicy partycji, tworzenie $layout)"
+        label_type="msdos"
+        [ "$layout" = "gpt" ] && label_type="gpt"
+        parted_cmd "$disk" mklabel "$label_type" >> "$LOG_FILE" 2>&1
+        rc=$?
+        if [ $rc -ne 0 ]; then
+            log_msg "Failed to create partition table (rc=$rc) (Nie udało się utworzyć tablicy partycji (rc=$rc))"
+            echo $rc > "$RESULT_FILE"
+            return $rc
+        fi
+        log_msg "Partition table $label_type created successfully (Tablica partycji $label_type utworzona pomyślnie)"
+        refresh_partitions "$disk"
+        parted_out=$(/sbin/parted -s "$disk" print 2>&1 || true)
+    fi
+
+    free_space=$(find_free_space "$disk")
+    
+    log_msg "DEBUG: free_space variable value (Wartość zmiennej free_space): '$free_space'"
+    
+    if [ -n "$free_space" ]; then
+        free_start=$(echo "$free_space" | cut -d: -f1)
+        free_end=$(echo "$free_space" | cut -d: -f2)
+        free_size=$(echo "$free_space" | cut -d: -f3)
+        
+        if [ -n "$free_start" ] && [ -n "$free_end" ] && [ "$free_start" -lt "$free_end" ] 2>/dev/null; then
+            log_msg "Found free region (Znaleziono wolny region): ${free_start}s - ${free_end}s (size/rozmiar: ${free_size}s)"
+            
+            if [ "$free_start" -lt 2048 ]; then
+                free_start=2048
+                log_msg "Adjusted free_start to 2048s for proper alignment (Dostosowano free_start do 2048s dla prawidłowego wyrównania)"
+            else
+                remainder=$((free_start % 2048))
+                if [ $remainder -ne 0 ]; then
+                    free_start=$((free_start + 2048 - remainder))
+                    log_msg "Adjusted free_start to ${free_start}s for proper alignment (Dostosowano free_start do ${free_start}s dla wyrównania)"
+                fi
+            fi
+            
+            if [ "$free_start" -ge "$free_end" ]; then
+                log_msg "ERROR: No space left after alignment (BŁĄD: Brak miejsca po wyrównaniu)"
+                echo 1 > "$RESULT_FILE"
+                return 1
+            fi
+        else
+            log_msg "Invalid free space values, will use fallback (Nieprawidłowe wartości wolnej przestrzeni, użyje fallback)"
+            free_space=""
+        fi
+    fi
+    
+    if [ -z "$free_space" ]; then
+        log_msg "No free space found by parted, calculating disk size manually (Nie znaleziono wolnej przestrzeni przez parted, ręczne obliczanie rozmiaru dysku)"
+        
+        total_sectors=$(blockdev --getsz "$disk" 2>/dev/null || true)
+        
+        if [ -z "$total_sectors" ] || [ "$total_sectors" = "0" ]; then
+            base_name=$(basename "$disk")
+            if [ -f "/sys/block/$base_name/size" ]; then
+                total_sectors=$(cat "/sys/block/$base_name/size" 2>/dev/null || true)
+            fi
+        fi
+        
+        if [ -z "$total_sectors" ] || [ "$total_sectors" = "0" ]; then
+            total_sectors=$(/sbin/parted -s -m "$disk" unit s print 2>/dev/null | awk -F: -v dev="$(basename "$disk")" '$1==dev{print $2}' | sed 's/s$//' || true)
+        fi
+        
+        if [ -z "$total_sectors" ] || [ "$total_sectors" = "0" ]; then
+            total_sectors=$(fdisk -l "$disk" 2>/dev/null | awk '/^Disk \/dev\// && /bytes/ {gsub(",","",$5); print int($5/512)}' | head -1 || true)
+        fi
+        
+        if [ -z "$total_sectors" ] || [ "$total_sectors" = "0" ]; then
+            log_msg "Cannot determine disk size (Nie można określić rozmiaru dysku)"
+            echo 1 > "$RESULT_FILE"
+            return 1
+        fi
+        
+        log_msg "Disk size determined (Określono rozmiar dysku: $total_sectors sectors/sektorów)"
+        
+        if [ "$layout" = "gpt" ]; then
+            free_start=2048
+            free_end=$((total_sectors - 34))
+        else
+            free_start=2048
+            free_end=$((total_sectors - 1))
+        fi
+        log_msg "Using default free area (Używanie domyślnego wolnego obszaru: ${free_start}s - ${free_end}s)"
+    fi
+
+    case "$size_param" in
+        *%|*s)
+            partition_end="$size_param"
+            ;;
+        *MB|*mb)
+            mb=$(echo "$size_param" | sed -E 's/[Mm][Bb]$//')
+            secs=$(( mb * 1024 * 1024 / 512 ))
+            partition_end="$(( free_start + secs ))s"
+            ;;
+        *GB|*gb)
+            gb=$(echo "$size_param" | sed -E 's/[Gg][Bb]$//')
+            secs=$(( gb * 1024 * 1024 * 1024 / 512 ))
+            partition_end="$(( free_start + secs ))s"
+            ;;
+        *)
+            if echo "$size_param" | grep -qE '^[0-9]+$'; then
+                mb=$size_param
+                secs=$(( mb * 1024 * 1024 / 512 ))
+                partition_end="$(( free_start + secs ))s"
+            else
+                partition_end="${free_end}s"
+            fi
+            ;;
+    esac
+
+    case "$partition_end" in
+        *s) ;;
+        *%) ;;
+        *) partition_end="${partition_end}s" ;;
+    esac
+
+    if echo "$partition_end" | grep -qE '^[0-9]+s$'; then
+        num_end=$(echo "$partition_end" | sed 's/s$//')
+        if [ -n "$free_end" ] && [ "$num_end" -gt "$free_end" ] 2>/dev/null; then
+            log_msg "Requested end $num_end > free_end $free_end, capping to free_end (Żądany koniec $num_end > free_end $free_end, ograniczanie do free_end)"
+            partition_end="${free_end}s"
+        fi
+    fi
+
+    log_msg "Creating partition type=$type from ${free_start}s to ${partition_end} (Tworzenie partycji type=$type od ${free_start}s do ${partition_end})"
+
+    if [ "$type" = "logical" ]; then
+        log_msg "Refreshing partition table before checking for extended (Odświeżanie tablicy partycji przed sprawdzeniem rozszerzonej)"
+        refresh_partitions "$disk"
+        sleep 1
+        
+        parted_machine=$(/sbin/parted -s -m "$disk" print 2>/dev/null || true)
+        parted_regular=$(/sbin/parted -s "$disk" print 2>/dev/null || true)
+        log_msg "DEBUG parted -m output: $parted_machine"
+        log_msg "DEBUG parted regular output (grep extended): $(echo "$parted_regular" | grep -i extended || echo 'NO MATCH')"
+        
+        ext_exists=""
+
+        ext_exists=$(/sbin/parted -s -m "$disk" print 2>/dev/null | awk -F: '/^[0-9]+:/ && tolower($5) ~ /extended/ {print $1}' | head -1 || true)
+        log_msg "DEBUG Method 1 (col 5): ext_exists='$ext_exists'"
+        
+        if [ -z "$ext_exists" ]; then
+            ext_exists=$(/sbin/parted -s -m "$disk" print 2>/dev/null | awk -F: '/^[0-9]+:/ && tolower($6) ~ /extended/ {print $1}' | head -1 || true)
+            log_msg "DEBUG Method 2 (col 6): ext_exists='$ext_exists'"
+        fi
+        
+        if [ -z "$ext_exists" ]; then
+            ext_exists=$(/sbin/parted -s "$disk" print 2>/dev/null | awk '/[Ee]xtended/ {print $1}' | head -1 || true)
+            log_msg "DEBUG Method 3 (regular): ext_exists='$ext_exists'"
+        fi
+        
+        log_msg "Extended partition check FINAL (Sprawdzenie partycji rozszerzonej FINALNE): ext_exists='$ext_exists'"
+        
+        if [ -n "$ext_exists" ]; then
+            log_msg "Extended partition $ext_exists already exists, will create logical inside it (Partycja rozszerzona $ext_exists już istnieje, utworzę logiczną wewnątrz)"
+            free_space=$(find_free_space "$disk")
+            if [ -n "$free_space" ]; then
+                free_start=$(echo "$free_space" | cut -d: -f1)
+                free_end=$(echo "$free_space" | cut -d: -f2)
+                
+                remainder=$((free_start % 2048))
+                if [ $remainder -ne 0 ]; then
+                    free_start=$((free_start + 2048 - remainder))
+                    log_msg "Adjusted logical free_start to ${free_start}s for alignment (Dostosowano logiczny free_start do ${free_start}s dla wyrównania)"
+                fi
+                
+                log_msg "Free space inside extended (Wolna przestrzeń wewnątrz rozszerzonej): ${free_start}s - ${free_end}s"
+                
+                if echo "$partition_end" | grep -qE '^[0-9]+s$'; then
+                    num_end=$(echo "$partition_end" | sed 's/s$//')
+                    if [ -n "$free_end" ] && [ "$num_end" -gt "$free_end" ] 2>/dev/null; then
+                        log_msg "Requested end $num_end > free_end $free_end inside extended, capping (Żądany koniec $num_end > free_end $free_end wewnątrz rozszerzonej, ograniczanie)"
+                        partition_end="${free_end}s"
+                    fi
+                fi
+            else
+                log_msg "ERROR: No free space found inside extended partition (BŁĄD: Nie znaleziono wolnej przestrzeni wewnątrz partycji rozszerzonej)"
+                echo 1 > "$RESULT_FILE"
+                return 1
+            fi
+        else
+            log_msg "No extended partition found — creating extended from ${free_start}s to ${free_end}s (Nie znaleziono partycji rozszerzonej — tworzenie rozszerzonej od ${free_start}s do ${free_end}s)"
+            parted_cmd "$disk" mkpart extended "${free_start}s" "${free_end}s" >> "$LOG_FILE" 2>&1
+            rc=$?
+            if [ $rc -ne 0 ]; then
+                log_msg "Failed to create extended partition (rc=$rc) (Nie udało się utworzyć partycji rozszerzonej (rc=$rc))"
+                echo $rc > "$RESULT_FILE"
+                refresh_partitions "$disk"
+                return $rc
+            fi
+            refresh_partitions "$disk"
+            free_space=$(find_free_space "$disk")
+            if [ -n "$free_space" ]; then
+                free_start=$(echo "$free_space" | cut -d: -f1)
+                free_end=$(echo "$free_space" | cut -d: -f2)
+                
+                remainder=$((free_start % 2048))
+                if [ $remainder -ne 0 ]; then
+                    free_start=$((free_start + 2048 - remainder))
+                    log_msg "Adjusted logical free_start to ${free_start}s for alignment (Dostosowano logiczny free_start do ${free_start}s dla wyrównania)"
+                fi
+                
+                log_msg "After extended (Po rozszerzonej): free region / wolny region ${free_start}s - ${free_end}s"
+            fi
+        fi
+        parted_fstype=$(map_fstype_for_parted "$fstype")
+        log_msg "Creating logical partition (Tworzenie partycji logicznej): parted $disk mkpart logical $parted_fstype ${free_start}s ${partition_end}"
+        parted_cmd "$disk" mkpart logical "$parted_fstype" "${free_start}s" "${partition_end}" >> "$LOG_FILE" 2>&1
+        rc=$?
+    else
+        case "$type" in
+            extended)
+                parted_cmd "$disk" mkpart extended "${free_start}s" "${partition_end}" >> "$LOG_FILE" 2>&1
+                rc=$?
+                ;;
+            primary|p|primary)
+                parted_fstype=$(map_fstype_for_parted "$fstype")
+                log_msg "Creating primary partition with fstype (Tworzenie partycji primary z fstype): $parted_fstype (original: $fstype)"
+                parted_cmd "$disk" mkpart primary "$parted_fstype" "${free_start}s" "${partition_end}" >> "$LOG_FILE" 2>&1
+                rc=$?
+                ;;
+            *)
+                parted_fstype=$(map_fstype_for_parted "$fstype")
+                log_msg "Creating default primary partition with fstype (Tworzenie domyślnej partycji primary z fstype): $parted_fstype (original: $fstype)"
+                parted_cmd "$disk" mkpart primary "$parted_fstype" "${free_start}s" "${partition_end}" >> "$LOG_FILE" 2>&1
+                rc=$?
+                ;;
+        esac
+    fi
+
+    echo $rc > "$RESULT_FILE"
+    if [ $rc -ne 0 ]; then
+        log_msg "Failed to create partition (rc=$rc) (Nie udało się utworzyć partycji (rc=$rc))"
+        refresh_partitions "$disk"
+        return $rc
+    fi
+
+    refresh_partitions "$disk"
+    sleep 1
+    last_part_num=$(get_last_partition_number "$disk" || true)
+    if [ -n "$last_part_num" ]; then
+        log_msg "Created partition number (Utworzono partycję numer): $last_part_num"
+        log_msg "Partition creation completed successfully (Tworzenie partycji zakończone pomyślnie)"
+        log_msg "Summary: Type=$type, FS=$fstype, Size=$size_param, Label=${label:-<none>}, Reserved=${reserved_space:-0}${reserved_unit:-%}"
+    else
+        log_msg "WARNING: Could not determine partition number (OSTRZEŻENIE: Nie można określić numeru partycji)"
+    fi
+
+    /sbin/parted -s "$disk" print >> "$LOG_FILE" 2>&1 || true
+
+    return 0
+}
+
+##################################################################################################################
+# DELETE PARTITION / USUWANIE PARTYCJI
+##################################################################################################################
+delete_partition() {
+    partition_path="$1"
+
+    log_msg "=== Deleting partition (Usuwanie partycji): $partition_path ==="
+    log_msg "DELETE PARTITION PARAMETERS (PARAMETRY USUWANIA PARTYCJI):"
+    log_msg "  - Partition path (Ścieżka partycji): $partition_path"
+
+    if [ -z "$partition_path" ]; then
+        log_msg "ERROR: Missing partition path (BŁĄD: Brak ścieżki partycji)"
+        log_msg "Usage (Użycie): delete_partition <partition_path>"
+        log_msg "Example (Przykład): delete_partition /dev/sda1"
+        echo 1 > "$RESULT_FILE"
+        return 1
+    fi
+
+    if [ ! -b "$partition_path" ]; then
+        log_msg "ERROR: Partition $partition_path does not exist as block device (BŁĄD: Partycja $partition_path nie istnieje jako urządzenie blokowe)"
+        echo 1 > "$RESULT_FILE"
+        return 1
+    fi
+
+    DEVICE=""
+    NUM=""
+    BNAME=$(basename "$partition_path")
+    
+    log_msg "Parsing partition name (Parsowanie nazwy partycji): $BNAME"
+    
+    if [ "$BNAME" != "${BNAME#sd?}" ]; then
+        if [ -z "${BNAME#sd?}" ]; then
+            DEVICE="/dev/$BNAME"
+            NUM="1"
+        else
+            DEVICE="/dev/${BNAME:0:3}"
+            NUM="${BNAME#sd?}"
+        fi
+    elif [ "$BNAME" != "${BNAME#sata?}" ]; then
+        if [ -z "${BNAME#sata?}" ]; then
+            DEVICE="/dev/$BNAME"
+            NUM="1"
+        else
+            DEVICE="/dev/${BNAME:0:5}"
+            NUM="${BNAME#sata?}"
+        fi
+    elif [ "$BNAME" != "${BNAME#nvme}" ]; then
+        DEVICE="/dev/${BNAME%%p*}"
+        NUM="${BNAME##*p}"
+    elif [ "$BNAME" != "${BNAME#mmcblk?}" ]; then
+        DEVICE="/dev/${BNAME%%p*}"
+        NUM="${BNAME##*p}"
+    else
+        log_msg "ERROR: Unsupported device naming (BŁĄD: Nieobsługiwane nazewnictwo urządzenia): $partition_path"
+        echo 1 > "$RESULT_FILE"
+        return 1
+    fi
+
+    log_msg "Parsed (Sparsowano): DEVICE=$DEVICE NUM=$NUM"
+
+    if [ -z "$DEVICE" ] || [ -z "$NUM" ]; then
+        log_msg "ERROR: Failed to parse device and partition number (BŁĄD: Nie udało się sparsować urządzenia i numeru partycji)"
+        echo 1 > "$RESULT_FILE"
+        return 1
+    fi
+
+    if [ ! -b "$DEVICE" ]; then
+        log_msg "ERROR: Base device $DEVICE does not exist (BŁĄD: Urządzenie bazowe $DEVICE nie istnieje)"
+        echo 1 > "$RESULT_FILE"
+        return 1
+    fi
+
+    if ! /sbin/parted -s -m "$DEVICE" print 2>/dev/null | grep -q "^${NUM}:"; then
+        log_msg "ERROR: Partition $NUM does not exist on $DEVICE (BŁĄD: Partycja $NUM nie istnieje na $DEVICE)"
+        /sbin/parted -s "$DEVICE" print >> "$LOG_FILE" 2>&1 || true
+        echo 1 > "$RESULT_FILE"
+        return 1
+    fi
+
+    is_extended=""
+    
+    is_extended=$(/sbin/parted -s -m "$DEVICE" print 2>/dev/null | awk -F: -v num="$NUM" '$1==num && tolower($5) ~ /extended/ {print "yes"}' || true)
+    
+    if [ -z "$is_extended" ]; then
+        is_extended=$(/sbin/parted -s -m "$DEVICE" print 2>/dev/null | awk -F: -v num="$NUM" '$1==num && tolower($6) ~ /extended/ {print "yes"}' || true)
+    fi
+    
+    if [ -z "$is_extended" ]; then
+        is_extended=$(/sbin/parted -s "$DEVICE" print 2>/dev/null | awk -v num="$NUM" '$1==num && tolower($5) ~ /extended/ {print "yes"}' || true)
+    fi
+    
+    log_msg "Is extended partition (Czy partycja rozszerzona): '$is_extended'"
+
+    if is_device_mounted "$partition_path"; then
+        log_msg "Unmounting partition $partition_path before deletion (Odmontowywanie partycji $partition_path przed usunięciem)"
+        umount -l "$partition_path" >> "$LOG_FILE" 2>&1 || umount -f "$partition_path" >> "$LOG_FILE" 2>&1
+        sleep 1
+    fi
+
+    base_name=$(basename "$DEVICE")
+    if [ "${base_name#nvme}" != "$base_name" ] || [ "${base_name#mmcblk}" != "$base_name" ]; then
+        partition_to_zero="${DEVICE}p${NUM}"
+    else
+        partition_to_zero="${DEVICE}${NUM}"
+    fi
+
+    log_msg "Partition to zero (Partycja do wyzerowania): $partition_to_zero"
+
+    if [ "$is_extended" = "yes" ]; then
+        log_msg "SKIPPING zeroing for extended partition (contains only metadata) (POMIJANIE zerowania dla partycji rozszerzonej (zawiera tylko metadane))"
+    else
+        SIZE_KB=$(grep "$(basename "$partition_to_zero")$" /proc/partitions 2>/dev/null | awk '{print $3}')
+        
+        if [ -n "$SIZE_KB" ]; then
+            log_msg "Partition size (Rozmiar partycji): ${SIZE_KB}KB"
+        else
+            log_msg "Could not determine partition size from /proc/partitions (Nie można określić rozmiaru partycji z /proc/partitions)"
+        fi
+
+        if [ -b "$partition_to_zero" ]; then
+            log_msg "Zeroing partition $partition_to_zero before deletion / Zerowanie partycji $partition_to_zero przed usunięciem"
+            
+            if [ -n "$SIZE_KB" ] && [ "$SIZE_KB" -ne 0 ] && [ "$SIZE_KB" -lt 10240 ]; then
+                log_msg "Partition smaller than 10MB, zeroing completely (Partycja mniejsza niż 10MB, zerowanie całkowite (${SIZE_KB}KB))"
+                dd if=/dev/zero of="$partition_to_zero" bs=1K count="$SIZE_KB" >> "$LOG_FILE" 2>&1 || true
+            else
+                log_msg "Zeroing first 10MB of partition (Zerowanie pierwszych 10MB partycji)"
+                dd if=/dev/zero of="$partition_to_zero" bs=1M count=10 >> "$LOG_FILE" 2>&1 || true
+            fi
+            sync
+            sleep 1
+        else
+            log_msg "Warning: partition $partition_to_zero not found as block device, skipping zeroing (Ostrzeżenie: partycja $partition_to_zero nie znaleziona jako urządzenie blokowe, pomijanie zerowania)"
+        fi
+    fi
+
+    log_msg "Executing (Wykonywanie): parted -s $DEVICE rm $NUM"
+    parted_cmd "$DEVICE" rm "$NUM" >> "$LOG_FILE" 2>&1
+    rc=$?
+
+    echo $rc > "$RESULT_FILE"
+
+    if [ $rc -eq 0 ]; then
+        log_msg "Partition $NUM deleted successfully from $DEVICE (Partycja $NUM usunięta pomyślnie z $DEVICE)"
+    else
+        log_msg "FAILED to delete partition $NUM from $DEVICE (rc=$rc) (NIE UDAŁO SIĘ usunąć partycji $NUM z $DEVICE (rc=$rc))"
+    fi
+
+    log_msg "Refreshing partition table on device $DEVICE (Odświeżanie tablicy partycji na urządzeniu $DEVICE)"
+    refresh_partitions "$DEVICE"
+    
+    sync
+    sleep 2
+    
+    if command -v partprobe >/dev/null 2>&1; then
+        partprobe "$DEVICE" >> "$LOG_FILE" 2>&1 || true
+    fi
+    
+    if ! disk_has_partitions "$DEVICE"; then
+        log_msg "No partitions left on $DEVICE - removing partition table (Brak partycji na $DEVICE - usuwanie tablicy partycji)"
+        dd if=/dev/zero of="$DEVICE" bs=512 count=1 >> "$LOG_FILE" 2>&1 || true
+        dd if=/dev/zero of="$DEVICE" bs=512 seek=1 count=2047 >> "$LOG_FILE" 2>&1 || true
+        sync
+        sleep 1
+        refresh_partitions "$DEVICE"
+        log_msg "Partition table removed from $DEVICE (Tablica partycji usunięta z $DEVICE)"
+    else
+        log_msg "Other partitions still exist on $DEVICE - keeping partition table (Inne partycje nadal istnieją na $DEVICE - zachowanie tablicy partycji)"
+    fi
+
+    sync
+    
+    log_msg "Partition deletion completed with rc=$rc (Usuwanie partycji zakończone z rc=$rc)"
+    
+    return $rc
+}
+
+##################################################################################################################
+# RESIZE PARTITION / POWIĘKSZANIE PARTYCJI
+##################################################################################################################
+resize_partition() {
+    partition="$1"
+    new_size="$2"
+    unit="$3"
+
+    log_msg "=== Resizing partition $partition to $new_size $unit (Powiększanie partycji $partition do $new_size $unit) ==="
+    log_msg "RESIZE PARTITION PARAMETERS (PARAMETRY POWIĘKSZANIA PARTYCJI):"
+    log_msg "  - Partition (Partycja): $partition"
+    log_msg "  - New size (Nowy rozmiar): $new_size"
+    log_msg "  - Unit (Jednostka): $unit"
+
+    if [ -z "$partition" ]; then
+        log_msg "ERROR: Partition parameter is empty (BŁĄD: Parametr partition jest pusty)"
+        echo 1 > "$RESULT_FILE"
+        return 1
+    fi
+
+    if [ -z "$new_size" ]; then
+        log_msg "ERROR: New size parameter is empty (BŁĄD: Parametr new_size jest pusty)"
+        echo 1 > "$RESULT_FILE"
+        return 1
+    fi
+
+    if [ -z "$unit" ]; then
+        log_msg "ERROR: Unit parameter is empty (BŁĄD: Parametr unit jest pusty)"
+        echo 1 > "$RESULT_FILE"
+        return 1
+    fi
+
+    parse_partition_name "$partition"
+    rc=$?
+    if [ $rc -ne 0 ]; then
+        log_msg "ERROR: Failed to parse partition name (BŁĄD: Nie udało się sparsować nazwy partycji)"
+        echo 1 > "$RESULT_FILE"
+        return 1
+    fi
+
+    if is_device_mounted "$partition"; then
+        log_msg "ERROR: Cannot resize mounted partition (BŁĄD: Nie można powiększyć zamontowanej partycji)"
+        echo 1 > "$RESULT_FILE"
+        return 1
+    fi
+
+    part_info=$(parted -s -m "$DEVICE" unit s print 2>/dev/null | grep "^${NUM}:")
+    if [ -z "$part_info" ]; then
+        log_msg "ERROR: Could not get partition info (BŁĄD: Nie można uzyskać informacji o partycji)"
+        echo 1 > "$RESULT_FILE"
+        return 1
+    fi
+
+    current_start=$(echo "$part_info" | cut -d: -f2 | sed 's/s$//')
+    current_end=$(echo "$part_info" | cut -d: -f3 | sed 's/s$//')
+    current_size=$(echo "$current_end - $current_start" | bc)
+
+    log_msg "Current partition: start=$current_start end=$current_end size=$current_size sectors"
+
+    case "$unit" in
+        MB)
+            new_size_bytes=$(echo "$new_size * 1024 * 1024" | bc)
+            ;;
+        GB)
+            new_size_bytes=$(echo "$new_size * 1024 * 1024 * 1024" | bc)
+            ;;
+        TB)
+            new_size_bytes=$(echo "$new_size * 1024 * 1024 * 1024 * 1024" | bc)
+            ;;
+        *)
+            log_msg "ERROR: Invalid unit '$unit' - supported: MB, GB, TB (BŁĄD: Nieprawidłowa jednostka '$unit' - obsługiwane: MB, GB, TB)"
+            echo 1 > "$RESULT_FILE"
+            return 1
+            ;;
+    esac
+
+    new_size_sectors=$(echo "$new_size_bytes / 512" | bc)
+    log_msg "New size in sectors: $new_size_sectors (Nowy rozmiar w sektorach: $new_size_sectors)"
+
+    new_end=$(echo "$current_start + $new_size_sectors - 1" | bc)
+    log_msg "New end sector: $new_end (current: $current_end) (Nowy sektor końcowy: $new_end (obecny: $current_end))"
+
+    if [ "$new_end" -le "$current_end" ]; then
+        log_msg "WARNING: New size ($new_end) is not larger than current size ($current_end), skipping resize (OSTRZEŻENIE: Nowy rozmiar nie jest większy od obecnego, pomijanie zmiany rozmiaru)"
+        echo 0 > "$RESULT_FILE"
+        return 0
+    fi
+
+    fstype=$(blkid -o value -s TYPE "$partition" 2>/dev/null)
+    log_msg "Filesystem type: ${fstype:-unknown} (Typ systemu plików: ${fstype:-nieznany})"
+
+    case "$fstype" in
+        ext2|ext3|ext4)
+            log_msg "Running e2fsck to check filesystem (Uruchamianie e2fsck w celu sprawdzenia systemu plików)"
+            e2fsck -f -y "$partition" >> "$LOG_FILE" 2>&1
+            fsck_rc=$?
+            
+            if [ $fsck_rc -ne 0 ] && [ $fsck_rc -ne 1 ]; then
+                log_msg "WARNING: e2fsck returned $fsck_rc, but continuing... (OSTRZEŻENIE: e2fsck zwrócił $fsck_rc, ale kontynuuję...)"
+            fi
+            ;;
+    esac
+
+    log_msg "Resizing partition with parted (Powiększanie partycji za pomocą parted)"
+    parted -s "$DEVICE" resizepart "$NUM" "${new_end}s" >> "$LOG_FILE" 2>&1
+    rc=$?
+
+    if [ $rc -ne 0 ]; then
+        log_msg "ERROR: Failed to resize partition with parted (rc=$rc) (BŁĄD: Nie udało się powiększyć partycji za pomocą parted)"
+        echo $rc > "$RESULT_FILE"
+        return $rc
+    fi
+
+    log_msg "Partition resized successfully, refreshing kernel partition table (Partycja powiększona pomyślnie, odświeżanie tablicy partycji)"
+    refresh_partitions "$DEVICE"
+    sleep 2
+
+    wait_for_partition "$partition" 15
+
+    case "$fstype" in
+        ext2|ext3|ext4)
+            log_msg "Resizing ext filesystem with resize2fs (Powiększanie systemu plików ext za pomocą resize2fs)"
+            resize2fs "$partition" >> "$LOG_FILE" 2>&1
+            rc=$?
+            ;;
+        *)
+            log_msg "WARNING: Automatic filesystem resize not supported for $fstype (OSTRZEŻENIE: Automatyczna zmiana rozmiaru systemu plików nie jest obsługiwana dla $fstype)"
+            rc=0
+            ;;
+    esac
+
+    echo $rc > "$RESULT_FILE"
+
+    if [ $rc -eq 0 ]; then
+        log_msg "Filesystem resized successfully (System plików powiększony pomyślnie)"
+    else
+        log_msg "ERROR: Failed to resize filesystem (rc=$rc) (BŁĄD: Nie udało się powiększyć systemu plików)"
+    fi
+
+    sync
+    return $rc
+}
+
+##################################################################################################################
+# FORMAT PARTITION / FORMATOWANIE PARTYCJI
+##################################################################################################################
+format_partition() {
+    device="$1"
+    fstype="$2"
+    label="$3"
+    reserved_space="$4"
+    reserved_unit="$5"
+
+    log_msg "=== Formatting $device as $fstype (Formatowanie $device jako $fstype) ==="
+    log_msg "FORMAT PARAMETERS (PARAMETRY FORMATOWANIA):"
+    log_msg "  - Device (Urządzenie): $device"
+    log_msg "  - Filesystem type (Typ systemu plików): $fstype"
+    log_msg "  - Label (Etykieta): ${label:-<none/brak>}"
+    log_msg "  - Reserved space value (Wartość zarezerwowanego miejsca): ${reserved_space:-<not set/nie ustawiono>}"
+    log_msg "  - Reserved space unit (Jednostka zarezerwowanego miejsca): ${reserved_unit:-<not set/nie ustawiono>}"
+
+    if is_device_mounted "$device"; then
+        umount -l "$device" >> "$LOG_FILE" 2>&1 || true
+        sleep 1
+    fi
+
+    case "$fstype" in
+        ext4|ext3|ext2)
+            cmd="mkfs.$fstype -F"
+            
+            if [ -n "$reserved_unit" ]; then
+                case "$reserved_unit" in
+                    "%")
+                        cmd="$cmd -m ${reserved_space:-0}"
+                        log_msg "Setting reserved space to ${reserved_space:-0}% (Ustawianie zarezerwowanego miejsca na ${reserved_space:-0}%)"
+                        ;;
+                    "MB"|"GB"|"TB")
+                        bytes=""
+                        rsv="${reserved_space:-0}"
+                        case "$reserved_unit" in
+                            "MB") bytes=$(( rsv * 1024 * 1024 / 4096 )) ;;  # Convert to 4K blocks
+                            "GB") bytes=$(( rsv * 1024 * 1024 * 1024 / 4096 )) ;;
+                            "TB") bytes=$(( rsv * 1024 * 1024 * 1024 * 1024 / 4096 )) ;;
+                        esac
+                        if [ "$bytes" -gt 0 ] 2>/dev/null; then
+                            cmd="$cmd -r $bytes"
+                            log_msg "Setting reserved blocks to $bytes (${rsv}${reserved_unit}) (Ustawianie zarezerwowanych bloków na $bytes)"
+                        else
+                            cmd="$cmd -m 0"
+                            log_msg "Setting reserved space to 0% (user specified 0${reserved_unit}) (Ustawianie zarezerwowanego miejsca na 0%)"
+                        fi
+                        ;;
+                esac
+            else
+                log_msg "No reserved space specified, using mkfs default (5%) (Nie określono zarezerwowanego miejsca, używanie domyślnych ustawień mkfs - 5%)"
+            fi
+            
+            [ -n "$label" ] && cmd="$cmd -L \"$label\""
+            
+            cmd="$cmd \"$device\""
+            log_msg "Running mkfs command (Uruchamianie polecenia mkfs): $cmd"
+            eval "$cmd" >> "$LOG_FILE" 2>&1
+            ;;
+        ntfs)
+            [ -n "$label" ] && mkfs.ntfs -f -L "$label" "$device" >> "$LOG_FILE" 2>&1 \
+                             || mkfs.ntfs -f "$device" >> "$LOG_FILE" 2>&1
+            ;;
+        vfat|fat32)
+            [ -n "$label" ] && mkfs.fat -F 32 -n "$label" "$device" >> "$LOG_FILE" 2>&1 \
+                             || mkfs.fat -F 32 "$device" >> "$LOG_FILE" 2>&1
+            ;;
+        f2fs)
+            [ -n "$label" ] && mkfs.f2fs -f -l "$label" "$device" >> "$LOG_FILE" 2>&1 \
+                             || mkfs.f2fs -f "$device" >> "$LOG_FILE" 2>&1
+            ;;
+        swap)
+            [ -n "$label" ] && mkswap -L "$label" "$device" >> "$LOG_FILE" 2>&1 \
+                             || mkswap "$device" >> "$LOG_FILE" 2>&1
+            ;;
+        exfat)
+            [ -n "$label" ] && mkfs.exfat -n "$label" "$device" >> "$LOG_FILE" 2>&1 \
+                             || mkfs.exfat "$device" >> "$LOG_FILE" 2>&1
+            ;;
+        *)
+            log_msg "Unsupported filesystem (Nieobsługiwany system plików): $fstype"
+            echo 1 > "$RESULT_FILE"
+            return 1
+            ;;
+    esac
+
+    rc=$?
+    echo $rc > "$RESULT_FILE"
+    
+    if [ $rc -eq 0 ]; then
+        log_msg "Formatting completed successfully (Formatowanie zakończone pomyślnie) - rc=$rc"
+    else
+        log_msg "ERROR: Formatting failed (BŁĄD: Formatowanie nie powiodło się) - rc=$rc"
+    fi
+
+    base=$(echo "$device" | sed -E 's/p?[0-9]+$//')
+
+    refresh_partitions "$base"
+
+    return $rc
+}
+
+##################################################################################################################
+# WIPE DISK / WYMAZYWANIE DYSKU
+##################################################################################################################
+wipe_disk() {
+    device="$1"
+    
+    log_msg "=== Wiping disk $device (Wymazywanie dysku $device) ==="
+    log_msg "WIPE DISK PARAMETERS (PARAMETRY WYMAZYWANIA DYSKU):"
+    log_msg "  - Device (Urządzenie): $device"
+    
+    if [ -z "$device" ]; then
+        log_msg "ERROR: No device specified (BŁĄD: Nie podano urządzenia)"
+        echo "1" > "$RESULT_FILE"
+        return 1
+    fi
+
+    case "$device" in
+        /dev/*)
+            TARGET_DEVICE="$device"
+            ;;
+        *)
+            TARGET_DEVICE="/dev/$device"
+            ;;
+    esac
+    
+    log_msg "Target device: $TARGET_DEVICE (Urządzenie docelowe: $TARGET_DEVICE)"
+    
+    check_target_path "$TARGET_DEVICE"
+    rc=$?
+    if [ $rc -ne 0 ]; then
+        log_msg "ERROR: Target path validation failed (BŁĄD: Walidacja ścieżki docelowej nie powiodła się)"
+        return $rc
+    fi
+    
+    log_msg "Unmounting all partitions on $TARGET_DEVICE (Odmontowywanie wszystkich partycji na $TARGET_DEVICE)"
+    unmount_device "$TARGET_DEVICE"
+    sleep 2
+    
+    log_msg "Wiping first 10MB of $TARGET_DEVICE (Wymazywanie pierwszych 10MB $TARGET_DEVICE)"
+    dd if=/dev/zero of="$TARGET_DEVICE" bs=1M count=10 >> "$LOG_FILE" 2>&1
+    rc=$?
+    
+    if [ $rc -ne 0 ]; then
+        log_msg "ERROR: Failed to wipe disk (rc=$rc) (BŁĄD: Nie udało się wyczyścić dysku)"
+        echo $rc > "$RESULT_FILE"
+        return $rc
+    fi
+    
+    log_msg "Disk wiped successfully, refreshing partition table (Dysk wyczyszczony pomyślnie, odświeżanie tablicy partycji)"
+    
+    refresh_partitions "$TARGET_DEVICE"
+    
+    log_msg "Wipe operation completed successfully (Operacja wymazywania zakończona pomyślnie)"
+    echo "0" > "$RESULT_FILE"
+    
+    sync
+    return 0
+}
+
+##################################################################################################################
+# JSON API INTERFACE / INTERFEJS API JSON
+##################################################################################################################
+case "$1" in
+    list)
+        json_init
+        json_add_object "create_partition"
+            json_add_string "device" "string"
+            json_add_string "type" "string"
+            json_add_string "fstype" "string"
+            json_add_string "size" "string"
+            json_add_string "layout" "string"
+            json_add_string "label" "string"
+            json_add_string "reserved_space" "string"
+            json_add_string "reserved_unit" "string"
+        json_close_object
+        json_add_object "delete_partition"
+            json_add_string "partition" "string"
+        json_close_object
+        json_add_object "format_partition"
+            json_add_string "device" "string"
+            json_add_string "fstype" "string"
+            json_add_string "label" "string"
+            json_add_string "reserved_space" "string"
+            json_add_string "reserved_unit" "string"
+        json_close_object
+        json_add_object "resize_partition"
+            json_add_string "partition" "string"
+            json_add_string "new_size" "string"
+            json_add_string "unit" "string"
+        json_close_object
+        json_add_object "wipe_disk"
+            json_add_string "device" "string"
+        json_close_object
+        json_add_object "check_operation"
+            json_add_string "pid" "string"
+        json_close_object
+        json_dump
+        ;;
+
+    call)
+        case "$2" in
+
+            create_partition)
+                read input
+                json_load "$input"
+                json_get_var device device
+                json_get_var type type
+                json_get_var fstype fstype
+                json_get_var size size
+                json_get_var layout layout
+                json_get_var label label
+                json_get_var reserved_space reserved_space
+                json_get_var reserved_unit reserved_unit
+
+                (
+                    create_partition_impl "$device" "$type" "${fstype:-ext2}" "${size:-0}" "${layout:-msdos}" "$label" "$reserved_space" "$reserved_unit"
+                    exit $?
+                ) &
+                pid=$!
+                echo $pid > "$PID_FILE"
+
+                json_init; json_add_boolean success 1; json_add_int pid $pid; json_dump
+                ;;
+
+            delete_partition)
+                read input
+                json_load "$input"
+                json_get_var partition partition
+
+                (
+                    delete_partition "$partition"
+                    exit $?
+                ) &
+                pid=$!
+                echo $pid > "$PID_FILE"
+
+                json_init; json_add_boolean success 1; json_add_int pid $pid; json_dump
+                ;;
+
+            format_partition)
+                read input
+                json_load "$input"
+                json_get_var device device
+                json_get_var fstype fstype
+                json_get_var label label
+                json_get_var reserved_space reserved_space
+                json_get_var reserved_unit reserved_unit
+
+                (
+                    format_partition "$device" "$fstype" "$label" "$reserved_space" "$reserved_unit"
+                    exit $?
+                ) &
+                pid=$!
+                echo $pid > "$PID_FILE"
+
+                json_init; json_add_boolean success 1; json_add_int pid $pid; json_dump
+                ;;
+
+            resize_partition)
+                read input
+                log_msg "DEBUG: Raw JSON input: $input"
+                json_load "$input"
+                json_get_var partition partition
+                json_get_var new_size new_size
+                json_get_var unit unit
+                log_msg "DEBUG: Parsed parameters - partition='$partition' new_size='$new_size' unit='$unit'"
+
+                (
+                    resize_partition "$partition" "$new_size" "$unit"
+                    exit $?
+                ) &
+                pid=$!
+                echo $pid > "$PID_FILE"
+
+                json_init; json_add_boolean success 1; json_add_int pid $pid; json_dump
+                ;;
+
+            wipe_disk)
+                read input
+                json_load "$input"
+                json_get_var device device
+
+                (
+                    wipe_disk "$device"
+                    exit $?
+                ) &
+                pid=$!
+                echo $pid > "$PID_FILE"
+
+                json_init; json_add_boolean success 1; json_add_int pid $pid; json_dump
+                ;;
+
+            check_operation)
+                read input
+                json_load "$input"
+                json_get_var pid pid
+
+                if kill -0 "$pid" 2>/dev/null; then
+                    json_init; json_add_boolean running 1; json_dump
+                else
+                    result=1
+                    [ -f "$RESULT_FILE" ] && result=$(cat "$RESULT_FILE")
+                    log=$(tail -n 200 "$LOG_FILE" 2>/dev/null)
+
+                    json_init
+                    json_add_boolean running 0
+                    json_add_int exitcode $result
+                    json_add_string log "$log"
+                    json_dump
+
+                    rm -f "$PID_FILE" "$RESULT_FILE"
+                fi
+                ;;
+
+        esac
+        ;;
+esac
diff --git a/package/luci-app-mini-diskmanager/root/usr/share/luci/menu.d/luci-app-mini-diskmanager.json b/package/luci-app-mini-diskmanager/root/usr/share/luci/menu.d/luci-app-mini-diskmanager.json
new file mode 100644
index 0000000000..40d13390f8
--- /dev/null
+++ b/package/luci-app-mini-diskmanager/root/usr/share/luci/menu.d/luci-app-mini-diskmanager.json
@@ -0,0 +1,41 @@
+{
+	"admin/services/mini-diskmanager": {
+		"title": "Disk Manager",
+		"order": 60,
+		"action": {
+			"type": "firstchild"
+		},
+		"depends": {
+			"acl": [ "luci-app-mini-diskmanager" ],
+			"uci": { "fstab": true }
+		}
+	},
+	
+	"admin/services/mini-diskmanager/minidiskmanager": {
+		"title": "Disk Manager",
+		"order": 10,
+		"action": {
+			"type": "view",
+			"path": "minidiskmanager"
+		}
+	},
+	
+	"admin/services/mini-diskmanager/mdmconfig": {
+		"title": "Configuration",
+		"order": 20,
+		"action": {
+			"type": "view",
+			"path": "mdmconfig"
+		}
+	},
+	
+	"admin/services/mini-diskmanager/mdmsupport": {
+		"title": "Package support",
+		"order": 30,
+		"action": {
+			"type": "view",
+			"path": "mdmsupport"
+		}
+	}
+	
+}
diff --git a/package/luci-app-mini-diskmanager/root/usr/share/rpcd/acl.d/luci-app-mini-diskmanager.json b/package/luci-app-mini-diskmanager/root/usr/share/rpcd/acl.d/luci-app-mini-diskmanager.json
new file mode 100644
index 0000000000..b7627e0c72
--- /dev/null
+++ b/package/luci-app-mini-diskmanager/root/usr/share/rpcd/acl.d/luci-app-mini-diskmanager.json
@@ -0,0 +1,130 @@
+{
+	"luci-app-mini-diskmanager": {
+		"description": "Grant access to LuCI JS Mini Disk Manager",
+		"read": {
+			"ubus": {
+				"minidiskmanager": [
+					"check_operation",
+					"list"
+				]
+			},
+			"cgi-io": ["exec"],
+			"uci": [ "mdmconfig" ],
+			"file": {
+				"/dev": ["list"],
+				"/proc/mounts": ["read"],
+				"/proc/partitions": ["read"],
+				"/sys/block/*/device/model": ["read"],
+				"/sys/block/*/device/vendor": ["read"],
+				"/sys/block/*/device/rescan": ["read", "write"],
+				"/tmp/mini-diskmanager.pid": ["read"],
+				"/tmp/mini-diskmanager.result": ["read"],
+				"/tmp/mini-diskmanager.log": ["read"],
+				"/tmp/diskop.pid": ["read"],
+				"/tmp/diskop.result": ["read"],
+				"/tmp/diskop.log": ["read"],
+				
+				"/etc/mdmconfig": [ "read" ],
+
+				"/usr/bin/lsblk -J -b -o NAME,SIZE,TYPE,FSTYPE,MOUNTPOINT,MODEL /dev/*": ["exec"],
+				"/usr/bin/lsblk -J -b -o NAME,SIZE,TYPE,FSTYPE,MOUNTPOINT,LABEL,UUID,PARTTYPENAME /dev/*": ["exec"],
+				"/usr/bin/lsblk -dno MODEL /dev/*": ["exec"],
+				"/usr/sbin/fdisk -l /dev/*": ["exec"],
+
+				"/sbin/parted /dev/* unit B print free": ["exec"],
+				"/sbin/parted -s /dev/* print": ["exec"],
+				"/sbin/parted -s /dev/* unit s print": ["exec"],
+				"/sbin/parted -s /dev/* unit s print free": ["exec"],
+				"/sbin/parted -s -m /dev/* print": ["exec"],
+				"/sbin/parted -s -m /dev/* unit s print": ["exec"],
+				"/sbin/parted -s -m /dev/* unit s print free": ["exec"],
+
+				"/usr/sbin/blkid -s TYPE -o value /dev/*": ["exec"],
+				"/bin/df -h *": ["exec"],
+				"/bin/df -B1 *": ["exec"],
+				"/bin/mount": ["exec"],
+
+				"/usr/sbin/smartctl --json=c -A /dev/*": ["exec"],
+				"/usr/sbin/smartctl --json=c -A -d sat /dev/*": ["exec"],
+				"/usr/sbin/smartctl --json=c -A -d ata /dev/*": ["exec"],
+				"/usr/sbin/smartctl -i /dev/*": ["exec"],
+				"/usr/sbin/smartctl -i -d sat /dev/*": ["exec"],
+				"/usr/sbin/smartctl -i -d ata /dev/*": ["exec"],
+				"/usr/sbin/smartctl -A /dev/*": ["exec"],
+				"/usr/sbin/smartctl -A -j /dev/*": ["exec"],
+				"/usr/sbin/smartctl -H /dev/*": ["exec"],
+				
+				"/usr/sbin/nvme smart-log /dev/* -o json": ["exec"],
+				"/usr/sbin/nvme id-ctrl /dev/*": ["exec"],
+				
+				"/usr/bin/bc": ["exec"],
+				"/usr/sbin/e2fsck": ["stat"],
+				"/usr/sbin/resize2fs": ["stat"],
+				"/sbin/parted": ["stat"],
+				
+				"/usr/bin/opkg list-installed": ["exec"],
+				"/usr/libexec/package-manager-call list-installed": [ "exec" ],
+				"/usr/libexec/opkg-list installed": [ "exec" ],
+				"/usr/libexec/opkg-call list-installed": [ "exec" ]
+			}
+		},
+		"write": {
+			"ubus": {
+				"minidiskmanager": [
+					"create_partition",
+					"delete_partition",
+					"format_partition",
+					"resize_partition",
+					"wipe_disk"
+				]
+			},
+			"cgi-io": ["exec"],
+			"uci": [ "mdmconfig" ],
+			"file": {
+				"/sys/block/*/device/rescan": ["write"],
+				"/tmp/mini-diskmanager.pid": ["write"],
+				"/tmp/mini-diskmanager.result": ["write"],
+				"/tmp/mini-diskmanager.log": ["write"],
+				
+				"/etc/mdmconfig": ["write"],
+
+				"/sbin/parted /dev/* mklabel *": ["exec"],
+				"/sbin/parted /dev/* mkpart *": ["exec"],
+				"/sbin/parted /dev/* rm *": ["exec"],
+
+				"/sbin/parted -s /dev/* mklabel *": ["exec"],
+				"/sbin/parted -s /dev/* mkpart *": ["exec"],
+				"/sbin/parted -s /dev/* rm *": ["exec"],
+
+				"/sbin/parted -s -m /dev/* mklabel *": ["exec"],
+				"/sbin/parted -s -m /dev/* mkpart *": ["exec"],
+				"/sbin/parted -s -m /dev/* rm *": ["exec"],
+
+				"/sbin/partprobe /dev/*": ["exec"],
+				"/sbin/blockdev --rereadpt /dev/*": ["exec"],
+
+				"/usr/sbin/mkfs.ext4 *": ["exec"],
+				"/usr/sbin/mkfs.ext3 *": ["exec"],
+				"/usr/sbin/mkfs.ext2 *": ["exec"],
+				"/usr/sbin/mkfs.f2fs *": ["exec"],
+				"/usr/sbin/mkfs.ntfs *": ["exec"],
+				"/usr/sbin/mkfs.fat *": ["exec"],
+				"/usr/sbin/mkfs.exfat *": ["exec"],
+				"/usr/sbin/mkswap *": ["exec"],
+
+				"/usr/sbin/e2fsck *": ["exec"],
+				"/usr/sbin/resize2fs *": ["exec"],
+				"/sbin/parted -s /dev/* resizepart *": ["exec"],
+				"/usr/bin/bc": ["exec"],
+
+				"/bin/dd *": ["exec"],
+				"/bin/sync": ["exec"],
+				"/bin/mount *": ["exec"],
+				"/bin/umount *": ["exec"],
+				"/bin/umount -l *": ["exec"],
+				"/bin/umount -f *": ["exec"],
+				"/bin/mkdir *": ["exec"]
+			}
+		}
+	}
+}
-- 
2.51.0

